<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MAXの瓜园</title>
  
  <subtitle>放弃很容易，但坚持一定很酷😎</subtitle>
  <link href="http://watermelondrip.github.io/atom.xml" rel="self"/>
  
  <link href="http://watermelondrip.github.io/"/>
  <updated>2021-05-07T02:15:53.883Z</updated>
  <id>http://watermelondrip.github.io/</id>
  
  <author>
    <name>快乐地瓜🍠</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>位运算</title>
    <link href="http://watermelondrip.github.io/2021/05/06/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://watermelondrip.github.io/2021/05/06/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-05-05T20:19:00.000Z</published>
    <updated>2021-05-07T02:15:53.883Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>位运算<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BD%8D%E8%BF%90%E7%AE%97.md#leetcode-%E9%A2%98%E8%A7%A3---%E4%BD%8D%E8%BF%90%E7%AE%97">刷题顺序</a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><div class="table-container"><table><thead><tr><th>Operator</th><th style="text-align:center">Description</th><th style="text-align:right">Syntax</th></tr></thead><tbody><tr><td>&amp;</td><td style="text-align:center">AND</td><td style="text-align:right">x&amp;y</td></tr><tr><td>‘$</td><td style="text-align:center">$’</td><td style="text-align:right">OR</td><td>x’$</td><td>$’y</td></tr><tr><td>~</td><td style="text-align:center">NOT</td><td style="text-align:right">~x</td></tr><tr><td>&gt;&gt;</td><td style="text-align:center">right shift</td><td style="text-align:right">x&gt;&gt;</td></tr><tr><td>&lt;&lt;</td><td style="text-align:center">left shift</td><td style="text-align:right">x&lt;&lt;</td></tr></tbody></table></div><ul><li>Bitwise AND operator: Returns 1 if both the bits are 1 else 0.<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 10 = 1010 (Binary)</span><br><span class="line">b = 4 =  0100 (Binary</span><br><span class="line">a &amp; b = 1010</span><br><span class="line">         &amp;</span><br><span class="line">        0100</span><br><span class="line">      = 0000</span><br><span class="line">      = 0 (Decimal)</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li>Bitwise or operator: Returns 1 if either of the bit is 1 else 0.</li></ul><p>Example:<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 10 = 1010 (Binary)</span><br><span class="line">b = 4 =  0100 (Binary</span><br><span class="line"></span><br><span class="line">a | b = 1010</span><br><span class="line">         |</span><br><span class="line">        0100</span><br><span class="line">      = 1110</span><br><span class="line">      = 14 (Decimal)</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li><p>Bitwise not operator: Returns one’s compliement of the number.<br>Example:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 10 = 1010 (Binary)</span><br><span class="line"></span><br><span class="line">~a = ~1010</span><br><span class="line">   = -(1010 + 1)</span><br><span class="line">   = -(1011)</span><br><span class="line">   = -11 (Decimal)</span><br></pre></td></tr></tbody></table></figure></li><li><p>Bitwise xor operator: Returns 1 if one of the bit is 1 and other is 0 else returns false.<br>Example:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 10 = 1010 (Binary)</span><br><span class="line">b = 4 =  0100 (Binary</span><br><span class="line"></span><br><span class="line">a &amp; b = 1010</span><br><span class="line">         ^</span><br><span class="line">        0100</span><br><span class="line">      = 1110</span><br><span class="line">      = 14 (Decimal)</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li>Python3 Code:</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python program to show</span></span><br><span class="line"><span class="comment"># bitwise operators</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print bitwise AND operation</span></span><br><span class="line">print(<span class="string">"a &amp; b ="</span>, a &amp; b)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Print bitwise OR operation</span></span><br><span class="line">print(<span class="string">"a | b ="</span>, a | b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print bitwise NOT operation</span></span><br><span class="line">print(<span class="string">"~a ="</span>, ~a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print bitwise XOR operation</span></span><br><span class="line">print(<span class="string">"a ^ b ="</span>, a ^ b)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Output:<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &amp; b = <span class="number">0</span></span><br><span class="line">a | b = <span class="number">14</span></span><br><span class="line">~a = -<span class="number">11</span></span><br><span class="line">a ^ b = <span class="number">14</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>Shift Operators<br>These operators are used to shift the bits of a number left or right thereby multiplying or dividing the number by two respectively. They can be used when we have to multiply or divide a number by two. </p><ul><li>Bitwise right shift: Shifts the bits of the number to the right and fills 0 on voids left as a result. Similar effect as of dividing the number with some power of two.</li></ul><p>Example:<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">a &gt;&gt; 1 = 5 </span><br><span class="line"></span><br><span class="line">a = -10 </span><br><span class="line">a &gt;&gt; 1 = -5</span><br></pre></td></tr></tbody></table></figure><p></p><p>Bitwise left shift: Shifts the bits of the number to the left and fills 0 on voids left as a result. Similar effect as of multiplying the number with some power of two.<br>Example: </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 5 = 0000 0101</span><br><span class="line">b = -10 = 1111 0110</span><br><span class="line"></span><br><span class="line">a &lt;&lt; 1 = 0000 1010 = 10</span><br><span class="line">a &lt;&lt; 2 = 0001 0100 = 20 </span><br><span class="line"></span><br><span class="line">b &lt;&lt; 1 = 0000 1010 = -20</span><br><span class="line">b &lt;&lt; 2 = 0001 0100 = -40 </span><br></pre></td></tr></tbody></table></figure><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p><a href="https://www.geeksforgeeks.org/python-bitwise-operators/">look</a></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>利用<code>x^1 = ~x</code>，可以将一个数的位级表示翻转。利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>^<span class="number">1</span>^<span class="number">2</span> = <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>只想保留最后一位</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0b101</span></span><br><span class="line">n = n&amp;<span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">0b1</span></span><br><span class="line">n = <span class="number">0b10</span> </span><br><span class="line">n = n&amp;<span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">0b0</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  其中 nn 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：<script type="math/tex">O(1)</script>。</li></ul></li></ul><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="LC461-汉明距离-汉明距离"><a href="#LC461-汉明距离-汉明距离" class="headerlink" title="(LC461)  汉明距离  汉明距离"></a>(LC461)  汉明距离  <a href="https://leetcode-cn.com/problems/hamming-distance/">汉明距离</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p><p>注意：<br>0 ≤ x, y &lt; 231.<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。 </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。</li><li>使用 z&amp;(z-1) 去除 z 位级表示最低的那一位。</li><li>可以使用 Integer.bitcount() 来统计 1 个的个数。</li></ul><h4 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        xor = x^y</span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> xor:</span><br><span class="line">            <span class="keyword">if</span> xor%<span class="number">2</span>:</span><br><span class="line">                distance+=<span class="number">1</span></span><br><span class="line">            xor = xor&gt;&gt;<span class="number">1</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> distance</span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC136-只出现一次的数字-只出现一次的数字"><a href="#LC136-只出现一次的数字-只出现一次的数字" class="headerlink" title="(LC136)  只出现一次的数字  只出现一次的数字"></a>(LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>异或<h4 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res = res^num</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC268-268-丢失的数字-268-丢失的数字"><a href="#LC268-268-丢失的数字-268-丢失的数字" class="headerlink" title="(LC268)  268. 丢失的数字 268. 丢失的数字"></a>(LC268)  268. 丢失的数字 <a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>异或<h4 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            res = res^num^i</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC260-260-只出现一次的数字-III-260-只出现一次的数字-III"><a href="#LC260-260-只出现一次的数字-III-260-只出现一次的数字-III" class="headerlink" title="(LC260)  260. 只出现一次的数字 III  260. 只出现一次的数字 III"></a>(LC260)  260. 只出现一次的数字 III  <a href="https://leetcode-cn.com/problems/single-number-iii/description/">260. 只出现一次的数字 III</a></h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br><span class="line">解释：[5, 3] 也是有效的答案。</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC190-190-颠倒二进制位-190-颠倒二进制位"><a href="#LC190-190-颠倒二进制位-190-颠倒二进制位" class="headerlink" title="(LC190)  190. 颠倒二进制位  190. 颠倒二进制位"></a>(LC190)  190. 颠倒二进制位  <a href="https://leetcode-cn.com/problems/reverse-bits/description/">190. 颠倒二进制位</a></h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>颠倒给定的 32 位无符号整数的二进制位。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br><span class="line">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class="line">     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-4"><a href="#大佬题解-4" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC231-231-Power-of-Two-231-Power-of-Two"><a href="#LC231-231-Power-of-Two-231-Power-of-Two" class="headerlink" title="(LC231)  231. Power of Two  231. Power of Two"></a>(LC231)  231. Power of Two  <a href="https://leetcode-cn.com/problems/power-of-two/">231. Power of Two</a></h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: true</span><br><span class="line">解释: 20 = 1</span><br></pre></td></tr></tbody></table></figure><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-6"><a href="#Python3-Code-6" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;=<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> n &gt;<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">if</span> (n&amp;<span class="number">1</span>) == <span class="number">0</span>: <span class="comment"># 取最后一位，判断是不是0</span></span><br><span class="line">                n = n&gt;&gt;<span class="number">1</span></span><br><span class="line">               </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span> <span class="comment">#4的幂</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> n &gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">3</span>) == <span class="number">0</span>:</span><br><span class="line">                n = n&gt;&gt;<span class="number">2</span></span><br><span class="line">                print(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-5"><a href="#大佬题解-5" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC693-693-交替位二进制数-693-交替位二进制数"><a href="#LC693-693-交替位二进制数-693-交替位二进制数" class="headerlink" title="(LC693)  693. 交替位二进制数  693. 交替位二进制数"></a>(LC693)  693. 交替位二进制数  <a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/description/">693. 交替位二进制数</a></h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：true</span><br><span class="line">解释：5 的二进制表示是：101</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-7"><a href="#Python3-Code-7" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasAlternatingBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        a = n ^(n&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (a &amp;(a+<span class="number">1</span>)) == <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析 </li><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-6"><a href="#大佬题解-6" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC476-476-数字的补数-476-数字的补数"><a href="#LC476-476-数字的补数-476-数字的补数" class="headerlink" title="(LC476)  476. 数字的补数  476. 数字的补数"></a>(LC476)  476. 数字的补数  <a href="https://leetcode-cn.com/problems/number-complement/">476. 数字的补数</a></h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>给你一个 正 整数 num，输出它的补数。补数是对该数的二进制表示取反。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：</p><p>mask |= mask &gt;&gt; 1    11000000<br>mask |= mask &gt;&gt; 2    11110000<br>mask |= mask &gt;&gt; 4    11111111</p><h4 id="Python3-Code-8"><a href="#Python3-Code-8" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        tmp = num </span><br><span class="line">      </span><br><span class="line">        tmp = tmp | tmp&gt;&gt;<span class="number">1</span></span><br><span class="line">         </span><br><span class="line">        tmp = tmp | tmp&gt;&gt;<span class="number">2</span></span><br><span class="line">         </span><br><span class="line">        tmp = tmp | tmp&gt;&gt;<span class="number">4</span></span><br><span class="line">        </span><br><span class="line">        tmp = tmp | tmp&gt;&gt;<span class="number">8</span></span><br><span class="line">         </span><br><span class="line">        tmp = tmp | tmp&gt;&gt;<span class="number">16</span></span><br><span class="line">      </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> tmp^num  </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-7"><a href="#大佬题解-7" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC136-只出现一次的数字-只出现一次的数字-1"><a href="#LC136-只出现一次的数字-只出现一次的数字-1" class="headerlink" title="(LC136)  只出现一次的数字  只出现一次的数字"></a>(LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-9"><a href="#Python3-Code-9" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-8"><a href="#大佬题解-8" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC136-只出现一次的数字-只出现一次的数字-2"><a href="#LC136-只出现一次的数字-只出现一次的数字-2" class="headerlink" title="(LC136)  只出现一次的数字  只出现一次的数字"></a>(LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-10"><a href="#Python3-Code-10" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-9"><a href="#大佬题解-9" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC136-只出现一次的数字-只出现一次的数字-3"><a href="#LC136-只出现一次的数字-只出现一次的数字-3" class="headerlink" title="(LC136)  只出现一次的数字  只出现一次的数字"></a>(LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-11"><a href="#Python3-Code-11" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-LC136-只出现一次的数字-只出现一次的数字"><a href="#大佬题解-LC136-只出现一次的数字-只出现一次的数字" class="headerlink" title="大佬题解##  (LC136)  只出现一次的数字  只出现一次的数字"></a>大佬题解##  (LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h4><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-12"><a href="#Python3-Code-12" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-LC136-只出现一次的数字-只出现一次的数字-1"><a href="#大佬题解-LC136-只出现一次的数字-只出现一次的数字-1" class="headerlink" title="大佬题解##  (LC136)  只出现一次的数字  只出现一次的数字"></a>大佬题解##  (LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h4><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-13"><a href="#Python3-Code-13" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-LC136-只出现一次的数字-只出现一次的数字-2"><a href="#大佬题解-LC136-只出现一次的数字-只出现一次的数字-2" class="headerlink" title="大佬题解##  (LC136)  只出现一次的数字  只出现一次的数字"></a>大佬题解##  (LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h4><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-14"><a href="#Python3-Code-14" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-LC136-只出现一次的数字-只出现一次的数字-3"><a href="#大佬题解-LC136-只出现一次的数字-只出现一次的数字-3" class="headerlink" title="大佬题解##  (LC136)  只出现一次的数字  只出现一次的数字"></a>大佬题解##  (LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h4><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-15"><a href="#Python3-Code-15" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-LC136-只出现一次的数字-只出现一次的数字-4"><a href="#大佬题解-LC136-只出现一次的数字-只出现一次的数字-4" class="headerlink" title="大佬题解##  (LC136)  只出现一次的数字  只出现一次的数字"></a>大佬题解##  (LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h4><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-16"><a href="#Python3-Code-16" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-LC136-只出现一次的数字-只出现一次的数字-5"><a href="#大佬题解-LC136-只出现一次的数字-只出现一次的数字-5" class="headerlink" title="大佬题解##  (LC136)  只出现一次的数字  只出现一次的数字"></a>大佬题解##  (LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h4><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-17"><a href="#Python3-Code-17" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-10"><a href="#大佬题解-10" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC136-只出现一次的数字-只出现一次的数字-4"><a href="#LC136-只出现一次的数字-只出现一次的数字-4" class="headerlink" title="(LC136)  只出现一次的数字  只出现一次的数字"></a>(LC136)  只出现一次的数字  <a href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h2><h3 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-18"><a href="#Python3-Code-18" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><pre><code>- 复杂度分析 </code></pre><ul><li>时间复杂度：$O(1)$,  在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</li><li>空间复杂度：$O(1)$,  使用恒定大小的空间。 </li></ul><h4 id="大佬题解-11"><a href="#大佬题解-11" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣数据类型" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣算法" scheme="http://watermelondrip.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数学</title>
    <link href="http://watermelondrip.github.io/2021/05/06/%E6%95%B0%E5%AD%A6/"/>
    <id>http://watermelondrip.github.io/2021/05/06/%E6%95%B0%E5%AD%A6/</id>
    <published>2021-05-05T14:00:00.000Z</published>
    <updated>2021-05-06T08:44:57.256Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常见运算"><a href="#常见运算" class="headerlink" title="常见运算"></a>常见运算</h1><h2 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h2><p>每一个数都可以分解成素数的乘积，例如 <script type="math/tex">84 = 2^2 * 3^1 * 5^0 * 7^1 * 11^0 * 13^0 * 17^0 * ...</script></p><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>令 <script type="math/tex">x = 2^{m0} * 3^{m1} * 5^{m2} * 7^{m3} * 11^{m4 }* …</script></p><p>令 <script type="math/tex">y = 2^{n0} * 3^{n1} * 5^{n2} * 7^{n3} * 11^{n4} * …</script></p><p>如果 x  整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h2 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h2><p>x 和 y 的最大公约数为：<script type="math/tex">gcd(x,y) = 2^{min(m0,n0)} * 3^{min(m1,n1)} * 5^{min(m2,n2)} * ...</script></p><p>x 和 y 的最小公倍数为：<script type="math/tex">lcm(x,y) = 2^{max(m0,n0)} * 3^{max(m1,n1)} * 5^{max(m2,n2)} * ...</script></p><h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="LC204-204-计数质数-计数质数"><a href="#LC204-204-计数质数-计数质数" class="headerlink" title="(LC204 ) 204. 计数质数  计数质数"></a>(LC204 ) 204. 计数质数  <a href="https://leetcode-cn.com/problems/count-primes/">计数质数</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>统计所有小于非负整数 n 的质数的数量。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。<br>我们考虑这样一个事实：如果 xx 是质数，那么大于 xx 的 xx 的倍数 2x,3x,\ldots2x,3x,… 一定不是质数，因此我们可以从这里入手。<br>我们设 <code>[i]isPrime[i]</code>表示数 <code>i</code> 是不是质数，如果是质数则为 1，否则为  0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即  0，这样在运行结束的时候我们即能知道质数的个数。 </p><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        notPrimes = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            <span class="keyword">if</span> notPrimes[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i**<span class="number">2</span>,n,i):</span><br><span class="line">                notPrimes[j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(nlogn)</script> 双层迭代 </li><li>空间复杂度：<script type="math/tex">O(n)</script> </li></ul></li></ul><h2 id="LC1819-序列中不同最大公约数的数目-序列中不同最大公约数的数目"><a href="#LC1819-序列中不同最大公约数的数目-序列中不同最大公约数的数目" class="headerlink" title="(LC1819 )  序列中不同最大公约数的数目 序列中不同最大公约数的数目"></a>(LC1819 )  序列中不同最大公约数的数目 <a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个由正整数组成的数组 <code>nums</code> 。<br>数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。<br>例如，序列 [4,6,16] 的最大公约数是 2 。<br>数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。<br>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。<br>计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>动态规划</li></ul><h4 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n^2)</script> 双层迭代 </li><li>空间复杂度：<script type="math/tex">O((n+1)*(n+1))</script> </li></ul></li></ul><h5 id="大佬"><a href="#大佬" class="headerlink" title="大佬"></a>大佬</h5><h3 id="LC"><a href="#LC" class="headerlink" title="(LC )    "></a>(LC )   <a href=""> </a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>动态规划</li></ul><h4 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><h5 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n^2)</script> 双层迭代 </li><li>空间复杂度：<script type="math/tex">O((n+1)*(n+1))</script> </li></ul></li></ul><h5 id="大佬-1"><a href="#大佬-1" class="headerlink" title="大佬"></a>大佬</h5><h3 id="LC-1"><a href="#LC-1" class="headerlink" title="(LC )    "></a>(LC )   <a href=""> </a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>动态规划</li></ul><h4 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><h5 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n^2)</script> 双层迭代 </li><li>空间复杂度：<script type="math/tex">O((n+1)*(n+1))</script> </li></ul></li></ul><h5 id="大佬-2"><a href="#大佬-2" class="headerlink" title="大佬"></a>大佬</h5><h3 id="LC-2"><a href="#LC-2" class="headerlink" title="(LC )    "></a>(LC )   <a href=""> </a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>动态规划</li></ul><h4 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><h5 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n^2)</script> 双层迭代 </li><li>空间复杂度：<script type="math/tex">O((n+1)*(n+1))</script> </li></ul></li></ul><h5 id="大佬-3"><a href="#大佬-3" class="headerlink" title="大佬"></a>大佬</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣算法" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python小教程</title>
    <link href="http://watermelondrip.github.io/2021/05/05/Python%E5%B0%8F%E6%95%99%E7%A8%8B%20(5)/"/>
    <id>http://watermelondrip.github.io/2021/05/05/Python%E5%B0%8F%E6%95%99%E7%A8%8B%20(5)/</id>
    <published>2021-05-05T06:16:20.783Z</published>
    <updated>2021-05-06T11:23:15.674Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python-Introduction"><a href="#Python-Introduction" class="headerlink" title="Python Introduction"></a>Python Introduction</h1><h2 id="Python-Keywords-关键词"><a href="#Python-Keywords-关键词" class="headerlink" title="Python Keywords(关键词)"></a>Python Keywords(关键词)</h2><p>关键词是指在Python中，保留的单词。我们不可以把关键词当作变量名variable name, 函数名，或者是其他标识符。关键词除了<code>True</code>，<code>False</code>，<code>None</code>，其他都是小写的。here is the complete <a href="https://www.programiz.com/python-programming/keyword-list">list of all the keywords</a> with examples</p><h2 id="Python-标识符"><a href="#Python-标识符" class="headerlink" title="Python 标识符"></a>Python 标识符</h2><p>标识符是一个名字，可以用来区别不同的<code>class</code>，<code>functions</code>，<code>variables</code></p><h3 id="标识符规则"><a href="#标识符规则" class="headerlink" title="标识符规则"></a>标识符规则</h3><ul><li>可以由各种小写字母或者数字表示或者是下划线<code>_</code>，比如名字为<code>MyDest</code>,<code>v_1</code></li><li>不能由数字开头</li><li>关键词不能做标识符，比如：<code>global = 1</code>是不运行的，如果执行会报错<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"&lt;interactive input&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">global</span> = <span class="number">1</span></span><br><span class="line">           ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></tbody></table></figure></li><li>不能用特殊符号比如<code>!,@</code>等。比如运行<code>a@ = 0</code>,会报错<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"&lt;interactive input&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    a@ = <span class="number">0</span></span><br><span class="line">     ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></tbody></table></figure></li><li>标识符长度不限</li></ul><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><p>python 是一个区分大小写（case-sensitive）语言。</p><h2 id="Python-Statement-语句-Indentation-缩进-and-Comments-注释"><a href="#Python-Statement-语句-Indentation-缩进-and-Comments-注释" class="headerlink" title="Python  Statement(语句), Indentation(缩进) and Comments(注释)"></a>Python  Statement(语句), Indentation(缩进) and Comments(注释)</h2><h3 id="Python-Statement-语句"><a href="#Python-Statement-语句" class="headerlink" title="Python  Statement(语句)"></a>Python  Statement(语句)</h3><p>Python 的运行需要执行语句。例如，<code>a = 1</code>是一个赋值语句。<code>if</code>语句等等。</p><h4 id="Multi-line-statement-多行语句"><a href="#Multi-line-statement-多行语句" class="headerlink" title="Multi-line statement 多行语句"></a>Multi-line statement 多行语句</h4><p>在Python中，我们可以用 行继续符（line continuation charater）<code>\</code>来把一个长的语句，变成多行语句来方便阅读。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + \</span><br><span class="line">    <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + \</span><br><span class="line">    <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure><br>这是一个明确的行继续符。 在Python里，行继续符直接应用在 parentheses ( ), brackets [ ], and braces { }里。例如<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> +</span><br><span class="line">    <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> +</span><br><span class="line">    <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span>)</span><br><span class="line">colors = [<span class="string">'red'</span>,</span><br><span class="line">          <span class="string">'blue'</span>,</span><br><span class="line">          <span class="string">'green'</span>]</span><br></pre></td></tr></tbody></table></figure><br>我们也可以用semicolons分号区别多个语句。例如<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>; b = <span class="number">2</span>; c = <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="Python-Indentation-缩进"><a href="#Python-Indentation-缩进" class="headerlink" title="Python  Indentation(缩进)"></a>Python  Indentation(缩进)</h3><p>Python美好的地方就是用缩进。<br>一个程序块开始于缩进，结束于第一个取消缩进的那行。一般用四个whitespaces用作缩进。为了可读性，不支持把缩进取消，比如：<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>: print(<span class="string">'Hello'</span>); a = <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><br>上面这个代码块可读性就比较差，如果换成下面的code，可读性就高了<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'Hello'</span>)</span><br><span class="line">    a = <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><br>所以莫装逼哟！<p></p><h3 id="Python-Comments-注释"><a href="#Python-Comments-注释" class="headerlink" title="Python  Comments(注释)"></a>Python  Comments(注释)</h3><p>注释在写程序的过程中是非常重要的。注释可以描述在这段程序在做一个什么事，可以帮助别人在看这段源代码的时候，就不那么头疼和想吐了。<br>在写程序的时候，其实很有可能会忘记一些很关键的步骤和细节。所以花些时间来写这些注释绝对是有意义的。<br>Python中，我们用hash(#)符号来写注释部分。比如<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#This is a comment</span></span><br><span class="line"><span class="comment">#print out Hello</span></span><br><span class="line">print(<span class="string">'Hello'</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Multi-line-comments-多行注释"><a href="#Multi-line-comments-多行注释" class="headerlink" title="Multi-line comments(多行注释)"></a>Multi-line comments(多行注释)</h4><p>python 中除了刚刚提到的用hash#注释之外，也可以用<code>``和</code>“””`。<br>比如<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""This is also a</span></span><br><span class="line"><span class="string">perfect example of</span></span><br><span class="line"><span class="string">multi-line comments"""</span></span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="Docstrings-文档字符串"><a href="#Docstrings-文档字符串" class="headerlink" title="Docstrings (文档字符串)"></a>Docstrings (文档字符串)</h4><p>Docstrings 是 documentation string 的缩写，意思是文档字符串。<br>Python的文档字符串是一行字符串在定义一个函数，方法，类或者模型后面。Triple quotes用于写文档字符串。<br>比如<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="string">"""Function to double the value"""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*num</span><br></pre></td></tr></tbody></table></figure><br>The docstrings are associated with the object as their <strong>doc</strong> attribute.<p></p><p>我们可以读取函数的docstrings<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="string">"""Function to double the value"""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*num</span><br><span class="line">print(double.__doc__)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Function to double the value</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="Python-Variables-变量-Constants-常熟-and-Literals-关键词"><a href="#Python-Variables-变量-Constants-常熟-and-Literals-关键词" class="headerlink" title="Python Variables(变量), Constants(常熟) and Literals (关键词)"></a>Python Variables(变量), Constants(常熟) and Literals (关键词)</h2><h3 id="Python-Variables-变量"><a href="#Python-Variables-变量" class="headerlink" title="Python Variables(变量)"></a>Python Variables(变量)</h3><p>一个变量（Variable）其实是一个被命名的地址，这个地址用来在存储器里来存储数据的。也可以理解成，变量是一个容器，这个容器可以装着数据data，在程序里，这个容器可以进行改变。<br>例如<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><br>我们创建了一个新的变量叫做<code>number</code>。我们把<code>10</code>这个数值assign to the variable(分配给了这个变量)。<br>我们也可以这么想，变量是一个大书包，这个书包里可以放很多的书，同时这些书也可以随时被其他的书替代。<br>例如：<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">10</span></span><br><span class="line">number = <span class="number">1.1</span></span><br></pre></td></tr></tbody></table></figure><br>我们初始<code>number</code>的值是<code>10</code>。过了一瞬间，就一会会儿，他就变成了<code>1.1</code>了。<br><strong>Note: 其实python里， 严格的说，我们实际上不是把value（数值）赋给了变量。其实是Python gives the reference of the object(value) to the variable。（这个我们后面再解释</strong><p></p><h4 id="Assigning-values-to-Variables-分配数值给变量"><a href="#Assigning-values-to-Variables-分配数值给变量" class="headerlink" title="Assigning values to Variables (分配数值给变量)"></a>Assigning values to Variables (分配数值给变量)</h4><p>我觉得中文里很难找到一个合适的词来描述assign这个动作，所有后面我有时候会写assign，而不翻译成英文了。</p><p>用上面的例子看到了我们可以用assginment操作<code>=</code>来assign一个数组给变量。</p><ul><li><p>Example 1: Declaring and assigning value to a variable</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">website = <span class="string">"apple.com"</span></span><br><span class="line">print(website)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apple.com</span><br></pre></td></tr></tbody></table></figure><p>在上面的程序里，我们可以把值<code>apple.com</code>分配给变量<code>website</code>。 然后我们打印出这个变量，这个被分配了<code>apple.com</code>的变量，<code>apple.com</code>。<br><strong>Note:  Python是一个type-inferred语言（隐式类型），所以我们不需要明确的定义出变量的类型。比如例子中，python 自动的就可以知道<code>apple.com</code>是字符串，然后接下来，声明变量<code>website</code>为字符串 </strong></p></li><li><p>Example 2: Changing the value of a variable</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">website = <span class="string">"apple.com"</span></span><br><span class="line">print(website)</span><br><span class="line"></span><br><span class="line"><span class="comment"># assigning a new value to website</span></span><br><span class="line">website = <span class="string">"programiz.com"</span></span><br><span class="line"></span><br><span class="line">print(website)</span><br><span class="line">&gt;&gt;&gt;apple.com</span><br><span class="line">&gt;&gt;&gt;programiz.com</span><br></pre></td></tr></tbody></table></figure><p>在上面的程序里，我们把初始值<code>apple.com</code>分配给变量<code>website</code>。 然后 这个变量又被改成了<code>programiz.com</code>。</p></li><li><p>Example 3: Assigning multiple values to multiple variables</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">5</span>, <span class="number">3.2</span>, <span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (b)</span><br><span class="line"><span class="built_in">print</span> (c)</span><br></pre></td></tr></tbody></table></figure><h3 id="Python-Constan-常量"><a href="#Python-Constan-常量" class="headerlink" title="Python Constan(常量)"></a>Python Constan(常量)</h3><p>Constant是一种变量，这种变量的值是不可变的。是不是很绕哈哈哈，所以说这时候，把变量这个概念理解成容器是很方便的，就是说constant是一种耿直的容器哈哈哈。也就是说，constant 是一个容器，这个容器里面保存的这些信息，是不可以改变的。<br>我们同时也可以把constant理解成一个书包，里面同样也放了很多的书，但是这些书可是被替换不了的，一次也不可以的！</p></li></ul><h4 id="Assigning-value-to-constant-in-Python"><a href="#Assigning-value-to-constant-in-Python" class="headerlink" title="Assigning value to constant in Python"></a>Assigning value to constant in Python</h4><p>在Python里，constants常常用来被declared(声明)和assgined(分配)在一个module(模块)里。module（模块。Module是一个新的文件，这个文件包括 variables, functions, etc。Module 可以被导入到主文件里。在module 里，常量一般用大写字母表示，同时用下划线把词和词直接分隔开。</p><ul><li>Example 3: Declaring and assigning value to a constant<br>(1） Create a constant.py:<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.14</span></span><br><span class="line">GRAVITY = <span class="number">9.8</span></span><br></pre></td></tr></tbody></table></figure>(2） Create a main.py:<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> constant</span><br><span class="line">print(constant.PI)</span><br><span class="line">print(constant.GRAVITY)</span><br></pre></td></tr></tbody></table></figure>（3）Output:<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">9.8</span></span><br></pre></td></tr></tbody></table></figure>在上面的程序里，我们创建了一个<code>constant.py</code>模块文件。然后我们分配给常量值<code>3.14</code>，<code>9.8</code>给常量<code>PI</code>和<code>GRAVITY</code>。然后我们由创建了主文件<code>main.py</code>，导入<code>constant</code>模块。最后打印常数值。</li></ul><h3 id="Rules-and-Naming-Convention-for-Variables-and-constants-（命名规范）"><a href="#Rules-and-Naming-Convention-for-Variables-and-constants-（命名规范）" class="headerlink" title="Rules and Naming Convention for Variables and constants （命名规范）"></a>Rules and Naming Convention for Variables and constants （命名规范）</h3><ul><li>常量变量名应该是由大写小写和下划线组成<code>snake_caseMACRO_CASEcamelCaseCapWords</code></li><li>命名的名字要意义，比如，<code>vowel</code>比<code>v</code>在程序中更容易理解</li><li>如果你想创建一个变量名字由两个单词组成，两个单词中间需要用下划线分开<code>my_name</code></li><li>通常用大写字母来declare常量constant，比如<code>PI</code>,<code>G</code></li><li>不要用特殊符号@#￥，也不要用数字来开头</li></ul><h2 id="Literals-（这个真的不知道怎么翻译-后面慢慢想吧）"><a href="#Literals-（这个真的不知道怎么翻译-后面慢慢想吧）" class="headerlink" title="Literals （这个真的不知道怎么翻译,后面慢慢想吧）"></a>Literals （这个真的不知道怎么翻译,后面慢慢想吧）</h2><p>Literal是给定变量和常量的原始数据。在Python里由很多中种不同的不同的literals:</p><h3 id="Numeric-Literals"><a href="#Numeric-Literals" class="headerlink" title="Numeric Literals"></a>Numeric Literals</h3><p>Numeric Literals是不可变的（immutable）。Numeric Literals可以包含三种类型：<code>Integer</code>，<code>Float</code>，<code>Complex</code>。</p><ul><li>Example 4: How to use Numeric literals in Python?<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0b1010</span> <span class="comment">#Binary Literals</span></span><br><span class="line">b = <span class="number">100</span> <span class="comment">#Decimal Literal </span></span><br><span class="line">c = <span class="number">0o310</span> <span class="comment">#Octal Literal</span></span><br><span class="line">d = <span class="number">0x12c</span> <span class="comment">#Hexadecimal Literal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Float Literal</span></span><br><span class="line">float_1 = <span class="number">10.5</span> </span><br><span class="line">float_2 = <span class="number">1.5e2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Complex Literal </span></span><br><span class="line">x = <span class="number">3.14j</span></span><br><span class="line"></span><br><span class="line">print(a, b, c, d)</span><br><span class="line">print(float_1, float_2)</span><br><span class="line">print(x, x.imag, x.real)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> <span class="number">100</span> <span class="number">200</span> <span class="number">300</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10.5</span> <span class="number">150.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3.14j</span> <span class="number">3.14</span> <span class="number">0.0</span></span><br></pre></td></tr></tbody></table></figure>在上面的程序里<br>（1) We assigned integer literals into different variables.<code>a</code>是一个二进制literal。<code>b</code>是个十进制literal。<code>c</code>是个八进制literal。<code>d</code>是个十六进制literal。<br>(2) 当我们print变量时，所有的Literals被转换成了十进制值。<br>（3） <code>10.5</code>和<code>1.5e2</code>是浮点literals。</li></ul><h3 id="String-Literals"><a href="#String-Literals" class="headerlink" title="String Literals"></a>String Literals</h3><p>String Literal是一连串的characters(字符)用引号引起来。我们用单双三引号。</p><ul><li>Example 7: How to use string literals in Python?<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">strings = <span class="string">"This is Python"</span></span><br><span class="line">char = <span class="string">"C"</span></span><br><span class="line">multiline_str = <span class="string">"""This is a multiline string with more than one line code."""</span></span><br><span class="line">unicode = <span class="string">u"\u00dcnic\u00f6de"</span></span><br><span class="line">raw_str = <span class="string">r"raw \n string"</span></span><br><span class="line"></span><br><span class="line">print(strings)</span><br><span class="line">print(char)</span><br><span class="line">print(multiline_str)</span><br><span class="line">print(unicode)</span><br><span class="line">print(raw_str)</span><br></pre></td></tr></tbody></table></figure>Output:<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This <span class="keyword">is</span> Python</span><br><span class="line">C</span><br><span class="line">This <span class="keyword">is</span> a multiline string <span class="keyword">with</span> more than one line code.</span><br><span class="line">Ünicöde</span><br><span class="line">raw \n string</span><br></pre></td></tr></tbody></table></figure>在上面的程序中，<code>This is Python</code>是一个string literal <code>C</code>是一个character literal。<br>在三引号的里的值<code>"""This is a multiline string with more than one line code."""</code>被配置给了<code>multiline_str</code>，是一个multi-line string literal。<br>字符串（String）<code>u"\u00dcnic\u00f6de"</code>是一个unicode literal，支持字符，而不是英文。这里面<code>\u00dc</code> 表示 <code>Ü</code> and <code>\u00f6</code>表示 <code>ö</code>。</li></ul><p><code>r"raw \n string"</code>中的<code>r</code>使得字符串是个raw string literal，忽略了中间的一些特殊符号</p><h3 id="Boolean-Literals"><a href="#Boolean-Literals" class="headerlink" title="Boolean Literals"></a>Boolean Literals</h3><p>Boolean Literals就两种值<code>True</code>或<code>False</code>。</p><ul><li>Example 8: How to use boolean literals in Python?<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="number">1</span> == <span class="literal">True</span>)</span><br><span class="line">y = (<span class="number">1</span> == <span class="literal">False</span>)</span><br><span class="line">a = <span class="literal">True</span> + <span class="number">4</span></span><br><span class="line">b = <span class="literal">False</span> + <span class="number">10</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"x is"</span>, x)</span><br><span class="line">print(<span class="string">"y is"</span>, y)</span><br><span class="line">print(<span class="string">"a:"</span>, a)</span><br><span class="line">print(<span class="string">"b:"</span>, b)</span><br></pre></td></tr></tbody></table></figure>Output:<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">y <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">a: <span class="number">5</span></span><br><span class="line">b: <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>在上面的程序里，我们用boolean literal<code>True</code>和<code>False</code>。<code>True</code>用<code>1</code>来表示它的值，<code>False</code>用<code>0</code>来表示它的值。<code>x</code>的值是<code>True</code>是因为<code>1</code>等于<code>True</code>。<code>y</code>的值是<code>False</code>是因为<code>1</code>不等于<code>False</code>。<code>a</code>的值是<code>5</code>因为加了<code>True</code>,因此加了一个<code>1</code>在<code>4</code>。<code>b</code>的值是<code>10</code>因为加了<code>False</code>,因此加了一个<code>0</code>在<code>10</code>。</li></ul><h3 id="Special-Literals"><a href="#Special-Literals" class="headerlink" title="Special Literals"></a>Special Literals</h3><p>Python 只有一个特殊Literal，是<code>None</code>。我们用它来表示空。</p><h3 id="Literal-集合"><a href="#Literal-集合" class="headerlink" title="Literal 集合"></a>Literal 集合</h3><p>四种不同的literal集合，List literals, Tuple literals, Dict literals, , Set literals。</p><ul><li>Example 10: How to use literals collections in Python?<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">"apple"</span>, <span class="string">"mango"</span>, <span class="string">"orange"</span>] <span class="comment">#list</span></span><br><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">#tuple</span></span><br><span class="line">alphabets = {<span class="string">'a'</span>:<span class="string">'apple'</span>, <span class="string">'b'</span>:<span class="string">'ball'</span>, <span class="string">'c'</span>:<span class="string">'cat'</span>} <span class="comment">#dictionary</span></span><br><span class="line">vowels = {<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span> , <span class="string">'o'</span>, <span class="string">'u'</span>} <span class="comment">#set</span></span><br><span class="line"></span><br><span class="line">print(fruits)</span><br><span class="line">print(numbers)</span><br><span class="line">print(alphabets)</span><br><span class="line">print(vowels)</span><br></pre></td></tr></tbody></table></figure>Output:<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'orange'</span>]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">{<span class="string">'a'</span>: <span class="string">'apple'</span>, <span class="string">'b'</span>: <span class="string">'ball'</span>, <span class="string">'c'</span>: <span class="string">'cat'</span>}</span><br><span class="line">{<span class="string">'e'</span>, <span class="string">'a'</span>, <span class="string">'o'</span>, <span class="string">'i'</span>, <span class="string">'u'</span>}</span><br></pre></td></tr></tbody></table></figure>在上面的程序里，我们创建了一个列表（有的也叫序列，英文名都一个叫List)，一个元组tuple,一个字典dictionary，一个集合set（集合（set）是一个无序的不重复元素序列）。 </li></ul><h2 id="Python-数据类型"><a href="#Python-数据类型" class="headerlink" title="Python 数据类型"></a>Python 数据类型</h2><h3 id="Python数据类型"><a href="#Python数据类型" class="headerlink" title="Python数据类型"></a>Python数据类型</h3><p>Python 中，每个值都有一个数据类型。因为在每一个object(对象)，数据类型实际是类和变量的例子。</p><h3 id="Python-Numbers数字"><a href="#Python-Numbers数字" class="headerlink" title="Python Numbers数字"></a>Python Numbers数字</h3><p>整型，浮点数，复数，是PYthon 的数字类型。被定义为<code>int</code>，<code>float</code>，<code>complex</code>类。<br>我们用<code>type()</code>函数来分别变量或者值属于哪一类。其中<code>isinstance()</code>function 是用来确认这个对象object 是否是属于某一种特殊的类。比如：<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">print(a, <span class="string">"is of type"</span>, <span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line">a = <span class="number">2.0</span></span><br><span class="line">print(a, <span class="string">"is of type"</span>, <span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>+<span class="number">2j</span></span><br><span class="line">print(a, <span class="string">"is complex number?"</span>, <span class="built_in">isinstance</span>(<span class="number">1</span>+<span class="number">2j</span>,<span class="built_in">complex</span>))</span><br></pre></td></tr></tbody></table></figure><br>Output:<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="keyword">is</span> of <span class="built_in">type</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">2.0 <span class="title">is</span> <span class="title">of</span> <span class="title">type</span> &lt;<span class="title">class</span> '<span class="title">float</span>'&gt;</span></span><br><span class="line"><span class="class">(<span class="params"><span class="number">1</span>+<span class="number">2j</span></span>) <span class="title">is</span> <span class="title">complex</span> <span class="title">number</span>? <span class="title">True</span></span></span><br></pre></td></tr></tbody></table></figure><br>整型可以是任何长度，只要是存储Memory允许。<br>一个浮点数的精度可以到小数点后15位。整数和浮点数通过是否存在小数点区分开。<code>1</code>是整数，<code>1.0</code>是浮点数。<br>复数的形式是<code>x+yj</code>,其中<code>x</code>是实数部分，<code>y</code>是虚数部分。<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1234567890123456789</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1234567890123456789</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">0.1234567890123456789</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">0.12345678901234568</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">1</span>+<span class="number">2j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br></pre></td></tr></tbody></table></figure><br>需要注意的是，<code>float</code>变量<code>b</code>被截短了。<p></p><h3 id="Python-List-列表"><a href="#Python-List-列表" class="headerlink" title="Python List(列表)"></a>Python List(列表)</h3><p>列表(List)是一有序序列。是Python 里最常用的数据结构，而且很灵活。列表里的所有项不需要是相同的数据类型。<br>表示一个列表是很直接的。 列表的每一项(item)通过都好区分开，同时被<code>[]</code>框框起来。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2.2</span>, <span class="string">'python'</span>]</span><br></pre></td></tr></tbody></table></figure><br>我们可以用切片操作符slicing operator<code>[]</code>来提取一项或者一串。Python 里，列表的序号是从<code>0</code>开始取的。<p></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">35</span>,<span class="number">40</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># a[2] = 15</span></span><br><span class="line">print(<span class="string">"a[2] = "</span>, a[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># a[0:3] = [5, 10, 15]</span></span><br><span class="line">print(<span class="string">"a[0:3] = "</span>, a[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># a[5:] = [30, 35, 40]</span></span><br><span class="line">print(<span class="string">"a[5:] = "</span>, a[<span class="number">5</span>:])</span><br></pre></td></tr></tbody></table></figure><p>Output<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>] =  <span class="number">15</span></span><br><span class="line">a[<span class="number">0</span>:<span class="number">3</span>] =  [<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]</span><br><span class="line">a[<span class="number">5</span>:] =  [<span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>]</span><br></pre></td></tr></tbody></table></figure><br>列表是可以mutable，也就是可变的。列表的每个元素的值都是可以改变的。<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### python Tuple(元组)</span></span><br><span class="line">元组和列表一样是有序的。这里的有序是序号有序的意思。 和列表唯一的区别是元组是不可变的。 元组一旦被创建出来，就不能改变了。</span><br><span class="line"></span><br><span class="line">元组用来做write-protect data(写保护的数据)比列表要快。</span><br><span class="line"></span><br><span class="line">元组定义在括号里`()`，里面的每项通过逗号区分开。</span><br><span class="line">```python</span><br><span class="line">t = (<span class="number">5</span>,<span class="string">'program'</span>, <span class="number">1</span>+<span class="number">3j</span>)</span><br></pre></td></tr></tbody></table></figure><br>我们可以通过切片操作来提取项，但是不能改变<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">5</span>,<span class="string">'program'</span>, <span class="number">1</span>+<span class="number">3j</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># t[1] = 'program'</span></span><br><span class="line">print(<span class="string">"t[1] = "</span>, t[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># t[0:3] = (5, 'program', (1+3j))</span></span><br><span class="line">print(<span class="string">"t[0:3] = "</span>, t[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generates error</span></span><br><span class="line"><span class="comment"># Tuples are immutable</span></span><br><span class="line">t[<span class="number">0</span>] = <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><br>Output：<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">1</span>] =  program</span><br><span class="line">t[<span class="number">0</span>:<span class="number">3</span>] =  (<span class="number">5</span>, <span class="string">'program'</span>, (<span class="number">1</span>+<span class="number">3j</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    t[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">TypeError: <span class="string">'tuple'</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="Python-Strings-字符串"><a href="#Python-Strings-字符串" class="headerlink" title="Python Strings 字符串"></a>Python Strings 字符串</h3><p>字符串是一系列的Unicode characters。 我们可以用单引号和双引号来表示字符串。多行字符可以通过三个引号，三个单引号或者三个双引号来表示。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"This is a string"</span></span><br><span class="line">print(s)</span><br><span class="line">s = <span class="string">'''A multiline</span></span><br><span class="line"><span class="string">string'''</span></span><br><span class="line">print(s)</span><br></pre></td></tr></tbody></table></figure><br>Output<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This <span class="keyword">is</span> a string</span><br><span class="line">A multiline</span><br><span class="line">string</span><br></pre></td></tr></tbody></table></figure><br>和列表，元组一样，切片操作<code>[]</code>也可以被用在字符串上，然而，字符串是不可变的。<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello world!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s[4] = 'o'</span></span><br><span class="line">print(<span class="string">"s[4] = "</span>, s[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s[6:11] = 'world'</span></span><br><span class="line">print(<span class="string">"s[6:11] = "</span>, s[<span class="number">6</span>:<span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generates error</span></span><br><span class="line"><span class="comment"># Strings are immutable in Python</span></span><br><span class="line">s[<span class="number">5</span>] =<span class="string">'d'</span></span><br></pre></td></tr></tbody></table></figure><br>Output:<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">4</span>] =  o</span><br><span class="line">s[<span class="number">6</span>:<span class="number">11</span>] =  world</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;string&gt;"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="python-set-（集合）"><a href="#python-set-（集合）" class="headerlink" title="python set （集合）"></a>python set （集合）</h3><p>集合是没有顺序的不重复的项的集合。 集合set定义在花括号<code>{}</code>里，逗号分开。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>}</span><br><span class="line"></span><br><span class="line"><span class="comment"># printing set variable</span></span><br><span class="line">print(<span class="string">"a = "</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data type of variable a</span></span><br><span class="line">print(<span class="built_in">type</span>(a))</span><br></pre></td></tr></tbody></table></figure><br>Output:<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a =  {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">set</span>'&gt;</span></span><br></pre></td></tr></tbody></table></figure><br>我们在集合上实现操作比如联通和交叉两个集合。集合的每个值都是唯一的，集合操作也可用来消除重复。<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>}</span><br><span class="line">print(a) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br></pre></td></tr></tbody></table></figure><br>因为集合是无序的一个集合，所以序号index对于集合来说是没有意义的。因此切片操作在集合上是没办法实现的。<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;string&gt;"</span>, line <span class="number">301</span>, <span class="keyword">in</span> runcode</span><br><span class="line">  File <span class="string">"&lt;interactive input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'set'</span> <span class="built_in">object</span> does <span class="keyword">not</span> support indexing</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="python-Dictionary-（字典）"><a href="#python-Dictionary-（字典）" class="headerlink" title="python Dictionary （字典）"></a>python Dictionary （字典）</h3><p>字典是由key-value对组成的无序集合。一般我们有很大的数据的时候，我们会想到用字典。 字典对于检索数据来说是最优的。但是我们需要知道key 才能检索到value。<br>在Python 里，字典定义在<code>{}</code>里，每项是的形式是一个对<code>key:value</code>。key 和value 可以是任何的数据类型。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = {<span class="number">1</span>:<span class="string">'value'</span>,<span class="string">'key'</span> = <span class="number">2</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(d)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br></pre></td></tr></tbody></table></figure><br>我们可以通过key 来检索到相应的value。不可以用value来检索到key哟。not the other way around.<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d = {<span class="number">1</span>:<span class="string">'value'</span>,<span class="string">'key'</span>:<span class="number">2</span>}</span><br><span class="line">print(<span class="built_in">type</span>(d))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"d[1] = "</span>, d[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"d['key'] = "</span>, d[<span class="string">'key'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generates error</span></span><br><span class="line">print(<span class="string">"d[2] = "</span>, d[<span class="number">2</span>])</span><br></pre></td></tr></tbody></table></figure><br>Output:<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line">d[1] = value</span><br><span class="line">d[<span class="string">'key'</span>] = <span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;string&gt;"</span>, line <span class="number">9</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="数据类型之间相互转换"><a href="#数据类型之间相互转换" class="headerlink" title="数据类型之间相互转换"></a>数据类型之间相互转换</h3><p>python 可以很方便的把各种数据类型进行转换，比如<code>int()</code>,<code>float()</code>,<code>str()</code>等<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="number">5</span>)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="number">10.6</span>) <span class="comment">#make it closet to 0</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(-<span class="number">10.6</span>) <span class="comment">#make it closet to 0</span></span><br><span class="line">-<span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>({<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>})</span><br><span class="line">(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="string">'hello'</span>)</span><br><span class="line">[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">{<span class="number">1</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">4</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="number">3</span>,<span class="number">26</span>),(<span class="number">4</span>,<span class="number">44</span>)])</span><br><span class="line">{<span class="number">3</span>: <span class="number">26</span>, <span class="number">4</span>: <span class="number">44</span>}</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="python-文件"><a href="#python-文件" class="headerlink" title="python 文件"></a>python 文件</h2><p>文件被定义在disk 的一个位置，用来存储相关的信息，他们用来永远保存数据在non-volatile的存储器里（比如硬盘）<br>因为在Random Access Memory (RAM) 是volatile(易失性的)(当电脑关机的时候，会丢失数据)，我们用文件为了以后不知道未来的某一时刻用，所以我们需要永久保存他们。<br>当我们想读或者写一个文件的时候，我们需要打开他。当我们完成之后，需要把资源解放，但是要和文件紧紧的绑在一起。<br>因此，在PYthon里，一个文件的操作发生以下的顺序里：</p><ol><li>打开一个文件</li><li>读或者写（进行操作）</li><li>关闭一个文件</li></ol><h3 id="python-里打开文件"><a href="#python-里打开文件" class="headerlink" title="python 里打开文件"></a>python 里打开文件</h3><p>Python有个内嵌的函数可以打开文件<code>open()</code>。这个函数返回return 一个文件对象，也叫做一个handle(句柄)，可以用来读或者相对应的改变文件<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">"test.txt"</span>) <span class="comment"># 打开一个current directory 的文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">"C:/Readme.txt"</span>) <span class="comment">#specifying full path</span></span><br></pre></td></tr></tbody></table></figure><br>当我们打开一个文件的时候，我们可以指定一个模式。 在模式里，我们可以确定我们想读<code>r</code>，写<code>w</code>或添加<code>a</code>在一个文件上进行操作。我们也可以选择我们想要打开的在text模式里还是在binary模式。<br>默认模式是在text上读， 在这个模式，我们获取的是字符串当我们读文件。另一方面，二进制模式返回的是比特，这个模式用来处理非text文件像图片或者可执行文件。<p></p><div class="table-container"><table><thead><tr><th>Mode</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td><code>r</code></td><td style="text-align:center">打开一个文件来读</td></tr><tr><td><code>w</code></td><td style="text-align:center">打开一个文件来写，当没有这个文件的时候，创建一个文件。如果存在这个文件的时候， 删截这个文件</td></tr><tr><td><code>x</code></td><td style="text-align:center">打开一个文件用来操作第一次，如果文件存在，则操作失败</td></tr><tr><td><code>t</code></td><td style="text-align:center">打开text模式</td></tr><tr><td><code>b</code></td><td style="text-align:center">打开二进制模式</td></tr><tr><td><code>+</code></td><td style="text-align:center">打开文件为了更新（读或者写）</td></tr></tbody></table></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">"test.txt"</span>)      <span class="comment"># equivalent to 'r' or 'rt'</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">"test.txt"</span>,<span class="string">'w'</span>)  <span class="comment"># write in text mode</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">"img.bmp"</span>,<span class="string">'r+b'</span>) <span class="comment"># read and write in binary mode</span></span><br></pre></td></tr></tbody></table></figure><p>不像其他的语言，字符串<code>a</code>不表示数字97，除非被编码<code>ASCII</code>码。 此外，默认的编码和平台是相关的。在windows下是<code>cp1252</code>，Linux下是<code>utf-8</code>。<br>所以我们必须不仅仅考虑默认的编码形式也需要考虑不同的Platform上不同的形式。<br>因此，当我们处理text模式的时候，我们强烈建议特别指出编码的类型<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, mode=<span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="python-里关闭文件"><a href="#python-里关闭文件" class="headerlink" title="python 里关闭文件"></a>python 里关闭文件</h3><p>当我们结束对文件的操作的时候，我们需要关闭文件。关闭一个文件会空出来资源，资源仅仅的和文件绑在一起。执行函数是<code>close()</code>。<br>python有一个垃圾收集器，用来清理没有引用的对像，这些对象和我们关闭文件没有任何关系。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">"text.txt"</span>,encoding =<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># performing file operation </span></span><br><span class="line">f.write(<span class="string">'hello world !'</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></tbody></table></figure><p></p><p>这个方法不是很安全。如果出现一个异常的时候，代码在并且没有执行关闭文件。<br>一个更安全的方式是用<code>try...finally</code>块<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>：</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">"text.txt"</span>,encoding = <span class="string">'utf-8'</span>)</span><br><span class="line">    f.write(<span class="string">'hello world'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">f = close()</span><br></pre></td></tr></tbody></table></figure><br><code>finally</code>模块的的作用其实是，不管是否有异常错误发生 或者try 里面的执行完了，都执行finally 块里的语句。<p></p><p>其实，最好的用来关闭文件的方法是使用<code>with</code>声明。 这个可以保证文件关闭当with里面有声明。其实我理解的意思是，with 可以自动的关闭文件。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"text.txt"</span>,encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="comment"># performing file operation </span></span><br><span class="line">    f.write(<span class="string">'hello world'</span>)</span><br></pre></td></tr></tbody></table></figure><br>我们可以看出来最后的那种方式<code>with</code>中，是没有<code>f.close()</code>这个语句的。<code>with</code>声明就神奇在可以保证合适的释放和获取资源。<p></p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>为了在python里写文件，我们需要先打开文件，然后开始写<code>w</code>，然后添加通过<code>a</code>或者<code>x</code>。<br>我们需要很小心用这个<code>w</code>模式，因为如果这个文件本身已经存在的话，很容易就没注意 ，然后就把以前的文件覆盖了，最后就找不到以前的文件了。<br>写一个字符串或者比特，我们用<code>write()</code>方法。这个方法返回很多字符串。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"text.txt"</span>,<span class="string">'w'</span>,encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(<span class="string">"my first file \n"</span>)</span><br><span class="line">    f.write(<span class="string">"This file\n\n"</span>)</span><br><span class="line">    f.write(<span class="string">"contains three lines\n"</span>)</span><br></pre></td></tr></tbody></table></figure><br>这段程序将创建一个新的文件叫做<code>test.txt</code>在当前的目录下，如果不存在这个名的文件的时候被第一次创建出来，如果存在这个名字的文件的话，会被覆盖的overwrite.<br>需要注意的是，使用<code>write</code>进行写的时候，如果要想向文件写入多行数据的时候，不会自动给各行添加换行符(newline characters)，我们需要加换行符，因为我们在读的时候，读取各行数据的同时，我们还读取了行尾的换行符。<p></p><h3 id="读文件了"><a href="#读文件了" class="headerlink" title="读文件了"></a>读文件了</h3><p>为了用Python来读文件，我们必须打开文件用<code>r</code>这个模式。<br>在Python里有好几种方式来通过Python读取文件。我们用<code>read(size)</code> 方法来读取size 数量的数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>排序 （熟到可以默写）</title>
    <link href="http://watermelondrip.github.io/2021/05/05/%E6%8E%92%E5%BA%8F/"/>
    <id>http://watermelondrip.github.io/2021/05/05/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-05-04T17:59:00.000Z</published>
    <updated>2021-05-04T17:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>排序<a href="https://github.com/CyC·2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%8E%92%E5%BA%8F.md">顺序</a></p><p>思路是：</p><p>（1）快速选择，用于求解第k个元素的问题</p><p>（2）堆:堆的中心就一个，那就是动态求极值。 堆可以用二叉树实现，叫做二叉堆。二叉堆的性质就是堆的性质不变。</p><p> (3) 三向快排： 快排的核心思想是选择一个枢纽，左边的都比枢纽小，右边的都比枢纽大。 然后堆分成的两部分再进行递归快排。 但是如果有很多重复元素的时候呢，因为快排会对一个都是重复元素的数组再进行递归，其实我们已经知道了， 不用再进行递归了，因为已经是有序的了。 怎么实现呢？</p><pre><code>- 三向排序： 对于一个数组，一次扫描要有三个指针。</code></pre><h2 id="1-LC215-Kth-Element-Kth-Element"><a href="#1-LC215-Kth-Element-Kth-Element" class="headerlink" title="1. (LC215) Kth Element Kth Element"></a>1. (LC215) Kth Element <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">Kth Element</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br> 示例 1：<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的是排序想法，直接把数组排序，然后找到k个就好了</li><li>堆， 堆是一种数据结构，一个很牛的<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ge-chong-pai-xu-suan-fa-tu-xie-zong-jie-by-ke-ai-x/">题解</a>和一个英文<a href="https://towardsdatascience.com/data-structure-heap-23d4c78a6962">解释</a> 和一个中文<a href="https://guguoyu.blog.csdn.net/article/details/81283998?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs">解释</a></li><li><a href="https://docs.python.org/3/library/heapq.html">heapq</a> 模块： 可能在面试过程中，有的面试官不让用，但是这个heapq还是很方便的。 (1)hq.heapqpush(heap,item) ：压入堆的意思，压入的是item （2）hq.heappop(heap)：弹出且返回最小的。hq.heappushpop(heap,item):先压入iem，然后弹出堆里最小的项。</li></ol><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest1</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment">#1. 排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest2</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 2. 最大堆  用heapq模块</span></span><br><span class="line">        <span class="keyword">import</span> heapq <span class="keyword">as</span> hq</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            hq.heappush(heap,i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                hq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest3</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 3.  最大堆， 构造堆模块</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">min_heapify</span>(<span class="params">array, i</span>):</span></span><br><span class="line">            left = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            length = <span class="built_in">len</span>(array) - <span class="number">1</span></span><br><span class="line">            smallest = i</span><br><span class="line">            <span class="keyword">if</span> left &lt;= length <span class="keyword">and</span> array[i] &gt; array[left]:</span><br><span class="line">                smallest = left</span><br><span class="line">            <span class="keyword">if</span> right &lt;= length <span class="keyword">and</span> array[smallest] &gt; array[right]:</span><br><span class="line">                smallest = right</span><br><span class="line">            <span class="keyword">if</span> smallest != i:</span><br><span class="line">                array[i], array[smallest] = array[smallest], array[i]</span><br><span class="line">                min_heapify(array, smallest)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_min_heap</span>(<span class="params">array</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(array)//<span class="number">2</span>)):</span><br><span class="line">                min_heapify(array, i)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">array</span>):</span></span><br><span class="line">            <span class="comment">#array = array.copy()</span></span><br><span class="line">            build_min_heap(array)</span><br><span class="line">            sorted_array = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">                array[<span class="number">0</span>], array[-<span class="number">1</span>] = array[-<span class="number">1</span>], array[<span class="number">0</span>]</span><br><span class="line">                sorted_array.append(array.pop())</span><br><span class="line">                min_heapify(array, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sorted_array</span><br><span class="line">        result = heapsort(nums)</span><br><span class="line">        <span class="keyword">return</span> result[-k]</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest4</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 4. 快速排序 [快速排序](https://jackkuo666.github.io/Data_Structure_with_Python_book/chapter6/section4.html)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">alist, low ,high</span>):</span></span><br><span class="line">            mid_value = alist[low]</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid_value:</span><br><span class="line">                    high-=<span class="number">1</span></span><br><span class="line">                alist[low] = alist[high]</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt;= mid_value:</span><br><span class="line">                    low+=<span class="number">1</span></span><br><span class="line">                alist[high] = alist[low]</span><br><span class="line">            alist[low] = mid_value</span><br><span class="line">            <span class="keyword">return</span> low</span><br><span class="line">        k = <span class="built_in">len</span>(nums) - k</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums) -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            p = partition(nums,low ,high)</span><br><span class="line">            <span class="keyword">if</span> k &lt; p:</span><br><span class="line">                high = p - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> k &gt; p:</span><br><span class="line">                low = p + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[p]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">         </span><br></pre></td></tr></tbody></table></figure><h2 id="2-LC347-前-K-个高频元素-前-K-个高频元素"><a href="#2-LC347-前-K-个高频元素-前-K-个高频元素" class="headerlink" title="2. (LC347) 前 K 个高频元素 前 K 个高频元素"></a>2. (LC347) 前 K 个高频元素 <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前 K 个高频元素</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素<br> 示例 1：<br>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的是排序想法，直接把数组排序，但是不满足时间复杂度的要求， 这里有个一个点是sort()函数，单独有一篇文章讲。</li><li>进一步，为了满足时间复杂度的要求，需要对解法一的排序过程进行改进。因为最终需要返回前k个频率最大的元素，可以想到借助堆这种数据结构。通过维护一个元素数目为k的最小堆，每次都将新的元素与对顶端的元素（也就是堆中频率最小的元素）进行比较，如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中。最终，堆中的k个元素即为前k个高频元素。 其中用到了.items(), #The items() method returns a view object. The view object contains the key-value pairs of the dictionary, as tuples in a list.</li><li>桶排序(bucket sort)，用空间复杂度换取时间复杂度的方法。为每一个数字设置一个桶，桶中是该数字出现的次数，然后对桶进行排序，实际上，上面的排序算法就说使用普通的排序方法对频率桶进行了排序，现在我们使用桶排序对频次惊醒排序。 桶排序为了进一步优化时间复杂度。 先统计数组中元素的频次。接着，将数组中的元素按着出现频次进行分组，即出现频次为i的元素存放在第i个桶，最后从桶中逆序取出前k个元素。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_1</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 1. 排序</span></span><br><span class="line">        freq_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums: <span class="comment"># 统计元素的频率</span></span><br><span class="line">            freq_dict[num] = freq_dict.get(num , <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        freq_dict_sort = <span class="built_in">sorted</span>(freq_dict.items(), key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line">        ret = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            ret.append(freq_dict_sort[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_2</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 2. 堆排序</span></span><br><span class="line">freq_dict = <span class="built_in">dict</span>() <span class="comment"># 统计元素的频率</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">freq_dict[num] = freq_dict.get(num,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 维护一个大小为k的最小堆，使得堆中的元素即为前k个高频元素</span></span><br><span class="line">pq = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> freq_dict.items(): </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pq)&lt; k:</span><br><span class="line">heapq.heappush(pq, (value,key))</span><br><span class="line"><span class="keyword">elif</span> value &gt; pq[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">heapq.heapreplace(pq, (value,key))</span><br><span class="line">ret = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">while</span> pq:</span><br><span class="line">ret.append(heapq.heappop(pq)[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_3</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 3. 桶排序</span></span><br><span class="line">freq_dict = <span class="built_in">dict</span>() <span class="comment"># 统计元素频率</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">freq_dict[num] = freq_dict.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+ <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> freq_dict.items():</span><br><span class="line">bucket[value].append(key)</span><br><span class="line">ret = <span class="built_in">list</span>() <span class="comment">#  逆序取出前k个元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(nums))):</span><br><span class="line"><span class="keyword">if</span> bucket[i]:</span><br><span class="line">ret.extend(bucket[i])</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ret)&gt;=k:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> ret[:k]</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ol><li>排序</li></ol><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(n)$ : 最极端的情况下（每个元素都不同），用于存储元素及其频率的map需要存储n个键值对</li></ul><ol><li>堆排序</li></ol><ul><li>时间复杂度：$O(nlogk)$ 其中n表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是O(n);接着，遍历用于存储元素频率的map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这一系列操作的时间复杂度是O(nlogk)的；最后，弹出堆中的元素所需要的时间复杂度O(klogk)。因此总的时间复杂度是O(nlogk)</li><li>空间复杂度：$O(n)$</li></ul><ol><li>桶排序</li></ol><ul><li>时间复杂度：$O(n)$ 数组的长度</li><li>空间复杂度：$O(n)$</li></ul><h2 id="3-LC75-颜色分类-颜色分类"><a href="#3-LC75-颜色分类-颜色分类" class="headerlink" title="3. (LC75) 颜色分类 颜色分类"></a>3. (LC75) 颜色分类 <a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></tbody></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>三路快排</li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul><li>在快排的基础上，将组数分为三个部分，及大于、等于、小于三个部分，其中大于和小于部分继续递归快排  </li><li>（lc官方解题）我们使用一个指针ptr表示头部位置的范围，ptr中存储了一个整数，表示数组nums从位置0到位置ptr - 1都属于【头部】。ptr的初始值为0，表示还没数处于【头部】。 在第一次遍历中，我们从左向右遍历整个数组，如果找到了0，那么就需要将0与【头部】位置的元素位置进行交换，并将【头部】向后扩充一位，结束后头部只有0。第二次同上。但是我们想要一次遍历怎么办，我们就要俩个指针。 </li><li>我们用指针p0 来交换 0， p1来交换1，初始值都是0。当从左向右遍历整个数组时:<br>  (1) 如果找到1， 那么将其与nums[p1]进行交换，并将p1向后移动一个位置。<br>  （2) 如果找到了0， 那么将其与nums[p0]交换的话，可能把1也交换出去。当p0 &lt; p1时，我们需要再将nums[i] 与nums[p1]进行交换，其中</li></ul><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>双指针</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        p0 = p1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                nums[i] , nums[p1] = nums[p1] , nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i] , nums[p0] = nums[p0] , nums[i]</span><br><span class="line">                <span class="keyword">if</span> p0 &lt; p1:</span><br><span class="line">                    nums[i] , nums[p1] = nums[p1] , nums[i]</span><br><span class="line">                p0+=<span class="number">1</span></span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="大佬解题"><a href="#大佬解题" class="headerlink" title="大佬解题"></a>大佬解题</h3><ol><li><a href="https://www.cnblogs.com/xugenpeng/p/9950007.html#%E6%8F%8F%E8%BF%B0">【LeetCode题解】347_前K个高频元素（Top-K-Frequent-Elements）</a></li></ol><h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。</p><p>以 1,2,3,4,5,6 为例，其排列依次为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">123456</span><br><span class="line">123465</span><br><span class="line">123546</span><br><span class="line">...</span><br><span class="line">654321</span><br></pre></td></tr></tbody></table></figure><p>可以看到有这样的关系：123456 &lt; 123465 &lt; 123546 &lt; … &lt; 654321。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        left = <span class="built_in">len</span>(nums)-<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[left] &gt;= nums[left+<span class="number">1</span>]:</span><br><span class="line">            left-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;=<span class="number">0</span>:</span><br><span class="line">            right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[right] &lt;= nums[left]:</span><br><span class="line">                right -=<span class="number">1</span></span><br><span class="line">                print(right)</span><br><span class="line">            nums[right],nums[left] = nums[left], nums[right]</span><br><span class="line">       </span><br><span class="line">        left+=<span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt; right:</span><br><span class="line">            </span><br><span class="line">            nums[right],nums[left] = nums[left], nums[right]</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">            right-=<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="LC56-56-合并区间"><a href="#LC56-56-合并区间" class="headerlink" title="(LC56) 56. 合并区间"></a>(LC56) 56. 合并区间</h2><p> <a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></p><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        merged = []</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="comment"># 如果列表为空，或者当前区间与上一区间不重合，直接添加</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> merged[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">                merged.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则的话，我们就可以与上一区间进行合并</span></span><br><span class="line">                merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(nlogn)$. 其中n为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的$O(nlogn)$.</li><li>空间复杂度：$O(logn)$. 排序所需要的空间</li></ul>]]></content>
    
    
    <summary type="html">快速选择，堆，三向快排</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣算法" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>动态规划 - 打家劫舍</title>
    <link href="http://watermelondrip.github.io/2021/05/05/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>http://watermelondrip.github.io/2021/05/05/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2021-05-04T14:00:00.000Z</published>
    <updated>2021-05-05T20:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>打家劫舍是一系列很经典的问题，这个问题大概是假设一个什么样的场景呢？</p><ol><li>可以通过求一堆子问题的解，来求出原问题的解。</li><li>每个子问题的解是和前面的子问题有关 ，和后面的子问题无关</li><li>每个子问题要求最大值，并且该点的选取会影响这个点附近的值的选择与否，也就是说每个点和附近的点有关联性，但是这种关联不会延伸到很远。</li></ol><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">nums</span>):</span></span><br><span class="line">    len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">    first, second = nums[<span class="number">0</span>], <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, len_nums):</span><br><span class="line">        first, second = second , <span class="built_in">max</span>(first + nums[i], second)</span><br><span class="line">    <span class="keyword">return</span> second</span><br></pre></td></tr></tbody></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ol><li>首先是first 和 second,我觉得这个其中的奥秘是，选第一个还是选第二个，如果选第二个就不能选第一个了</li><li>第三个数和以后的数呢， 选第三个数的时候就意味着不能选第二个了，但是可以选第一个了，所以第一个数得到的最大值就可以直接像接力棒接力似的，让第三棒接着跑了。</li></ol><h1 id="LC198-打家劫舍-打家劫舍"><a href="#LC198-打家劫舍-打家劫舍" class="headerlink" title="(LC198) 打家劫舍   打家劫舍"></a>(LC198) 打家劫舍   <a href="https://leetcode-cn.com/problems/house-robber/description/">打家劫舍</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">偷窃到的最高金额 = 1 + 3 = 4 。 </span><br></pre></td></tr></tbody></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>动态方程 <script type="math/tex">dp[i] = max(dp[i-1], dp[i-2] + nums[i])</script></li></ul><h4 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><h5 id="数组存储"><a href="#数组存储" class="headerlink" title="数组存储"></a>数组存储</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n)</script>,其中 <script type="math/tex">n</script>是数组长度。只需要对数组遍历一次。 </li><li>空间复杂度：<script type="math/tex">O(n)</script>。使用数组存储结果。</li></ul></li></ul><h5 id="滚动数组存储"><a href="#滚动数组存储" class="headerlink" title="滚动数组存储"></a>滚动数组存储</h5><p>考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额有关，因此我们使用滚动数组，也就是每个时刻至保存前两间房屋的最高总金额。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp0 = nums[<span class="number">0</span>]</span><br><span class="line">        dp1 = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        first,second = dp0,dp1 </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            second,first =<span class="built_in">max</span>(second,first+nums[i]), second </span><br><span class="line">            print(<span class="string">'first,second ='</span>,first,second)</span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n)</script>,其中 <script type="math/tex">n</script>是数组长度。只需要对数组遍历一次。 </li><li>空间复杂度：<script type="math/tex">O(1)</script>。使用滚动数组存储结果。</li></ul></li></ul><h3 id="LC213-打家劫舍-II-打家劫舍-II"><a href="#LC213-打家劫舍-II-打家劫舍-II" class="headerlink" title="(LC213)  打家劫舍 II   打家劫舍 II"></a>(LC213)  打家劫舍 II   <a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></tbody></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>环形排列意味着第一个房子和最后一个房子只能选一个，因此环状排列问题化为两个单排排列房间问题<ul><li>1.在不偷第一个房子的情况下<code>(nums[1:])</code>，最大金额是多少</li><li>2.在不偷最后一个房子的情况下<code>(nums[:n-1])</code>，最大金额是多少<br>以上两个情况的最大值，求出最终的最大金额</li></ul></li></ul><h4 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><h5 id="我写的"><a href="#我写的" class="headerlink" title="我写的"></a>我写的</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        nums0, nums1 = nums[:n-<span class="number">1</span>], nums[<span class="number">1</span>:]</span><br><span class="line">        first0,second0 = nums0[<span class="number">0</span>],<span class="built_in">max</span>(nums0[<span class="number">1</span>],nums0[<span class="number">0</span>])</span><br><span class="line">        first1,second1 = nums1[<span class="number">0</span>], <span class="built_in">max</span>(nums1[<span class="number">1</span>],nums1[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n-<span class="number">1</span>):</span><br><span class="line">            first0,second0 = second0, <span class="built_in">max</span>(second0,first0+nums0[i])</span><br><span class="line">            first1,second1 = second1, <span class="built_in">max</span>(second1,first1+nums1[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(second0,second1)</span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n)</script>,其中 <script type="math/tex">n</script>是数组长度。只需要对数组遍历一次。 </li><li>空间复杂度：<script type="math/tex">O(1)</script>。使用滚动数组存储结果。</li></ul></li></ul><h5 id="大佬递归-（看起来更简洁）"><a href="#大佬递归-（看起来更简洁）" class="headerlink" title="大佬递归 （看起来更简洁）"></a>大佬递归 （看起来更简洁）</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">my_rob</span>(<span class="params">nums</span>):</span></span><br><span class="line">            cur, pre = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                cur, pre = <span class="built_in">max</span>(pre + num, cur), cur</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(my_rob(nums[:-<span class="number">1</span>]),my_rob(nums[<span class="number">1</span>:])) <span class="keyword">if</span> <span class="built_in">len</span>(nums) != <span class="number">1</span> <span class="keyword">else</span> nums[<span class="number">0</span>] </span><br></pre></td></tr></tbody></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n)</script>,其中 <script type="math/tex">n</script>是数组长度。只需要对数组遍历一次。 </li><li>空间复杂度：<script type="math/tex">O(1)</script> </li></ul></li></ul><h1 id="740-删除并获得点数-740-删除并获得点数"><a href="#740-删除并获得点数-740-删除并获得点数" class="headerlink" title="740. 删除并获得点数 740. 删除并获得点数"></a>740. 删除并获得点数 <a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组<code>nums</code>，你可以对它进行一些操作。<br>每次操作中，选择任意一个<code>nums[i]</code>，删除它并获得<code>nums[i]</code>的点数。之后，你必须删除每个等于<code>nums[i] - 1</code>或<code>nums[i] + 1</code>的元素。<br>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 </p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul><li>动态方程 <script type="math/tex">dp[i] = max(dp[i-1], dp[i-2] + nums[i])</script></li></ul><h2 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAndEarn</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(<span class="built_in">max</span>(nums) + <span class="number">1</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        dict_nums = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            dict_nums[num] = dict_nums.get(num,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            dp[num] = num*dict_nums[num]</span><br><span class="line">     </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">nums</span>):</span></span><br><span class="line">            len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">            first, second = nums[<span class="number">0</span>], <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, len_nums):</span><br><span class="line">                first, second = second , <span class="built_in">max</span>(first + nums[i], second)</span><br><span class="line">            <span class="keyword">return</span> second</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rob(dp)</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣算法" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode竞赛(第239场周赛)</title>
    <link href="http://watermelondrip.github.io/2021/05/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B239/"/>
    <id>http://watermelondrip.github.io/2021/05/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B239/</id>
    <published>2021-05-01T14:00:00.000Z</published>
    <updated>2021-05-04T17:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p> <a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">5746. Minimum Distance to the Target Element</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数 target 和 start ，请你找出一个下标 i ，满足 nums[i] == target 且 abs(i - start) 最小化 。注意：abs(x) 表示 x 的绝对值。</p><p>返回 abs(i - start) 。</p><p>题目数据保证 target 存在于 nums 中。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5], target = 5, start = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：nums[4] = 5 是唯一一个等于 target 的值，所以答案是 abs(4 - 3) = 1 。 </span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinDistance</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span>, start: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">10000</span>] * len_nums</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == target:</span><br><span class="line">                dp[i] = <span class="built_in">abs</span>(i-start)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp)</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(n)$  </li></ul><h1 id="2-题目"><a href="#2-题目" class="headerlink" title="2. 题目"></a>2. 题目</h1><p> <a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/">1849. 将字符串拆分为递减的连续值</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个仅由数字组成的字符串 s 。</p><p>请你判断能否将 s 拆分成两个或者多个 非空子字符串 ，使子字符串的 数值 按 降序 排列，且每两个 相邻子字符串 的数值之 差 等于 1 。</p><p>例如，字符串 s = “0090089” 可以拆分成 [“0090”, “089”] ，数值为 [90,89] 。这些数值满足按降序排列，且相邻值相差 1 ，这种拆分方法可行。<br>另一个例子中，字符串 s = “001” 可以拆分成 [“0”, “01”]、[“00”, “1”] 或 [“0”, “0”, “1”] 。然而，所有这些拆分方法都不可行，因为对应数值分别是 [0,1]、[0,1] 和 [0,0,1] ，都不满足按降序排列的要求。<br>如果可以按要求拆分 s ，返回 true ；否则，返回 false 。</p><p>子字符串 是字符串中的一个连续字符序列。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "050043"</span><br><span class="line">输出：true</span><br><span class="line">解释：s 可以拆分为 ["05", "004", "3"] ，对应数值为 [5,4,3] 。</span><br><span class="line">满足按降序排列，且相邻值相差 1 。 </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>枚举第一个字符串</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        len_s = <span class="built_in">len</span>(s)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,len_s+<span class="number">1</span>):</span><br><span class="line">            first = <span class="built_in">int</span>(s[:i])</span><br><span class="line">            l = i </span><br><span class="line">            r = i+<span class="number">1</span> </span><br><span class="line">            num = first <span class="comment">#第一个字符串</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> r &lt; len_s+<span class="number">1</span>:</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(s[l:r])== num - <span class="number">1</span>:</span><br><span class="line">                    num = num -<span class="number">1</span></span><br><span class="line">                    l,r = r, r+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> num == <span class="number">0</span> <span class="keyword">and</span> r&lt;len_s+<span class="number">1</span>:</span><br><span class="line">                        num = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">int</span>(s[l:r]) &gt; num - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">int</span>(s[l:r]) &lt; num - <span class="number">1</span>:</span><br><span class="line">                    r+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l == len_s  <span class="keyword">and</span> num!=first:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n^2)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="3-题目"><a href="#3-题目" class="headerlink" title="3. 题目"></a>3. 题目</h1><p> <a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/">1850. 邻位交换的最小次数串</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个表示大整数的字符串 num ，和一个整数 k 。</p><p>如果某个整数是 num 中各位数字的一个 排列 且它的 值大于 num ，则称这个整数为 妙数 。可能存在很多妙数，但是只需要关注 值最小 的那些。</p><p>例如，num = “5489355142” ：<br>第 1 个最小妙数是 “5489355214”<br>第 2 个最小妙数是 “5489355241”<br>第 3 个最小妙数是 “5489355412”<br>第 4 个最小妙数是 “5489355421”<br>返回要得到第 k 个 最小妙数 需要对 num 执行的 相邻位数字交换的最小次数 。</p><p>测试用例是按存在第 k 个最小妙数而生成的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = "5489355142", k = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：第 4 个最小妙数是 "5489355421" ，要想得到这个数字：</span><br><span class="line">- 交换下标 7 和下标 8 对应的位："5489355142" -&gt; "5489355412"</span><br><span class="line">- 交换下标 8 和下标 9 对应的位："5489355412" -&gt; "5489355421" </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ul><li>下一个排列</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestBeautifulSubstring</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        output= <span class="number">0</span></span><br><span class="line">        list_word = <span class="built_in">list</span>(word)</span><br><span class="line">        yuanyin = [<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>]</span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word):</span><br><span class="line">            <span class="keyword">if</span> list_word[i] == <span class="string">'a'</span> <span class="keyword">and</span> step == <span class="number">1</span>:</span><br><span class="line">                res =<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'a'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'e'</span>:</span><br><span class="line">                    step = <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    res =<span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'e'</span> <span class="keyword">and</span> step == <span class="number">2</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'e'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'i'</span>:</span><br><span class="line">                    step = <span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    res =<span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'i'</span> <span class="keyword">and</span> step == <span class="number">3</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'i'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'o'</span>:</span><br><span class="line">                    step = <span class="number">4</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    res =<span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'o'</span> <span class="keyword">and</span> step == <span class="number">4</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'o'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'u'</span>:</span><br><span class="line">                    step = <span class="number">5</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    res =<span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'u'</span> <span class="keyword">and</span> step == <span class="number">5</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'u'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line">                output= <span class="built_in">max</span>(output,res)</span><br><span class="line">                 </span><br><span class="line">             </span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            step = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            output= <span class="built_in">max</span>(output,res)</span><br><span class="line">        <span class="keyword">if</span> output&lt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$ </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣周赛" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>计划</title>
    <link href="http://watermelondrip.github.io/2021/05/01/%E8%AE%A1%E5%88%92/"/>
    <id>http://watermelondrip.github.io/2021/05/01/%E8%AE%A1%E5%88%92/</id>
    <published>2021-04-30T14:00:00.000Z</published>
    <updated>2021-05-06T08:04:36.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><ul><li><p>deadline Review: 2021-06-01</p></li><li><p>写review, 所有responce的仿真0501跑完</p></li><li><p>保1争2（Til 20210701）</p></li></ul><ul><li><p>学学xcode how to use</p></li><li><p>学学Pandas dataframe (GreeksforGreeks)</p></li><li><p>把pdf（C++PRIME）传到blog上，教程好找。 (地址)[<a href="https://github.com/SabrinaHuang/CppPrimeExercise/blob/master/C%2B%2B%20Primer%E7%AC%AC%E4%BA%94%E7%89%88%E4%B8%AD%E6%96%87%E7%89%88.pdf">https://github.com/SabrinaHuang/CppPrimeExercise/blob/master/C%2B%2B%20Primer%E7%AC%AC%E4%BA%94%E7%89%88%E4%B8%AD%E6%96%87%E7%89%88.pdf</a>]</p></li></ul>]]></content>
    
    
    <summary type="html">deadline Review  2021-06-01</summary>
    
    
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://watermelondrip.github.io/2021/04/29/%E9%93%BE%E8%A1%A8/"/>
    <id>http://watermelondrip.github.io/2021/04/29/%E9%93%BE%E8%A1%A8/</id>
    <published>2021-04-28T15:16:00.000Z</published>
    <updated>2021-04-29T01:24:02.930Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>链表<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md#7-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C">刷题顺序</a></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><ul><li>Important notice: 涉及到链表的操作，一定要在纸上把过程先画出来，再写程序！不要断链子。</li><li>小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</li></ul><ul><li>注意<a href="https://zhuanlan.zhihu.com/p/53691100">防止锻链</a>，因为一旦把节点的指针反向了，当前的指针就不再指向下一个节点了，因为也就i不能再继续往后遍历了，也就不能把这个完整的链表进行反转了，这种情况称作断链。为了解决断链的情况，我们就需要再节点指针反向之前，就把当前节点的下一个节点先记下来，等到当前节点的指针完成反转之后，遍历指针直接移动到刚刚被记住的那个节点，这样就能防止锻炼的情况了。具体操作如下：<a href="https://zhuanlan.zhihu.com/p/53691100">讲解1</a></li><li></li><li>注意：我们经常需要定义一个哨兵节点<code>prehead</code>，这可以在最后让我们比较容易地返回合并后的链表。</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol><li>双指针：</li><li>栈：</li></ol><h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><p>剑指 Offer 25. 合并两个排序的链表</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        head = ListNode()</span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val&gt; l2.val:</span><br><span class="line">                tmp.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">                tmp = tmp.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">                tmp = tmp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            tmp.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.<span class="built_in">next</span> = l2</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  其中 nn 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：<script type="math/tex">O(1)</script>。</li></ul></li></ul><p>剑指 Offer 22. 链表中倒数第k个节点</p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        cur_pre = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            cur_pre = cur_pre.<span class="built_in">next</span></span><br><span class="line">            k -=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur_pre:</span><br><span class="line">            cur_pre =cur_pre.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  其中 nn 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：<script type="math/tex">O(n)</script>。</li></ul></li></ul><h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        cur_next = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur_pre = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur.<span class="built_in">next</span> = cur_pre</span><br><span class="line">            cur_pre = cur</span><br><span class="line">            cur = cur_next</span><br><span class="line">            <span class="keyword">if</span> cur_next:</span><br><span class="line">                cur_next = cur_next.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur_pre </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  其中 nn 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：<script type="math/tex">O(1)</script>。</li></ul></li></ul><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></tbody></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; List[int]:</span></span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">return</span> print_list(node.<span class="built_in">next</span>) +[node.val]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> print_list(head)</span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(n)</script>。</li></ul></li></ul><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="1-LC160-相交链表-相交链表"><a href="#1-LC160-相交链表-相交链表" class="headerlink" title="1. (LC160) 相交链表 相交链表"></a>1. (LC160) 相交链表 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">相交链表</a></h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>图解</li></ol><p><img src= "/img/watermelon.gif" data-lazy-src="https://pic.leetcode-cn.com/1614527163-BKaiqs-Picture1.png" alt=""></p><ol><li>数学思维</li></ol><ul><li>我们假设<code>A</code>的头节点到交汇点的距离为<code>a</code>， <code>B</code>的头节点到交汇点的距离为<code>b</code>，交会点最后的距离为<code>c</code>。</li><li><code>A</code>指针<code>cur_A</code>总共走了<code>a+b-c</code>步，<code>B</code>指针<code>cur_B</code>总共走了<code>b+a-c</code>步，所以会两个指针相同，达到终止条件。当没有交点的时候，<code>A</code>指针<code>cur_A</code>总共走了<code>a+b</code>步，<code>B</code>指针<code>cur_B</code>总共走了<code>b+a</code>步，也会两个指针相同指向null，达到终止条件。</li></ul><ol><li>思路总结</li></ol><ul><li>链表来说，首先是先动手走一走，再一个如果碰到交点问题，要看看怎么才能得到一个等式。</li></ul><h3 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span>  <span class="comment">#双指针</span></span><br><span class="line">        cur_A = headA</span><br><span class="line">        cur_B = headB</span><br><span class="line">        <span class="keyword">while</span> cur_A != cur_B:</span><br><span class="line">            cur_A = cur_A.<span class="built_in">next</span> <span class="keyword">if</span> cur_A <span class="keyword">else</span> headB</span><br><span class="line">            cur_B = cur_B.<span class="built_in">next</span> <span class="keyword">if</span> cur_B <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> cur_A</span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n+m)$ n是链表A的长度，m是链表B的长度  </li><li>空间复杂度：$O(1)$  </li></ul><h2 id="2-LC2206-反转链表-反转链表"><a href="#2-LC2206-反转链表-反转链表" class="headerlink" title="2. (LC2206) 反转链表 反转链表"></a>2. (LC2206) 反转链表 <a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>反转一个单链表。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li>双指针：为了防止断链子，要保持下一个节点<code>temp</code>和前一个节点<code>pre</code></li><li>递归：和双指针是一样的逻辑，同样是当<code>cur</code>为空的时候循环结束，不断将<code>cur</code>指向<code>pre</code>的过程。递归的这个好绕啊，第一遍没太理解，先记下来吧。一个很好的解释，慢慢理解，<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">戳这里</a></li><li>栈：最简单的一种方式就是使用栈，因为栈是先进后出的，实现原理是把链表点一个个入栈，当全部入栈之后在一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。</li></ol><h3 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span> <span class="comment">#双指针</span></span><br><span class="line">        cur = head</span><br><span class="line">        pre = <span class="literal">None</span>        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span> <span class="comment">#递归</span></span><br><span class="line"><span class="comment"># 递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span>==<span class="literal">None</span>):</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line"><span class="comment"># 这里的cur就是最后一个节点</span></span><br><span class="line">cur = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line"><span class="comment"># 这里请配合动画演示理解</span></span><br><span class="line"><span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line"><span class="comment"># 而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line"><span class="comment"># 所以head.next.next 就是5-&gt;4</span></span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line"><span class="comment"># 防止链表循环，需要将head.next设置为空</span></span><br><span class="line">head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line"><span class="keyword">return</span> cur </span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        stack = [<span class="literal">None</span>]</span><br><span class="line">        <span class="comment"># 把链表节点全部放到栈中</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            stack.append(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        head = stack.pop()</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 栈中的结点全部出栈，然后重新连成一个新的链表</span></span><br><span class="line">        <span class="keyword">while</span> stack: </span><br><span class="line">            cur.<span class="built_in">next</span> = stack.pop()</span><br><span class="line">            cur =cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 最后一个结点就是反转前的头结点，一定要让他的next</span></span><br><span class="line">        <span class="comment"># 等于空，否则会构成环</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O( )$ n是链表的长度，  </li><li>空间复杂度：$O( )$  </li></ul><h2 id="3-LC21-合并两个有序链表-合并两个有序链表"><a href="#3-LC21-合并两个有序链表-合并两个有序链表" class="headerlink" title="3. (LC21) 合并两个有序链表 合并两个有序链表"></a>3. (LC21) 合并两个有序链表 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ol><li>迭代<ul><li>首先，我们设定一个哨兵节点<code>prehead</code>，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个<code>prev</code>指针，我们需要做的是调整它的<code>next</code>指针。然后我们重复以下过程，直到<code>l1</code>或者<code>l2</code>指向<code>null</code>。在循环终止的时候，<code>l1</code>和<code>l2</code>至多有一个是非空的。</li></ul></li><li>递归</li></ol><h3 id="Python3-Code-6"><a href="#Python3-Code-6" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    dummy = ListNode()</span><br><span class="line">    cur = dummy </span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = l1</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = l2</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n+m)$, 其中n和m个链表长度</li><li>空间复杂度：$O(1)$  </li></ul><h2 id="4-LC83-从有序链表中删除重复节点-从有序链表中删除重复节点"><a href="#4-LC83-从有序链表中删除重复节点-从有序链表中删除重复节点" class="headerlink" title="4. (LC83) 从有序链表中删除重复节点 从有序链表中删除重复节点"></a>4. (LC83) 从有序链表中删除重复节点 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/">从有序链表中删除重复节点</a></h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></tbody></table></figure><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-7"><a href="#Python3-Code-7" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        curnext = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> curnext:</span><br><span class="line">            <span class="keyword">if</span> cur.val == curnext.val:</span><br><span class="line">                curnext = curnext.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = curnext    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = curnext</span><br><span class="line">                curnext = curnext.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n)$ n是链表的长度。因为列表中的每个节点都检查一次以确定它是否重复，所以总运行时间为$O(n)$</li><li>空间复杂度：$O(1)$，没有使用额外的空间</li></ul><h3 id="LC19-删除链表的倒数第-N-个结点-删除链表的倒数第-N-个结点"><a href="#LC19-删除链表的倒数第-N-个结点-删除链表的倒数第-N-个结点" class="headerlink" title="(LC19)删除链表的倒数第 N 个结点   删除链表的倒数第 N 个结点"></a>(LC19)删除链表的倒数第 N 个结点   <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/">删除链表的倒数第 N 个结点</a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>进阶：你能尝试使用一趟扫描实现吗？<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-8"><a href="#Python3-Code-8" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC2-两数相加-2-两数相加"><a href="#LC2-两数相加-2-两数相加" class="headerlink" title="(LC2. 两数相加)     2. 两数相加 "></a>(LC2. 两数相加)    <a href="https://leetcode-cn.com/problems/add-two-numbers/"> 2. 两数相加 </a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></tbody></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-9"><a href="#Python3-Code-9" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC"><a href="#LC" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-10"><a href="#Python3-Code-10" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-1"><a href="#LC-1" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-11"><a href="#Python3-Code-11" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-2"><a href="#LC-2" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-12"><a href="#Python3-Code-12" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-4"><a href="#大佬题解-4" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-3"><a href="#LC-3" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-13"><a href="#Python3-Code-13" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-5"><a href="#大佬题解-5" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-4"><a href="#LC-4" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-14"><a href="#Python3-Code-14" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-6"><a href="#大佬题解-6" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣数据类型" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣数据结构" scheme="http://watermelondrip.github.io/tags/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode竞赛(第238场周赛)</title>
    <link href="http://watermelondrip.github.io/2021/04/25/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B238/"/>
    <id>http://watermelondrip.github.io/2021/04/25/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B238/</id>
    <published>2021-04-24T14:00:00.000Z</published>
    <updated>2021-04-25T14:28:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p> <a href="https://leetcode-cn.com/problems/sum-of-digits-in-base-k/">5738. K 进制表示下的各位数字总和</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。</p><p>转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 34, k = 6</span><br><span class="line">输出：9</span><br><span class="line">解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。</span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumBase</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            res1 = n%k</span><br><span class="line">            res2 = n//k</span><br><span class="line">     </span><br><span class="line">            n = res2</span><br><span class="line">            res += res1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="2-题目"><a href="#2-题目" class="headerlink" title="2. 题目"></a>2. 题目</h1><p> <a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">5739. 最高频元素的频数</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>元素的 频数 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。</p><p>执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,4], k = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。</span><br><span class="line">4 是数组中最高频元素，频数是 3 。 </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>双指针</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxFrequency</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            total += (nums[r] - nums[r - <span class="number">1</span>]) * (r - l)</span><br><span class="line">            <span class="keyword">while</span> total &gt; k:</span><br><span class="line">                total -= nums[r] - nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><p>-时间复杂度：$ O(nlogn)$，排序数组的时间复杂度为 $O(nlogn)$，使用双指针遍历目标值的时间复杂度为$O(n)$。</p><ul><li>空间复杂度：$O(logn)$，即为排序数组需要使用的栈空间。</li></ul><h1 id="3-题目"><a href="#3-题目" class="headerlink" title="3. 题目"></a>3. 题目</h1><p> <a href="https://leetcode-cn.com/problems/longest-substring-of-all-vowels-in-order/">5740. 所有元音按顺序排布的最长子字符串</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>当一个字符串满足如下条件时，我们称它是 美丽的 ：</p><p>所有 5 个英文元音字母（’a’ ，’e’ ，’i’ ，’o’ ，’u’）都必须 至少 出现一次。<br>这些元音字母的顺序都必须按照 字典序 升序排布（也就是说所有的 ‘a’ 都在 ‘e’ 前面，所有的 ‘e’ 都在 ‘i’ 前面，以此类推）<br>比方说，字符串 “aeiou” 和 “aaaaaaeiiiioou” 都是 美丽的 ，但是 “uaeio” ，”aeoiu” 和 “aaaeeeooo” 不是美丽的 。</p><p>给你一个只包含英文元音字母的字符串 word ，请你返回 word 中 最长美丽子字符串的长度 。如果不存在这样的子字符串，请返回 0 。</p><p>子字符串 是字符串中一个连续的字符序列。  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "aeiaaioaaaaeiiiiouuuooaauuaeiu"</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 "aaaaeiiiiouuu" ，长度为 13 。 </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestBeautifulSubstring</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        output= <span class="number">0</span></span><br><span class="line">        list_word = <span class="built_in">list</span>(word)</span><br><span class="line">        yuanyin = [<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>]</span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word):</span><br><span class="line">            <span class="keyword">if</span> list_word[i] == <span class="string">'a'</span> <span class="keyword">and</span> step == <span class="number">1</span>:</span><br><span class="line">                res =<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'a'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'e'</span>:</span><br><span class="line">                    step = <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    res =<span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'e'</span> <span class="keyword">and</span> step == <span class="number">2</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'e'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'i'</span>:</span><br><span class="line">                    step = <span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    res =<span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'i'</span> <span class="keyword">and</span> step == <span class="number">3</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'i'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'o'</span>:</span><br><span class="line">                    step = <span class="number">4</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    res =<span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'o'</span> <span class="keyword">and</span> step == <span class="number">4</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'o'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'u'</span>:</span><br><span class="line">                    step = <span class="number">5</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    res =<span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'u'</span> <span class="keyword">and</span> step == <span class="number">5</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(list_word) <span class="keyword">and</span> list_word[i] == <span class="string">'u'</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    res +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    step = <span class="number">1</span></span><br><span class="line">                    i-=<span class="number">1</span></span><br><span class="line">                output= <span class="built_in">max</span>(output,res)</span><br><span class="line">                 </span><br><span class="line">             </span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            step = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            output= <span class="built_in">max</span>(output,res)</span><br><span class="line">        <span class="keyword">if</span> output&lt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$ </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣周赛" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://watermelondrip.github.io/2021/04/16/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://watermelondrip.github.io/2021/04/16/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2021-04-16T00:22:00.000Z</published>
    <updated>2021-04-16T00:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>栈和队列<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.md#leetcode-%E9%A2%98%E8%A7%A3---%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97">刷题顺序</a></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是一个线性的数据结构，存储数据的方式是Last-In/First-Out(LIFO)先进后出。在栈里，每个新元素从一个end加入，也只能从这个end移除。这个加入和删除的操作经常就叫做<strong>push</strong> 和<strong>pop</strong>。<br>和栈有关的功能是：<br>（1) <code>empty()</code> : 返回stack是否是空 - 时间复杂度<script type="math/tex">O(1)</script><br>（2) <code>size()</code> : 返回stack的长度  - 时间复杂度<script type="math/tex">O(1)</script><br>（3) <code>push()</code> : 加入元素到stack里  - 时间复杂度<script type="math/tex">O(1)</script><br>（4) <code>pop()</code> :  - 时间复杂度<script type="math/tex">O(1)</script></p><p><a href="https://www.geeksforgeeks.org/stack-in-python/">实现方式</a>：list,collections.deque,queue.LifoQueue </p><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h2 id="大佬解释"><a href="#大佬解释" class="headerlink" title="大佬解释"></a>大佬解释</h2><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="LC232-用栈实现队列-用栈实现队列-经典"><a href="#LC232-用栈实现队列-用栈实现队列-经典" class="headerlink" title="(LC232)  用栈实现队列  用栈实现队列 经典"></a>(LC232)  用栈实现队列  <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">用栈实现队列</a> <strong>经典</strong></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实如果def里有self，下面的赋值里就有self.是一致的</p><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1 = [] <span class="comment"># input stack</span></span><br><span class="line">        self.stack2 = [] <span class="comment"># output stack</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[-<span class="number">1</span>] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.stack1 <span class="keyword">and</span> <span class="keyword">not</span> self.stack2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析  <ul><li>时间复杂度：$O( 1)$  </li><li>空间复杂度：$O(N)$  </li></ul></li></ul><h3 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h3><h2 id="LC225-用队列实现栈-用队列实现栈-经典"><a href="#LC225-用队列实现栈-用队列实现栈-经典" class="headerlink" title="(LC225)  用队列实现栈   用队列实现栈  经典"></a>(LC225)  用队列实现栈  <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/description/"> 用队列实现栈</a>  <strong>经典</strong></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.queue1 = []</span><br><span class="line">        self.queue2 = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x onto stack.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.queue2.append(x)</span><br><span class="line">        <span class="keyword">while</span> self.queue1: </span><br><span class="line">            self.queue2.append(self.queue1.pop(<span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">        self.queue1,self.queue2 = self.queue2,self.queue1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the stack is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析  <ul><li>时间复杂度：$O(n)$  </li><li>空间复杂度：$O(n)$  </li></ul></li></ul><h3 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h3><h2 id="LC155-最小栈-最小栈"><a href="#LC155-最小栈-最小栈" class="headerlink" title="(LC155 ) 最小栈   最小栈"></a>(LC155 ) 最小栈   <a href="https://leetcode-cn.com/problems/min-stack/description/">最小栈</a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> self.min_stack:</span><br><span class="line">            self.min_stack.append(<span class="built_in">min</span>(val,self.min_stack[-<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop(-<span class="number">1</span>)</span><br><span class="line">        self.min_stack.pop(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(val)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析  <ul><li>时间复杂度：$O(n)$  </li><li>空间复杂度：$O(n)$  </li></ul></li></ul><h3 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h3><h2 id="LC20-有效的括号-有效的括号"><a href="#LC20-有效的括号-有效的括号" class="headerlink" title="(LC20)   有效的括号  有效的括号 "></a>(LC20)   有效的括号 <a href="https://leetcode-cn.com/problems/valid-parentheses/description/"> 有效的括号 </a></h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "()"</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        s = <span class="built_in">list</span>(s) </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                stack.append(s.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = s.pop(<span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">if</span> tmp == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack[-<span class="number">1</span>] != <span class="string">'('</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    stack.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">elif</span> tmp == <span class="string">']'</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack[-<span class="number">1</span>] != <span class="string">'['</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    stack.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">elif</span> tmp == <span class="string">'}'</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack[-<span class="number">1</span>] != <span class="string">'{'</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    stack.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(tmp)</span><br><span class="line">               </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> stack</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析  <ul><li>时间复杂度：$O(n )$  </li><li>空间复杂度：$O(n)$  </li></ul></li></ul><h3 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h3><h2 id="LC739-每日温度-每日温度"><a href="#LC739-每日温度-每日温度" class="headerlink" title="(LC739 )  每日温度   每日温度 "></a>(LC739 )  每日温度  <a href="https://leetcode-cn.com/problems/daily-temperatures/description/"> 每日温度 </a></h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 </p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ul><li>单调栈</li></ul><h3 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, T: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        mono_stack = []</span><br><span class="line">        result = [<span class="number">0</span>]*<span class="built_in">len</span>(T)</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> i,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(T):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mono_stack:</span><br><span class="line">                tmp = T[i]</span><br><span class="line">                mono_stack.append([i,tmp])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = T[i]</span><br><span class="line">                mono_stack.append([i,tmp])</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> tmp&gt; mono_stack[-<span class="number">2</span>][<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">while</span> <span class="built_in">len</span>(mono_stack)&gt;<span class="number">1</span> <span class="keyword">and</span> tmp&gt; mono_stack[-<span class="number">2</span>][<span class="number">1</span>]:</span><br><span class="line">                        result[mono_stack[-<span class="number">2</span>][<span class="number">0</span>]]=i-mono_stack[-<span class="number">2</span>][<span class="number">0</span>] </span><br><span class="line">                        mono_stack.pop(-<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析  <ul><li>时间复杂度：$O(n+m)$ n是链表A的长度，m是链表B的长度  </li><li>空间复杂度：$O(1)$  </li></ul></li></ul><h3 id="大佬题解-4"><a href="#大佬题解-4" class="headerlink" title="大佬题解"></a>大佬题解</h3><h2 id="LC503-下一个更大元素-II"><a href="#LC503-下一个更大元素-II" class="headerlink" title="(LC503 )  下一个更大元素 II"></a>(LC503 )  下一个更大元素 II</h2><p>  <a href="https://leetcode-cn.com/problems/next-greater-element-ii/description/"> 下一个更大元素 II </a></p><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul><li>单调栈</li></ul><h3 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, T: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        mono_stack = []</span><br><span class="line">        result = [<span class="number">0</span>]*<span class="built_in">len</span>(T)</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> i,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(T):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mono_stack:</span><br><span class="line">                tmp = T[i]</span><br><span class="line">                mono_stack.append([i,tmp])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = T[i]</span><br><span class="line">                mono_stack.append([i,tmp])</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> tmp&gt; mono_stack[-<span class="number">2</span>][<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">while</span> <span class="built_in">len</span>(mono_stack)&gt;<span class="number">1</span> <span class="keyword">and</span> tmp&gt; mono_stack[-<span class="number">2</span>][<span class="number">1</span>]:</span><br><span class="line">                        result[mono_stack[-<span class="number">2</span>][<span class="number">0</span>]]=i-mono_stack[-<span class="number">2</span>][<span class="number">0</span>] </span><br><span class="line">                        mono_stack.pop(-<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析  <ul><li>时间复杂度：$O(n+m)$ n是链表A的长度，m是链表B的长度  </li><li>空间复杂度：$O(1)$  </li></ul></li></ul><h3 id="大佬题解-5"><a href="#大佬题解-5" class="headerlink" title="大佬题解"></a>大佬题解</h3>]]></content>
    
    
    <summary type="html">栈的顺序为后进先出，而队列的顺序为先进先出。</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣数据类型" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>数组与矩阵</title>
    <link href="http://watermelondrip.github.io/2021/04/12/%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/"/>
    <id>http://watermelondrip.github.io/2021/04/12/%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/</id>
    <published>2021-04-11T14:00:00.000Z</published>
    <updated>2021-04-13T02:18:27.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5.md">刷题顺序</a></p><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h2 id="大佬"><a href="#大佬" class="headerlink" title="大佬"></a>大佬</h2><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="LC283-移动零-移动零"><a href="#LC283-移动零-移动零" class="headerlink" title="(LC283) 移动零    移动零 "></a>(LC283) 移动零   <a href="https://leetcode-cn.com/problems/move-zeroes/description/"> 移动零 </a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements.<br>Note that you must do this in-place without making a copy of the array </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></tbody></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC"><a href="#LC" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-1"><a href="#LC-1" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-2"><a href="#LC-2" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-3"><a href="#LC-3" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-4"><a href="#大佬题解-4" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-4"><a href="#LC-4" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-5"><a href="#大佬题解-5" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-5"><a href="#LC-5" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-6"><a href="#Python3-Code-6" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-6"><a href="#大佬题解-6" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-6"><a href="#LC-6" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-7"><a href="#Python3-Code-7" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-7"><a href="#大佬题解-7" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-7"><a href="#LC-7" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-8"><a href="#Python3-Code-8" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-8"><a href="#大佬题解-8" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-8"><a href="#LC-8" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-9"><a href="#Python3-Code-9" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-9"><a href="#大佬题解-9" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-9"><a href="#LC-9" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-10"><a href="#Python3-Code-10" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-10"><a href="#大佬题解-10" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-10"><a href="#LC-10" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-11"><a href="#Python3-Code-11" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-11"><a href="#大佬题解-11" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-11"><a href="#LC-11" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-12"><a href="#Python3-Code-12" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-12"><a href="#大佬题解-12" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-12"><a href="#LC-12" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-13"><a href="#Python3-Code-13" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-13"><a href="#大佬题解-13" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-13"><a href="#LC-13" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-14"><a href="#Python3-Code-14" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-14"><a href="#大佬题解-14" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-14"><a href="#LC-14" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-15"><a href="#Python3-Code-15" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-15"><a href="#大佬题解-15" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-15"><a href="#LC-15" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-16"><a href="#Python3-Code-16" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-16"><a href="#大佬题解-16" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC-16"><a href="#LC-16" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-17"><a href="#Python3-Code-17" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。  </li><li>空间复杂度：<script type="math/tex">O(s)</script>。 </li></ul></li></ul><h4 id="大佬题解-17"><a href="#大佬题解-17" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣数据类型" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://watermelondrip.github.io/2021/04/09/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://watermelondrip.github.io/2021/04/09/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-04-09T02:49:24.978Z</published>
    <updated>2021-04-09T02:49:24.978Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哈希表<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%93%88%E5%B8%8C%E8%A1%A8.md">刷题顺序</a></p><p><a href="https://www.edureka.co/blog/data-structures-in-python/">data structures</a></p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典和列表完全不同，字典里的对象是无序的，他是通过一对对的键和值来反映一种映射关系。字典里，每个键都是唯一的，我们可以通过键来存储对应的值，而不能像列表那样通过位置来索引。</p><p>生成字典的方法：第一种方法：初始为空字典，动态填充新的键和值。重点是第二种方法，用列表动态生成字典。第三种方法，用键值对元组组成的列表构造字典。</p><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><ul><li>哈希映射的用途： 我个人理解是方便搜索定位吧</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h2 id="大佬解释"><a href="#大佬解释" class="headerlink" title="大佬解释"></a>大佬解释</h2><ul><li><a href="https://www.zhihu.com/question/58099937">Python中列表和字典有什么区别，分别适用于什么场景？</a></li></ul><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="LC1-两数之和-两数之和"><a href="#LC1-两数之和-两数之和" class="headerlink" title="(LC1)  两数之和    两数之和"></a>(LC1)  两数之和   <a href="https://leetcode-cn.com/problems/two-sum/description/"> 两数之和</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 </span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li> 注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。<br> 使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 <script type="math/tex">O(N)</script>  降低到 <code>$O(1)$</code> 。<br> 这样我们创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 x 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。 </li><li>可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 $O(NlogN)$，空间复杂度为 $O(1)$。</li><li>用 HashMap 存储数组元素和索引的映射，在访问到 <code>nums[i]</code> 时，判断 HashMap 中是否存在 <code>target - nums[i]</code>，如果存在说明 <code>target - nums[i]</code> 所在的索引和 <code>i</code> 就是要找的两个数。该方法的时间复杂度为 $O(N)$，空间复杂度为 $O(N)$，使用空间来换取时间。</li></ol><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i , num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[num] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O( n)</script>   </li><li>空间复杂度：<script type="math/tex">O( n )</script> </li></ul></li></ul><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="LC217-存在重复元素-存在重复元素"><a href="#LC217-存在重复元素-存在重复元素" class="headerlink" title="(LC217)  存在重复元素  存在重复元素"></a>(LC217)  存在重复元素  <a href="https://leetcode-cn.com/problems/contains-duplicate/">存在重复元素</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><code>set</code>的特点是不重复的数组。 比较数组<code>nums</code>和集合<code>nums</code>长度，如果长度不一致，就返回<code>true</code>，否则返回<code>False</code></li><li>字典， 遍历<code>nums</code>，将其加入字典中，加入之前判断一下是否存在，如果存在就return False,否则true</li></ol><h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span> <span class="comment"># 思路1：set思路</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) != <span class="built_in">len</span>(<span class="built_in">set</span>(nums)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span> <span class="comment"># 思路2：dic思路</span></span><br><span class="line">        pairs = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            pairs[num] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>复杂度分析 （思路1,思路2）<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O( n)</script>   </li><li>空间复杂度：<script type="math/tex">O( n )</script> </li></ul></li></ul><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC594-最长和谐序列-最长和谐序列"><a href="#LC594-最长和谐序列-最长和谐序列" class="headerlink" title="(LC594)  最长和谐序列  最长和谐序列"></a>(LC594)  最长和谐序列  <a href="">最长和谐序列</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。</p><p>现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p><p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,2,2,5,2,3,7]</span><br><span class="line">输出：5</span><br><span class="line">解释：最长的和谐子序列是 [3,2,2,2,3]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>枚举：我们可以枚举数组中的每一个元素，对于当前枚举的元素<code>x</code>，它可以和<code>x+1</code>组成和谐子序列。我们遍历一遍整个数组，找出等于<code>x</code>或<code>x+1</code>的元素的个数，就可以得到以<code>x</code>为最小值的和谐子序列的长度。（一开始我同时找了<code>x-1</code>和<code>x+1</code>，其实就找<code>x+1</code>就行，再找<code>x-1</code>就重复了，比如<code>1</code>找<code>2</code>，<code>2</code>又找<code>1</code>。不是一样的吗！）</li><li>字典：枚举超时的，怎么办？我们枚举完<code>x</code>后，其实可以通过HashMap来直接找到<code>x</code>和<code>x+1</code>出现的次数。这样就能在$O(1)$的时间内得到<code>x</code>和<code>x+1</code>的次数。我们首先还是遍历一遍数组，得到HashMap。随后遍历哈希映射，设当前遍历到的key-value对为<code>(x,value)</code>，那么我们就查询<code>x+1</code>在HashMap 中对应的值，就得到了<code>x</code>和<code>x+1</code>出现的次数。</li></ul><h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLHS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dic_nums = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            dic_nums[num] = dic_nums.get(num,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> dic_nums.items():</span><br><span class="line">            <span class="keyword">if</span> dic_nums.get(key+<span class="number">1</span>,<span class="number">0</span>) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = dic_nums.get(key+<span class="number">1</span>,<span class="number">0</span>)+ value</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n)</script>   </li><li>空间复杂度：<script type="math/tex">O(n)</script> </li></ul></li></ul><h4 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC128-最长连续序列-最长连续序列"><a href="#LC128-最长连续序列-最长连续序列" class="headerlink" title="(LC128)  最长连续序列   最长连续序列"></a>(LC128)  最长连续序列  <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/"> 最长连续序列</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>暴力改良版：首先我们会想到最直接暴力的破解。我们可以用一个<code>set</code>把给的数组，去重的保存起来。然后再考虑数组的每个数，比如这个数是<code>n</code>，然后看到<code>n+1</code>在不在<code>set</code>中，然后再看<code>n+2</code>。这样时间复杂度就是$n^2$。 如果我们只考虑从序列最小的数开始的话，我们就直接跳过了很多数，复杂度就降低了。</li><li></li></ol><h4 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>  <span class="comment">#思路1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums_set = <span class="built_in">set</span>(nums)</span><br><span class="line">        longest_seq = <span class="number">1</span></span><br><span class="line">        current_seq = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums_set:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">in</span> nums_set:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> num + <span class="number">1</span> <span class="keyword">in</span> nums_set:</span><br><span class="line">                <span class="keyword">while</span> num + <span class="number">1</span> <span class="keyword">in</span> nums_set:</span><br><span class="line">                    current_seq += <span class="number">1</span></span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">                longest_seq = <span class="built_in">max</span>(longest_seq, current_seq)</span><br><span class="line">                current_seq = <span class="number">1</span></span><br><span class="line">                print(longest_seq)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> longest_seq</span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>虽然 for 循环里套了 while 循环，但每个元素其实最多也就是被访问两次。比如极端情况 987654 ，98765 循环的时候都不会进入 while 循环，只有到 4 的时候才进入了 while 循环。所以总共的话， 98765 也只会被访问两次，所以时间复杂度就是 O(2n) 了。<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n)</script>   </li><li>空间复杂度：<script type="math/tex">O(n)</script> </li></ul></li></ul><h4 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC"><a href="#LC" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-4"><a href="#大佬题解-4" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-1"><a href="#LC-1" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-5"><a href="#大佬题解-5" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣数据类型" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://watermelondrip.github.io/2021/04/09/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://watermelondrip.github.io/2021/04/09/%E7%8A%B6%E6%80%81%E6%9C%BA/</id>
    <published>2021-04-09T02:49:24.978Z</published>
    <updated>2021-04-30T02:47:40.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.html#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">设计模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="实际开发" scheme="http://watermelondrip.github.io/categories/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="面向对象" scheme="http://watermelondrip.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://watermelondrip.github.io/2021/04/09/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://watermelondrip.github.io/2021/04/09/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-04-08T14:00:00.000Z</published>
    <updated>2021-04-12T06:40:53.869Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2.md#leetcode-%E9%A2%98%E8%A7%A3---%E5%AD%97%E7%AC%A6%E4%B8%B2">刷题顺序</a></p><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><ol><li>其实数组可以看成就是一张哈希表。 哈希表中关键码就是数组的索引下标。然后通过下表直接访问数组中的元素。如图<br><img src= "/img/watermelon.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/F1VzfUpxxe4nxvWzKLIMPMARI6WiaMdagKMTKu830oD0eOzK0xBVBSsyX9b0XM2QNrDV3Q8cubZL39weD3933YA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Build Status">]<br>那么哈希表能解决什么问题呢，「一般哈希表都是用来快速判断一个元素是否出现集合里。」。<br>所以可以通过哈希来快速判断一个元素是否出现在数组里或者集合里。</li></ol><h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><ul><li>数组 + 哈希</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h2 id="大佬"><a href="#大佬" class="headerlink" title="大佬"></a>大佬</h2><ul><li><a href="https://mp.weixin.qq.com/s/g8N6WmoQmsCUw3_BaWxHZA">哈希表</a></li></ul><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="LC242-有效的字母异位词-有效的字母异位词"><a href="#LC242-有效的字母异位词-有效的字母异位词" class="headerlink" title="(LC242)有效的字母异位词 有效的字母异位词"></a>(LC242)有效的字母异位词 <a href="https://leetcode-cn.com/problems/valid-anagram/description/">有效的字母异位词</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "anagram", t = "nagaram"</span><br><span class="line">输出: true</span><br></pre></td></tr></tbody></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p><code>t</code> 是 <code>s</code> 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 <code>s</code> 和 <code>t</code> 分别排序，看排序后的字符串是否相等即可判断。此外，如果 <code>s</code> 和 <code>t</code> 的长度不同，<code>t</code> 必然不是 <code>s</code> 的异位词。 </p></li><li><p>思路1：由于字符串只包含26个小写字母，因此我们可以维护一个长度为26的频次数组<code>table</code>。先遍历记录字符串<code>s</code>中字符出现的频次，然后遍历字符串<code>t</code>，减去<code>table</code>中对应的频次，如果出现<code>table[i]&lt;0</code>， 则说明<code>t</code>包含一个不在<code>s</code>中的额外字符，返回<code>false</code>。</p></li><li><p>思路2：可以用Collections 模块中的Counter</p></li></ul><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span> <span class="comment">#思路1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        table = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            table[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">'a'</span>)] +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> t:</span><br><span class="line">            table[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">'a'</span>)] -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> table[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">'a'</span>)] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n)</script>   </li><li>空间复杂度：<script type="math/tex">O(n)</script> </li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment"># 思路2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s_count = Counter(s)</span><br><span class="line">        t_count = Counter(t)</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> s_count.items():</span><br><span class="line">            t_value = t_count[key]</span><br><span class="line">            <span class="keyword">if</span> t_value != value:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析<br>令 n 为数组长度。<ul><li>时间复杂度：<script type="math/tex">O(n)</script>   </li><li>空间复杂度：<script type="math/tex">O(n)</script> </li></ul></li></ul><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC409-最长回文串-最长回文串"><a href="#LC409-最长回文串-最长回文串" class="headerlink" title="(LC409) 最长回文串   最长回文串"></a>(LC409) 最长回文串   <a href="https://leetcode-cn.com/problems/longest-palindrome/">最长回文串</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母<strong>构造</strong>最长的回文串。</p><p>在<strong>构造过程中</strong>，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。<br>注意:<br>假设字符串的长度不会超过 1010。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:"abccccdd"</span><br><span class="line">输出:7</span><br><span class="line">解释:我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。 </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>每个字符有偶数个可以用来构成回文字符串。因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间。</li></ul><h4 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#简洁版大佬</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        count = collections.Counter(s)</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> count.values():</span><br><span class="line">            ans += v // <span class="number">2</span> * <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> ans % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> v % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(n)</script>。其中 <code>n</code>为字符串 <code>s</code> 的长度。我们需要遍历每个字符一次。   </li><li>空间复杂度：<script type="math/tex">O(s)</script>。最多52个（大小写数量之和）</li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#本菜</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        s_count = Counter(s)</span><br><span class="line">        ans_odd = <span class="number">0</span></span><br><span class="line">        ans_even = <span class="number">0</span></span><br><span class="line">        mark_odd = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> s_count.items():</span><br><span class="line">            <span class="keyword">if</span> value% <span class="number">2</span>:</span><br><span class="line">                ans_odd = <span class="built_in">max</span>(ans_odd,value)</span><br><span class="line">                <span class="keyword">if</span> ans_odd == value <span class="keyword">and</span> value == <span class="number">1</span>:</span><br><span class="line">                    mark_odd = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    mark_odd = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> value &gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> value%<span class="number">2</span>:</span><br><span class="line">                    ans_even +=value -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans_even += value</span><br><span class="line">        <span class="keyword">if</span> ans_odd == <span class="number">0</span>:</span><br><span class="line">            mark_odd = <span class="number">0</span> </span><br><span class="line">        ans = ans_even+ ans_odd + mark_odd*(ans_odd-<span class="number">1</span>)</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><h3 id="LC205-同构字符串-同构字符串"><a href="#LC205-同构字符串-同构字符串" class="headerlink" title="(LC205)   同构字符串 同构字符串"></a>(LC205)   同构字符串 <a href="https://leetcode-cn.com/problems/isomorphic-strings/description/">同构字符串</a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果<code>s</code>中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "egg", t = "add"</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li><p>暴力超时</p></li><li><p>暴力法主要浪费在判断回文串上，不能有效利用同中心的会文串的状态。简单来说就是此时我们假设前面的子串<code>s[j,i]</code>是回文串，那么，子串<code>s[j-1,i+1]</code>也有可能是回文串，不难想出当且仅当子串<code>s[j,i]</code>是回文串且<code>s[j-1]=s[i+1]</code>时，子串<code>s[j-1,i+1]</code>也是回文串，于是我们可以通过数组保存子串是否是回文串，然后通过递推上一次的状态，得到下一次的状态，属于动态规划的解法，令<code>dp[j][i]</code>表示子串<code>s[j,i]</code>是否是回文串，状态转移如下：</p><ul><li>当<code>i=j</code>时，单个字符肯定是回文串，可以看成奇数回文串的起点<ul><li>当<code>s[i]=s[j]</code>且<code>i-j=1</code>，则<code>dp[j][i]</code>是回文串，可以看成偶数回文串的起点</li></ul></li><li>当<code>s[i]=s[j]</code>且<code>dp[j+1][i-1]</code>是回文串，则<code>dp[j][i]</code>也是回文串<ul><li>其他情形都不是回文串</li></ul></li></ul></li></ul><h4 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment"># 动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [ [<span class="number">0</span>] * (<span class="built_in">len</span>(s)+<span class="number">1</span>)  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>) ]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>): </span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (i - j &lt;<span class="number">2</span> <span class="keyword">or</span>  dp[j+<span class="number">1</span>][i-<span class="number">1</span>]  ):</span><br><span class="line">                    dp[j][i] = <span class="number">1</span></span><br><span class="line">                    result +=<span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span> <span class="comment">#超时版本</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ispalindrome</span> (<span class="params">word</span>):</span></span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = <span class="built_in">len</span>(word) -<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> word[left] != word[right]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                left +=<span class="number">1</span></span><br><span class="line">                right -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> ispalindrome(s[i:j]):</span><br><span class="line">                    result +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><h3 id="LC9-回文数-回文数"><a href="#LC9-回文数-回文数" class="headerlink" title="(LC9)  回文数 回文数"></a>(LC9)  回文数 <a href="https://leetcode-cn.com/problems/palindrome-number/description/">回文数</a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>低级版本：str(x)判断</li><li>进阶： 不用str()。将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。</li><li>反转一半数字：数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。</li></ul><h4 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rever_x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x&gt; rever_x:</span><br><span class="line">            rever_x = x % <span class="number">10</span> + rever_x * <span class="number">10</span></span><br><span class="line">            x = x//<span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> (x == rever_x <span class="keyword">or</span> x == rever_x//<span class="number">10</span>  )</span><br></pre></td></tr></tbody></table></figure><ul><li>复杂度分析   <ul><li>时间复杂度：<script type="math/tex">O(log(n))</script>。 每次迭代，我们除以10。   </li><li>空间复杂度：<script type="math/tex">O(1)</script>。 </li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#低版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        str_x =  <span class="built_in">str</span>(x)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(str_x)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            <span class="keyword">if</span> str_x[left] != str_x[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC696-计数二进制子串"><a href="#LC696-计数二进制子串" class="headerlink" title="(LC696)   计数二进制子串"></a>(LC696)   计数二进制子串</h3><p> <a href="https://leetcode-cn.com/problems/count-binary-substrings/"> 计数二进制子串 </a></p><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。</p><p>重复出现的子串要计算它们出现的次数。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: "00110011"</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC"><a href="#LC" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣数据类型" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>2021春季力扣杯（个人）</title>
    <link href="http://watermelondrip.github.io/2021/04/05/2021%E6%98%A5%E5%AD%A3%E5%8A%9B%E6%89%A3%E6%9D%AF%E4%B8%AA%E4%BA%BA/"/>
    <id>http://watermelondrip.github.io/2021/04/05/2021%E6%98%A5%E5%AD%A3%E5%8A%9B%E6%89%A3%E6%9D%AF%E4%B8%AA%E4%BA%BA/</id>
    <published>2021-04-04T14:00:00.000Z</published>
    <updated>2021-04-06T07:25:38.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="joy-题目"><a href="#joy-题目" class="headerlink" title=":joy: 题目"></a><span class="github-emoji"><span>😂</span><img src= "/img/watermelon.gif" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 题目</h1><p> <a href="https://leetcode-cn.com/problems/4xy4Wx/">采购方案</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。<br>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1 。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,5,3,5], target = 6</span><br><span class="line">输出：1</span><br><span class="line">解释：预算内仅能购买 nums[0] 与 nums[2]。 </span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>2 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i], target &lt;= 10^5</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>双指针</li><li>二分查找</li></ul><h2 id="反省"><a href="#反省" class="headerlink" title="反省"></a>反省</h2><ol><li>迭代超时的时候可以想想排序+双指针</li></ol><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#本菜</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">purchasePlans</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums.sort() </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        result = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]&gt;= target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[k] &lt; target:</span><br><span class="line">                m= k</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res = target - nums[i] </span><br><span class="line">            <span class="keyword">if</span> res &lt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> result % (<span class="number">1000000007</span>)</span><br><span class="line">            position = bisect.bisect(nums,res)</span><br><span class="line">            <span class="keyword">if</span> position - i &lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> result % (<span class="number">1000000007</span>)</span><br><span class="line">            result += position-i-<span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> result % (<span class="number">1000000007</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong><br>令 n 为数组长度。</p><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(1)$</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment"># 大佬双指针</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">purchasePlans</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> pos &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[pos] + nums[i] &lt;= target:</span><br><span class="line">                pos += <span class="number">1</span></span><br><span class="line">            ans = (ans + <span class="built_in">min</span>(pos, i)) % <span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong><br>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h1 id="joy-题目-1"><a href="#joy-题目-1" class="headerlink" title=":joy: 题目"></a><span class="github-emoji"><span>😂</span><img src= "/img/watermelon.gif" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 题目</h1><p> <a href="https://leetcode-cn.com/problems/SNJvJP/">乐团站位</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。</p><p>为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，…，9 循环重复排列。例如当 num = 5 时，站位如图所示</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 3, Xpos = 0, Ypos = 2</span><br><span class="line"></span><br><span class="line">输出：3 </span><br></pre></td></tr></tbody></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>先看在第几圈， 再看在哪条边</li></ul><h2 id="反省-1"><a href="#反省-1" class="headerlink" title="反省"></a>反省</h2><ul><li>再看看吧</li></ul><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment"># 大佬 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orchestraLayout</span>(<span class="params">self, num: <span class="built_in">int</span>, xPos: <span class="built_in">int</span>, yPos: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> xPos == num // <span class="number">2</span> <span class="keyword">and</span> yPos == num // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> (num * num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span></span><br><span class="line">        up = xPos</span><br><span class="line">        down = num - xPos - <span class="number">1</span></span><br><span class="line">        left = yPos</span><br><span class="line">        right = num - yPos - <span class="number">1</span></span><br><span class="line">        least = <span class="built_in">min</span>(up, down, left, right)</span><br><span class="line">        ans = num * num - (num - <span class="number">2</span> * least) * (num - <span class="number">2</span> * least)</span><br><span class="line">        <span class="keyword">if</span> up == least:</span><br><span class="line">            ans += yPos - least + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> right == least:</span><br><span class="line">            ans += num - <span class="number">3</span> * least + xPos</span><br><span class="line">        <span class="keyword">elif</span> down == least:</span><br><span class="line">            ans += (num - <span class="number">2</span> * least - <span class="number">1</span>) * <span class="number">2</span> + right - least + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans += (num - <span class="number">2</span> * least - <span class="number">1</span>) * <span class="number">3</span> + down - least + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (ans - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O( )$</li><li>空间复杂度：$O( )$</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment"># 超时的本菜</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orchestraLayout</span>(<span class="params">self, num: <span class="built_in">int</span>, xPos: <span class="built_in">int</span>, yPos: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        dp = [[ <span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num)]</span><br><span class="line">        </span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dp[i][j] == <span class="number">0</span>:</span><br><span class="line">           <span class="comment"># print(dp)</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= num-<span class="number">1</span> <span class="keyword">and</span> dp[i][j]==<span class="number">0</span>: <span class="comment">#right</span></span><br><span class="line">                dp[i][j] = count</span><br><span class="line">                <span class="keyword">if</span> i == xPos <span class="keyword">and</span> j == yPos:</span><br><span class="line">                    <span class="keyword">return</span> count</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == <span class="number">10</span>:</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span> </span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> i &lt;= num -<span class="number">1</span> <span class="keyword">and</span> dp[i][j] == <span class="number">0</span>: </span><br><span class="line">                dp[i][j] = count </span><br><span class="line">                <span class="keyword">if</span> i == xPos <span class="keyword">and</span> j == yPos:</span><br><span class="line">                    <span class="keyword">return</span> count</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == <span class="number">10</span>:</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> dp[i][j]==<span class="number">0</span>:</span><br><span class="line">                dp[i][j] = count </span><br><span class="line">                <span class="keyword">if</span> i == xPos <span class="keyword">and</span> j == yPos:</span><br><span class="line">                    <span class="keyword">return</span> count</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == <span class="number">10</span>:</span><br><span class="line">                    count = <span class="number">1</span> </span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> i &gt;=<span class="number">0</span> <span class="keyword">and</span> dp[i][j]==<span class="number">0</span>:</span><br><span class="line">                dp[i][j] = count </span><br><span class="line">                <span class="keyword">if</span> i == xPos <span class="keyword">and</span> j == yPos:</span><br><span class="line">                    <span class="keyword">return</span> count</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == <span class="number">10</span>:</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span> </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O( n^2)$</li><li>空间复杂度：$O(n^2)$<h1 id="joy-题目-2"><a href="#joy-题目-2" class="headerlink" title=":joy: 题目"></a><span class="github-emoji"><span>😂</span><img src= "/img/watermelon.gif" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 题目</h1></li></ul><h1 id="joy-题目-3"><a href="#joy-题目-3" class="headerlink" title=":joy: 题目"></a><span class="github-emoji"><span>😂</span><img src= "/img/watermelon.gif" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 题目</h1><p> <a href="">魔塔游戏</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。每个房间的补血道具/怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。</p><p>小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,100,100,-250,-60,-140,-50,-50,100,150]</span><br><span class="line"></span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">解释：初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求 </span><br></pre></td></tr></tbody></table></figure><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^5 &lt;= nums[i] &lt;= 10^5</li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><h2 id="反省-2"><a href="#反省-2" class="headerlink" title="反省"></a>反省</h2><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><ol><li><a href="https://stackoverflow.com/questions/57106445/heapify-function-does-not-give-sorted-list">heapify function does not give sorted list</a></li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">magicTower</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> total &lt; <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        l = SortedList()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        hp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> nums :</span><br><span class="line">            hp += val</span><br><span class="line">            <span class="keyword">if</span> val &lt; <span class="number">0</span> :</span><br><span class="line">                l.add(val)</span><br><span class="line">            <span class="keyword">while</span> hp &lt;= <span class="number">0</span> :</span><br><span class="line">                d = l.pop(<span class="number">0</span>)</span><br><span class="line">                hp -= d</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O( )$</li><li>空间复杂度：$O( )$</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span><span class="comment">#本菜</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">magicTower</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(nums) &lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        minheap = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>]</span><br><span class="line">            heapq.heappush(minheap,nums[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> dp[i] &lt; <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i] - heapq.heappop(minheap)</span><br><span class="line">                <span class="keyword">if</span> i &lt; n-<span class="number">1</span>:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></tbody></table></figure><h1 id="joy-题目-4"><a href="#joy-题目-4" class="headerlink" title=":joy: 题目"></a><span class="github-emoji"><span>😂</span><img src= "/img/watermelon.gif" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 题目</h1><p> <a href=""> </a></p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><h2 id="反省-3"><a href="#反省-3" class="headerlink" title="反省"></a>反省</h2><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O( )$</li><li>空间复杂度：$O( )$</li></ul><h1 id="joy-题目-5"><a href="#joy-题目-5" class="headerlink" title=":joy: 题目"></a><span class="github-emoji"><span>😂</span><img src= "/img/watermelon.gif" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 题目</h1><p> <a href=""> </a></p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><h2 id="反省-4"><a href="#反省-4" class="headerlink" title="反省"></a>反省</h2><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O( )$</li><li>空间复杂度：$O( )$</li></ul><h1 id="joy-题目-6"><a href="#joy-题目-6" class="headerlink" title=":joy: 题目"></a><span class="github-emoji"><span>😂</span><img src= "/img/watermelon.gif" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 题目</h1><p> <a href=""> </a></p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><h2 id="反省-5"><a href="#反省-5" class="headerlink" title="反省"></a>反省</h2><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O( )$</li><li>空间复杂度：$O( )$</li></ul>]]></content>
    
    
    <summary type="html">一顿超时</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣周赛" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="竞赛" scheme="http://watermelondrip.github.io/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode竞赛(第235场周赛)</title>
    <link href="http://watermelondrip.github.io/2021/04/04/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B235/"/>
    <id>http://watermelondrip.github.io/2021/04/04/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B235/</id>
    <published>2021-04-03T14:00:00.000Z</published>
    <updated>2021-04-04T08:56:37.974Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>排名： 哼，时间忘了 ，我才不说呢</p><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>(5722)[ <a href="https://leetcode-cn.com/problems/truncate-sentence/">https://leetcode-cn.com/problems/truncate-sentence/</a> ]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p><p>例如，”Hello World”、”HELLO” 和 “hello world hello world” 都是句子。<br>给你一个句子 s  和一个整数 k ，请你将 s 截断 ， 使截断后的句子仅含 前 k 个单词。返回 截断 s 后得到的句子。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "Hello how are you Contestant", k = 4</span><br><span class="line">输出："Hello how are you"</span><br><span class="line">解释：</span><br><span class="line">s 中的单词为 ["Hello", "how" "are", "you", "Contestant"]</span><br><span class="line">前 4 个单词为 ["Hello", "how", "are", "you"]</span><br><span class="line">因此，应当返回 "Hello how are you"</span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">truncateSentence</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        firststep = s.split( )</span><br><span class="line">        secondstep = firststep[:k]</span><br><span class="line">        result = <span class="string">' '</span>.join(secondstep)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="2-题目"><a href="#2-题目" class="headerlink" title="2. 题目"></a>2. 题目</h1><p>(5723. 查找用户活跃分钟数)[<a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes/">https://leetcode-cn.com/problems/finding-the-users-active-minutes/</a>]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDi, timei] 表示 ID 为 $ID_i$ 的用户在 $time_i$ 分钟时执行了某个操作。</p><p>多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。</p><p>指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p><p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（1 &lt;= j &lt;= k），answer[j] 表示 用户活跃分钟数 等于 j 的用户数。</p><p>返回上面描述的答案数组 answer 。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5</span><br><span class="line">输出：[0,2,0,0,0]</span><br><span class="line">解释：</span><br><span class="line">ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）</span><br><span class="line">ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2</span><br><span class="line">2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0 </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>字典 <a href="https://www.pythonforbeginners.com/dictionary/how-to-use-dictionaries-in-python">Python for beginners</a>  </li><li>collection module <a href="https://www.geeksforgeeks.org/python-collections-module/">Python Collections Module</a></li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findingUsersActiveMinutes</span>(<span class="params">self, logs: List[List[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        ans = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        <span class="keyword">for</span> i, t <span class="keyword">in</span> logs:</span><br><span class="line">            ans[i].add(t) </span><br><span class="line">        res = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> ans:</span><br><span class="line">            res[<span class="built_in">len</span>(ans[u]) - <span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="3-题目"><a href="#3-题目" class="headerlink" title="3. 题目"></a>3. 题目</h1><p>(5724. 绝对差值和)[ <a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">https://leetcode-cn.com/problems/minimum-absolute-sum-difference/</a> ]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。</p><p>数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 &lt;= i &lt; n）的 总和（下标从 0 开始）。</p><p>你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。</p><p>在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。</p><p>|x| 定义为：</p><p>如果 x &gt;= 0 ，值为 x ，或者<br>如果 x &lt;= 0 ，值为 -x </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,7,5], nums2 = [2,3,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：有两种可能的最优方案：</span><br><span class="line">- 将第二个元素替换为第一个元素：[1,7,5] =&gt; [1,1,5] ，或者</span><br><span class="line">- 将第二个元素替换为第三个元素：[1,7,5] =&gt; [1,5,5]</span><br><span class="line">两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3 </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ul><li></li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAbsoluteSumDiff</span>(<span class="params">self, nums1, nums2</span>):</span>  <span class="comment"># Max's solution</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> nums1 == nums2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            diff = [a - b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(nums1, nums2)]</span><br><span class="line">            diff = [<span class="built_in">abs</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> diff]</span><br><span class="line">            max_abs_value = <span class="built_in">max</span>(diff)</span><br><span class="line">            max_abs_value_idx = diff.index(max_abs_value) <span class="comment"># the nums1[max_abs_value_idx] needs to be replaced </span></span><br><span class="line">            </span><br><span class="line">            temp = [x - nums2[max_abs_value_idx] <span class="keyword">for</span> x <span class="keyword">in</span> nums1]</span><br><span class="line">            diff_single = [<span class="built_in">abs</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> temp]</span><br><span class="line">            min_abs_value = <span class="built_in">min</span>(diff_single)</span><br><span class="line">            </span><br><span class="line">            min_abs_value_idx = diff_single.index(min_abs_value) <span class="comment"># the nums1[min_abs_value_idx] is used to do the replace</span></span><br><span class="line"></span><br><span class="line">            nums1[max_abs_value_idx] = nums1[min_abs_value_idx]</span><br><span class="line"></span><br><span class="line">            diff_two_nums = [a - b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(nums1, nums2)]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>([<span class="built_in">abs</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> diff_two_nums]) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAbsoluteSumDiff</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; int:</span> <span class="comment"># me's solution</span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sumoperation</span>(<span class="params"> n1, n2</span>):</span></span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n1)):</span><br><span class="line">                result += <span class="built_in">abs</span>(n1[i] - n2[i])</span><br><span class="line">            <span class="keyword">return</span> result </span><br><span class="line">        <span class="keyword">if</span> nums1 == nums2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums1)</span><br><span class="line">        helper = []</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            helper.append(<span class="built_in">abs</span>(nums1[i]-nums2[i]))</span><br><span class="line">        </span><br><span class="line">        a = <span class="built_in">max</span>(helper)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> helper[i] == a:</span><br><span class="line">                ind = i</span><br><span class="line">   </span><br><span class="line">        mindif = inf</span><br><span class="line">        index1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> mindif &gt; <span class="built_in">abs</span>(nums1[j]-nums2[ind]):</span><br><span class="line">                mindif = <span class="built_in">min</span>(mindif,<span class="built_in">abs</span>(nums1[j]-nums2[ind]))</span><br><span class="line">                index1 = j</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> (sumoperation(nums1[:ind], nums2[:ind])+mindif+ sumoperation(nums1[ind+<span class="number">1</span>:],nums2[ind+<span class="number">1</span>:]) )%(<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="4-题目"><a href="#4-题目" class="headerlink" title="4. 题目"></a>4. 题目</h1><p>(5725. 序列中不同最大公约数的数目)[ <a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/">https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/</a>]</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个由正整数组成的数组 nums 。</p><p>数字序列的 最大公约数定义为序列中所有整数的共有约数中的最大整数。</p><p>例如，序列 [4,6,16] 的最大公约数是 2 。数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删）得到。</p><p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：primeFactors = 5</span><br><span class="line">输出：6</span><br><span class="line">解释：200 是一个可行的 n 。</span><br><span class="line">它有 5 个质因子：[2,2,2,5,5] ，且有 6 个好因子：[10,20,40,50,100,200] 。</span><br><span class="line">不存在别的 n 有至多 5 个质因子，且同时有更多的好因子。 </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><ul><li>不明白！咋的</li></ul><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDifferentSubsequenceGCDs</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line">        tag = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            tag[n] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(tag)):</span><br><span class="line">            cur_gcd = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(tag), i):</span><br><span class="line">                <span class="keyword">if</span> tag[j]:</span><br><span class="line">                    cur_gcd = gcd(cur_gcd, j) <span class="keyword">if</span> cur_gcd != -<span class="number">1</span> <span class="keyword">else</span> j</span><br><span class="line">                    <span class="keyword">if</span> cur_gcd == i:</span><br><span class="line">                        ans += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDifferentSubsequenceGCDs</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        f = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200010</span>)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> f[num] == <span class="number">0</span>:</span><br><span class="line">                f[num] += <span class="number">1</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        maxn = <span class="built_in">max</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxn + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> f[i]: <span class="keyword">continue</span></span><br><span class="line">            r = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, maxn + <span class="number">1</span>, i):</span><br><span class="line">                <span class="keyword">if</span> f[j]:</span><br><span class="line">                    r = self.gcd(r, j)</span><br><span class="line">                    <span class="keyword">if</span> r == i:</span><br><span class="line">                        ans += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">self, x, y</span>):</span>  <span class="comment">#最大公约数</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>: <span class="keyword">return</span> y</span><br><span class="line">        <span class="keyword">if</span> y == <span class="number">0</span>: <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">return</span> gcd(y, x % y) </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O( )$  </li><li>空间复杂度：$O( )$  </li></ul>]]></content>
    
    
    <summary type="html">哼，时间忘了 ，我才不说呢</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣周赛" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>小知识点们儿（全局局部区别，self参数）</title>
    <link href="http://watermelondrip.github.io/2021/03/29/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%AC%E5%84%BF/"/>
    <id>http://watermelondrip.github.io/2021/03/29/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%AC%E5%84%BF/</id>
    <published>2021-03-28T13:42:00.000Z</published>
    <updated>2021-03-28T13:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h1 id="Python-全局变量-局部变量区"><a href="#Python-全局变量-局部变量区" class="headerlink" title="Python 全局变量-局部变量区"></a>Python 全局变量-局部变量区</h1><p>整理一下<a href="https://www.cnblogs.com/insane-Mr-Li/p/9813226.html">这个</a><br>对于很多初学者来说，对于全局和局部变量容易混淆，我们来尝试解释一下：</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>全局变量：在模块内、在所有函数的外面、在class 外面<br>局部变量：在函数内，在class的方法内</strong></p><ol><li>在子程序中定义的变量成为局部变量，在程序的一开始定义的变量成为全局变量。全局变量作用域是整个程序，局部变量作用域是定义该变量的子程序。</li><li>全局变量没有任何缩进，在任何位置都可以调用</li><li>子程序：如用def定义的函数。</li><li>作用域 ：全局作用域（global)在整个程序运行中都可见。局部作用域：在函数内部、类等内部可见；局部变量使用范围不能超过其所在的局部作用域。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Name =<span class="string">"nicholas"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span>():</span></span><br><span class="line">    print(<span class="string">"change_name"</span>,Name)</span><br><span class="line">change_name()</span><br><span class="line">print(Name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>change_name nicholas</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nicholas</span><br></pre></td></tr></tbody></table></figure><ul><li>分析： <code>Name ="nicholas"</code>就是全局变量，在<code>change_name()</code>函数体内可以直接调用打印出<code>change_name nicholas</code></li></ul><ol><li>当全局变量与局部变量同名时<br>在定义局部变量的子程序内，局部变量起作用；在其他地方全局起作用</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Name =<span class="string">"nicholas"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span>():</span></span><br><span class="line">    Name =<span class="string">"ZhaoSiEr"</span></span><br><span class="line">    print(<span class="string">"change_name"</span>,Name)</span><br><span class="line">change_name()</span><br><span class="line">print(Name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>change_name ZhaoSiEr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nicholas</span><br></pre></td></tr></tbody></table></figure><ul><li>分析：当全局变量与局部变量同名时：在<code>def change_name():</code>函数内部，执行<code>print("change_name",Name)</code>语句时，这里的<code>Name</code>优先调用函数内部的值，函数执行结束后执行<code>print(Name)</code>语句，全局变量<code>Name ="nicholas"</code> 起作用。</li></ul><ol><li><p>如果函数内部无global关键字<br>优先读取局部变量，如果没有局部变量则读取全局变量，此时无法对全局变量进行赋值。 但是对于可变对象可以对内部元素进行操作（如<code>append()</code>,<code>pop()</code>）</p><ul><li>有声明（同名）局部变量<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name =[<span class="string">"Lijing Yi"</span>,<span class="string">"Shaogang Zhang"</span>]</span><br><span class="line">print(<span class="number">1</span>,name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span>():</span></span><br><span class="line">    name =<span class="string">"Dan Li"</span></span><br><span class="line">    print(<span class="string">"Dalao"</span>,name)</span><br><span class="line">change_name()</span><br><span class="line">print(<span class="number">2</span>,name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> [<span class="string">"Lijing Yi"</span>,<span class="string">"Shaogang Zhang"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dalao Dan Li</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> [<span class="string">"Lijing Yi"</span>,<span class="string">"Shaogang Zhang"</span>]</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li>这里无<code>global</code>关键字，执行<code>print(1,name)</code>语句时读取全局变量<code>name =["Lijing Yi","Shaogang Zhang"]</code>，之后执行<code>change_name()</code>函数，在函数里面<code>name ="Dan Li"</code>。执行<code>print("Dalao",name)</code>语句，这里的<code>name</code>优先读取函数内部的局部变量<code>name ="Dan Li"</code>，因此输出<code>Dalao Dan Li</code>。之后<code>change_name()</code>函数结束。执行<code>print(2,name)</code>语句时，这里仍然读取全局变量<code>name =["Lijing Yi","Shaogang Zhang"]</code>。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>搜索（BFS, DFS, Backtracking）</title>
    <link href="http://watermelondrip.github.io/2021/03/29/%E6%90%9C%E7%B4%A2%20/"/>
    <id>http://watermelondrip.github.io/2021/03/29/%E6%90%9C%E7%B4%A2%20/</id>
    <published>2021-03-28T13:42:00.000Z</published>
    <updated>2021-04-07T06:53:01.466Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="搜索（BFS-DFS-Backtracking）"><a href="#搜索（BFS-DFS-Backtracking）" class="headerlink" title="搜索（BFS, DFS, Backtracking）"></a>搜索（BFS, DFS, Backtracking）</h1><hr><p>广度优先算法（Breadth-First-Search），简称BFS。深度优先算法（Deep-First-Search），简称DFS。BFS:利用队列先进先出的特性，可以优先遍历横向节点。DFS:利用栈先进后出的特性，可以优先遍历纵向节点。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md">搜索</a></h2><p>深度优先搜索和广度优先搜索广泛应用于树和图中。 （1） BFS  (2) DFS  (3) Backtracking</p><h2 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h2><h1 id="BFS-广度优先搜索）"><a href="#BFS-广度优先搜索）" class="headerlink" title="BFS (广度优先搜索）"></a>BFS (广度优先搜索）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p>广度优先算法（BFS）：是一种<a href="https://www.xiaoheidiannao.com/13213.html">图形搜索演算法</a>。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点，如果发现目标，则演算终止。</p><h2 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h2><p>BFS是一种盲目搜寻法，目的是系统的展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为主。</p><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>邻接表的时候是$O(|V|+|E|)$。其中，$|V|$是节点的数目，$|E|$是图中边的数目。</p><h2 id="适应条件："><a href="#适应条件：" class="headerlink" title="适应条件："></a>适应条件：</h2><p>对于所有边长度相同的情况，比如地图的模型，BFS第一次遇到目标点，此时就一定是从根节点到目标节点的最短路径（因为每次所有的点都是向外扩张一步，你先遇到，那你就一定最短的了）。<strong>BFS先找到的一定是最短的</strong>。但是如果是加权边的话就会有问题，BFS传回的是经过<strong>边数最少</strong>的解，但是因为加权了，这个解到根节点的<strong>距离</strong>就不一定是最短的了。比如1000+1000是两段，1+1+1是三段，但是由于BFS返回的是是<strong>经过边数最少的的解</strong>，这里就会返回总长度是2000的那个解，但是显然不是距离最短的路径。此时我们就应该采用<strong>Dijkstra最短路算法</strong>解决加权路径的最短路了（这就有点超纲了呀）。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>寻找非加权图(或者所有边权重是一样)中任两点的最短路径。</li><li>寻找其中一个连通分支中的所有节点（扩散性）。</li><li>BFS染色法判断是否为二分图</li><li>BFS也可以运用在算法和爬虫之中。而BFS优先处理自己周围的资源。所以在爬虫可以用于遍历网站，搜寻整个网站的价值信息等等，笔者以前用爬虫+bfs实现过下载网站的模板(17素材的网页模板)。 而在算法中，在迷宫或者无权图中，bfs可以找到最短路径。并且在bfs还有变种的A*等高级算法。并 且bfs经常和优先队列在一起搜索部分有其他规则的目的地。  </li></ol><h2 id="大佬解释BFS"><a href="#大佬解释BFS" class="headerlink" title="大佬解释BFS"></a>大佬解释BFS</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/40151973#:~:text=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88Breadth%2DFirst,%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BB%A5%E6%89%BE%E5%AF%BB%E7%BB%93%E6%9E%9C%E3%80%82">BFS算法介绍</a></li><li><a href="https://zhuanlan.zhihu.com/p/50187643">算法- 从栈 &amp; 队列 到 BFS &amp; DFS</a></li><li><a href="https://www.jianshu.com/p/d2125448270b">用Python实现树的BFS与DFS</a></li><li><a href="https://zhuanlan.zhihu.com/p/141898546">LeetCode | 一文帮你搞定BFS、DFS算法（python版）</a></li></ol><h1 id="DFS-深度优先搜索）"><a href="#DFS-深度优先搜索）" class="headerlink" title="DFS (深度优先搜索）"></a>DFS (深度优先搜索）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h2><p>深度优先搜索（DFS）：也是一种图形搜索演算法。简单的说，DFS是从根节点开始，沿着树的深度遍历树的节点，沿着一条路一直走到底，然后从这条路的尽头的节点回退到上一个节点，再从另一条路开始走到底，不断重复，  如果发现目标，则演算终止。特点是<strong>不撞南墙不回头</strong>，先走完一条路，再换一条路继续走。</p><h2 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a>算法分析：</h2><p>DFS也是一种盲目搜寻法，目的是系统的展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为主。树是图的一个特例，树是如何用深度优先遍历进行遍历的<a href="https://developer.aliyun.com/article/756316">戳这里</a></p><h2 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>邻接表的时候是$O(|V|+|E|)$。其中，$|V|$是节点的数目，$|E|$是图中边的数目。<br>邻接矩阵表示时，查找每个顶点的邻接点所需时间为$O(|V|)$，要查找整个矩阵，故总的时间度为$O(|V|^2)$。</p><h2 id="适应条件：-1"><a href="#适应条件：-1" class="headerlink" title="适应条件："></a>适应条件：</h2><p>广度优先搜索一层一层遍历，每一层得到的所有新节点，用队列存储起来以备下一层遍历的时候再遍历。而深度优先搜索再得到一个新的节点时立即堆新节点进行遍历。从一个节点出发，使用DFS对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS常用来求解这种<strong>可达性</strong>问题。</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>1.dfs可以运用在查找和爬虫中，如果爬虫的话那么更多是优先找到不同链接，可用于统计等。而在查找中比如迷宫类可以利用dfs判断 是否存在路径，出路等等。<a href="https://juejin.cn/post/6844903934616682509">click here</a></p><h2 id="大佬解释BFS-1"><a href="#大佬解释BFS-1" class="headerlink" title="大佬解释BFS"></a>大佬解释BFS</h2><ol><li><a href="https://www.pythonf.cn/read/99825">深度优先搜索（DFS）和广度优先搜索（BFS）</a> </li><li><a href="https://juejin.cn/post/6844903934616682509">深度优先搜索、广度优先搜索(dfs和bfs)详解</a></li></ol><h1 id="BFS-vs-DFS"><a href="#BFS-vs-DFS" class="headerlink" title="BFS vs DFS"></a>BFS vs DFS</h1><p><img src= "/img/watermelon.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200428190053807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTM4OTg=,size_16,color_FFFFFF,t_70" alt="avatar"></p><h2 id="BFS思想："><a href="#BFS思想：" class="headerlink" title="BFS思想："></a>BFS思想：</h2><p>BFS是队列的思想。如下图，BFS从起点<code>A</code>,把<code>A</code>附近的点<code>(B,C)</code>先遍历，遍历完<code>(B,C)</code>入队，然后再以<code>B</code>为起点，遍历<code>B</code>点附近的未被遍历过的点。<strong>呈现扩散趋势</strong>。所以以下图为例，以<code>A</code>点为起点，BFS遍历顺序是：<code>[A,B,C,D,E,F]</code></p><h2 id="DFS思想："><a href="#DFS思想：" class="headerlink" title="DFS思想："></a>DFS思想：</h2><p>DFS是栈的思想。如下图，DFS从起点<code>A</code>（被遍历）,把<code>A</code>附近的点<code>B,C</code>先入栈，由于栈是后进先出，所以<code>C</code>先出栈（被遍历），然后接着<code>C</code>点附近未入栈的<code>D,E</code>点入栈，然后是后入过栈的<code>E</code>点出栈（被遍历），然后接着<code>E</code>点附近找未入过栈的点，但是发现<code>E</code>点附近的点都入过栈，这是没有新的点入栈了，那就开始出栈。所以<code>D</code>点开始出栈（被遍历），然后<code>D</code>点附近没有入过栈的<code>F</code>点入栈，又没有未入过栈的点，点<code>F</code>出栈（被遍历），只剩点<code>B</code>（被遍历）。</p><h1 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h2><ol><li>当题目中出现“所有组合”等类似字眼时，我们第一感觉就要想到用回溯了。</li><li><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但是当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p></li><li><p>Backtracking（回溯）属于DFS</p><ul><li>普通DFS主要用在可达性问题，这种问题只需要执行到特点的位置然后返回即可。而Backtracking主要用于求解排列组合问题，例如有<code>{'a','b','c'}</code>三个字符，求解所有由这三个字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li></ul></li><li><p>Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p><ul><li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素</li><li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li></ul></li><li><p>回溯本质是暴力搜索，再问题的解空间树中，用DFS的方式，从根节点出发搜索整个解空间。如果要找出所有的解，则要搜索整个子树，如果只用找出一个解，则搜到一个解就可以结束搜索。<strong>找出所有可能的组合</strong>的问题，适合用回溯算法。</p></li></ol><h2 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a>算法分析：</h2><h2 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><h2 id="适应条件：-2"><a href="#适应条件：-2" class="headerlink" title="适应条件："></a>适应条件：</h2><h2 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h2><ol><li>回溯法来解决<code>n</code>个<code>for</code>循环问题</li></ol><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>回溯算法专注三个问题:</p><ul><li>路径：已经做出的选择</li><li>选择列表：当前可以做的选择</li><li>结束条件：到达决策树底层，无法再做选择<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径，选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件：</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="大佬解释BFS-2"><a href="#大佬解释BFS-2" class="headerlink" title="大佬解释BFS"></a>大佬解释BFS</h2><ol><li><p>个人认为，充分剪枝的回溯算法和三层嵌套的暴力循环，复杂度是一样的，而不存在什么“暴力循环是O(1)，回溯不是O(1)”的情况。字符串拷贝（构造）在许多语言下应当都类似于数组拷贝，是一个O(|s|)的操作，暴力循环也无法避免数组拷贝，所以在输出集合生产这件事下，回溯 = 暴力循环。至于递归和循环究竟有多少层，画画递归调用栈就看出来了，二者是一模一样的（当然递归需要剪枝）。</p><p> 究其原因，本题说白了是一个每个顶点度最大为3，且半径最大为4的无向图，从中心出发完成遍历。这种图的循环当然好写了，因为规模小呀。而且本题因为状态的出现和游标推移是完全一致的，所以并不需要构造图，循环显得非常易写。</p><p> 脱离性能层面，也且不论代码可读性层面，回溯仍是必须要掌握的算法。虽然回溯算法由于“指数爆炸”通常不适用于大规模的计算，但它仍然是算法领域里一个重要组成，甚至很多时候是最优解。并且，许多时候它逐渐缩小问题规模的思考方式，在特定的问题下，稍加改动就能通向很多其他算法分支——动态规划、记忆化搜索等。</p></li></ol><hr><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><hr><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="LC1091-计算在网格中从原点到特定点的最短路径长度-计算在网格中从原点到特定点的最短路径长度"><a href="#LC1091-计算在网格中从原点到特定点的最短路径长度-计算在网格中从原点到特定点的最短路径长度" class="headerlink" title="(LC1091)计算在网格中从原点到特定点的最短路径长度   计算在网格中从原点到特定点的最短路径长度 "></a>(LC1091)计算在网格中从原点到特定点的最短路径长度   <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">计算在网格中从原点到特定点的最短路径长度 </a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p> 给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：路径途经的所有单元格都的值都是 0 。路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。畅通路径的长度 是该路径途经的单元格总数。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1],[1,0]]</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>Deque(class collections.deque([iterable[,maxlen]])) <a href="collections中 deque的使用">使用戳一戳</a><ul><li>Deque是双边队列（double-ended queue），具有队列和栈的性质，在 list 的基础上增加了移动、旋转和增删等。</li><li>Deque队列是由栈或者queue队列生成的（发音是”deck”,”double-ended queue”的简称）。</li><li>Deque是一个双端队列, 如果要经常从两端append 的数据, 选择这个数据结构就比较好了, 如果要实现随机访问,不建议用这个,请用列表。Deque 优势就是可以从两边append ,appendleft 数据。这一点list 是没有的<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">queue = deque([<span class="string">"Eric"</span>, <span class="string">"John"</span>, <span class="string">"Michael"</span>])</span><br><span class="line">queue.append(<span class="string">"Terry"</span>)           <span class="comment"># Terry 入队</span></span><br><span class="line">queue.append(<span class="string">"Graham"</span>)          <span class="comment"># Graham 入队</span></span><br><span class="line">queue.popleft()                 <span class="comment"># 队首元素出队</span></span><br><span class="line"><span class="comment">#输出: 'Eric'</span></span><br><span class="line">queue.popleft()                 <span class="comment"># 队首元素出队</span></span><br><span class="line"><span class="comment">#输出: 'John'</span></span><br><span class="line">print(queue)                           <span class="comment"># 队列中剩下的元素</span></span><br><span class="line"><span class="comment">#输出: deque(['Michael', 'Terry', 'Graham'])</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>第一次刷这个BFS,毫无头绪，怎么办？首先是看到大佬的一个模板，先偷过来<ul><li>第一步：先构造图<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initial_graph</span>(<span class="params">n, edges</span>):</span></span><br><span class="line">    dict_graph = {}  <span class="comment">#用字典表示</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dict_graph[i] = []</span><br><span class="line">    num_e = <span class="built_in">len</span>(edges)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_e):</span><br><span class="line">        u = edges[i][<span class="number">0</span>] <span class="comment">#用矩阵表示</span></span><br><span class="line">        v = edges[i][<span class="number">1</span>]</span><br><span class="line">        dict_graph[u].append(v)</span><br><span class="line">        dict_graph[v].append(u)</span><br><span class="line">    <span class="keyword">return</span> dict_graph</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><ul><li>第二步：使用队列<br>  BFS适用于层级搜索，队列先进先出，量身定做。python中队列有两种导入方法：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.使用queue  #队列</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line">q = Queue() <span class="comment"># 定义，为什么是这样涉及python的设计，不是很懂</span></span><br><span class="line">q.put(node) <span class="comment"># 放入</span></span><br><span class="line">q.get() <span class="comment"># 出队</span></span><br><span class="line"><span class="comment"># 2.使用deque</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">q = collections.deque() <span class="comment"># 双向队列</span></span><br><span class="line">q.append() <span class="comment"># 入队</span></span><br><span class="line">q.popleft() <span class="comment"># 出队</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>第三步：节点入队</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Queue()定义</span></span><br><span class="line">q.put(start_node)</span><br><span class="line"><span class="comment"># 为防止无向图中回溯，使用set阻断</span></span><br><span class="line">hash_set = <span class="built_in">set</span>()</span><br><span class="line">hash_set.add(start_node)</span><br></pre></td></tr></tbody></table></figure></li><li><p>第四步：BFS主体</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">size = <span class="built_in">len</span>(q)</span><br><span class="line">step += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> iter_num <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">node = q.get() <span class="comment"># current node</span></span><br><span class="line"><span class="comment"># get the neighbor</span></span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> dict_graph[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor == end_node: <span class="comment"># find it!!!!</span></span><br><span class="line"><span class="keyword">return</span> step</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> hash_set:</span><br><span class="line"><span class="keyword">continue</span> <span class="comment"># avoid backtracking</span></span><br><span class="line">hast_set.add(node)</span><br><span class="line">q.put(neighbor)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="comment"># can't find</span></span><br></pre></td></tr></tbody></table></figure></li></ul><ol><li>具体操作<ul><li>本题本身就是矩阵，就不需要重新弄建initial。从头遍历，每次遇到0的时候，将周围8个方向可走的点push进队列，这样就可以将下一步能走的点找到。</li><li>用一个大小为3的数组来保存当前点的坐标，和走到当前点所需要的代价</li><li>由于要找的是花费路径最短的，所以第一个符合循环结束条件的数组，其第三个值就是我们要找的最小代价</li></ul></li></ol><h4 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">or</span> grid[n - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>:  <span class="comment"># 若起始点或终点堵塞，则不可能有这样的路径</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">1</span>  <span class="comment"># 注意题目的描述，是返回从 1 到 k 的路径，第一个节点被定为下标 1，</span></span><br><span class="line">        path = deque()</span><br><span class="line">        path.append([<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 先压入起点</span></span><br><span class="line">        <span class="keyword">while</span> path:  <span class="comment"># BFS模板</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path)):  <span class="comment"># 对BFS的某一层的中所有点向8个方向进行扩展</span></span><br><span class="line">                x, y = path.popleft()</span><br><span class="line">                <span class="keyword">for</span> new_x, new_y <span class="keyword">in</span> [[x - <span class="number">1</span>, y - <span class="number">1</span>], [x - <span class="number">1</span>, y], [x - <span class="number">1</span>, y + <span class="number">1</span>], [x, y - <span class="number">1</span>],</span><br><span class="line">                                     [x, y + <span class="number">1</span>], [x + <span class="number">1</span>, y - <span class="number">1</span>], [x + <span class="number">1</span>, y], [x + <span class="number">1</span>, y + <span class="number">1</span>]]:</span><br><span class="line">                    <span class="comment"># 下面几种continue可以合并一行，这里为看的清楚就分开写了</span></span><br><span class="line">                    <span class="keyword">if</span> new_x == n - <span class="number">1</span> <span class="keyword">and</span> new_y == n - <span class="number">1</span>:  <span class="comment"># 如果扩展的点到达了终点</span></span><br><span class="line">                        <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_x &lt; n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_y &lt; n:  <span class="comment"># 扩展的点超出边界，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">1</span>:  <span class="comment"># 若扩展的点为阻塞，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == -<span class="number">1</span>:  <span class="comment"># 若扩展的点已经访问过，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">0</span>:  <span class="comment"># 若为通畅点</span></span><br><span class="line">                        grid[new_x][new_y] = -<span class="number">1</span>  <span class="comment"># 当前层次下已经访问该点</span></span><br><span class="line">                        path.append([new_x, new_y])  <span class="comment"># 将扩展的点加入path，到下一层的时候继续扩展</span></span><br><span class="line">            res += <span class="number">1</span>  <span class="comment"># 对某一层的元素都求判定过后，距离加1(同一个层次中的所有点的距离距离起点都是相等的）</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC297-完全平方数-完全平方数"><a href="#LC297-完全平方数-完全平方数" class="headerlink" title="(LC297)完全平方数   完全平方数 "></a>(LC297)完全平方数   <a href="https://leetcode-cn.com/problems/perfect-squares/description/">完全平方数 </a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol><li>可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。</li><li><a href="https://leetcode-cn.com/problems/perfect-squares/solution/dong-tai-gui-hua-bfs-zhu-xing-jie-shi-python3-by-2/">广度优先遍历</a></li><li><h4 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([n])  <span class="comment">#必须带[]，否则不是iterable </span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            step +=<span class="number">1</span></span><br><span class="line">            l = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                temp = queue.pop()  <span class="comment"># 不能用 queue.popleft() 因为后面用的是appendleft。前后只能有一个left</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(temp**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">                    x = temp - i**<span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> step</span><br><span class="line">                    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(x)</span><br><span class="line">                        queue.appendleft(x)</span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC127-单词接龙-单词接龙"><a href="#LC127-单词接龙-单词接龙" class="headerlink" title="(LC127 )单词接龙   单词接龙 "></a>(LC127 )单词接龙   <a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙 </a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>序列中第一个单词是 beginWord 。<br>序列中最后一个单词是 endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典 wordList 中的单词。<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog", 返回它的长度 5。 </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>从起点词出发，每次变一个字母，经过n次变换，变成终点词，希望n尽量小。</li><li>我们需要找出邻接关系，比如<code>hit</code>变成一个字母会变成<code>_it</code>，<code>h_t</code>，<code>hi_</code>形式的新词，再看看该新词是否存在于单词表中，如果存在，就找到了一个下一层的转换词。</li><li>同时，要避免重复访问，<code>hot-&gt;dot-&gt;hot</code>这样变回来是没有意义的，徒增转换的长度。</li><li>所以确定了下一个转换词之后， 将它从单词表中删除（单词表里的单词是唯一的）</li><li><code>wordSet=set(wordList)</code>，方便<code>o(1)</code>时间复杂度查找</li><li></li></ol><h4 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([beginWord])</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        wordSet = <span class="built_in">set</span>(wordList)</span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">in</span> wordSet:</span><br><span class="line">            wordSet.remove(beginWord)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            step+=<span class="number">1</span></span><br><span class="line">            l = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                word = queue.pop()</span><br><span class="line">                <span class="keyword">if</span> word == endWord:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">                  <span class="comment"># 开始变化单词（一个位置有26种情况）</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                        new_word = word[:j] + <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">'a'</span>)+i) + word[j+<span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> new_word <span class="keyword">in</span> wordSet: </span><br><span class="line">                            wordSet.remove(new_word)</span><br><span class="line">                            queue.appendleft(new_word)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p> 最坏情况下时间复杂度：O(m*n)，n为字典中单词数量，m为单词长度  </p><ul><li>时间复杂度：$O(m*n)$</li><li>空间复杂度：$O(n)$</li></ul><h4 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h4><hr><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><hr><h3 id="LC695-岛屿的最大面积-岛屿的最大面积"><a href="#LC695-岛屿的最大面积-岛屿的最大面积" class="headerlink" title="(LC695)岛屿的最大面积   岛屿的最大面积 "></a>(LC695)岛屿的最大面积   <a href="https://leetcode-cn.com/problems/max-area-of-island/">岛屿的最大面积 </a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。<br>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]] </span><br></pre></td></tr></tbody></table></figure><br>对于上面这个给定矩阵应返回 6。注意答案不应该是 11，因为岛屿只能包含水平或垂直的四个方向的 1 。<p></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span>  <span class="comment">#grid 是小岛，也就是题目中给的矩阵</span></span><br><span class="line">       <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">       stack = deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       ans = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> i,l <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid): </span><br><span class="line">           <span class="keyword">for</span> j,n <span class="keyword">in</span> <span class="built_in">enumerate</span>(l):    <span class="comment">#[i,j] 是 n 在grid 中的位置（下标[i,j]）</span></span><br><span class="line">               cur = <span class="number">0</span></span><br><span class="line">               stack.append([i,j])</span><br><span class="line">               <span class="keyword">while</span> stack:</span><br><span class="line">                   cur_i, cur_j = stack.pop()</span><br><span class="line">                   <span class="keyword">if</span> cur_i &lt; <span class="number">0</span> <span class="keyword">or</span> cur_j &lt; <span class="number">0</span>  <span class="keyword">or</span> cur_i == <span class="built_in">len</span>(grid) <span class="keyword">or</span> cur_j == <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[cur_i][cur_j]== <span class="number">0</span>:</span><br><span class="line">                       <span class="keyword">continue</span></span><br><span class="line">                   cur+=<span class="number">1</span></span><br><span class="line">                   grid[cur_i][cur_j]=<span class="number">0</span></span><br><span class="line">                   <span class="keyword">for</span> di, dj <span class="keyword">in</span> [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,-<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>]]:</span><br><span class="line">                       next_i , next_j = cur_i + di, cur_j + dj</span><br><span class="line">                       stack.append([next_i,next_j])</span><br><span class="line">               ans = <span class="built_in">max</span>(ans,cur)</span><br><span class="line">       <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC200-岛屿数量-岛屿数量"><a href="#LC200-岛屿数量-岛屿数量" class="headerlink" title="(LC200)岛屿数量   岛屿数量 "></a>(LC200)岛屿数量   <a href="https://leetcode-cn.com/problems/number-of-islands/description/">岛屿数量 </a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  ["1","1","1","1","0"],</span><br><span class="line">  ["1","1","0","1","0"],</span><br><span class="line">  ["1","1","0","0","0"],</span><br><span class="line">  ["0","0","0","0","0"]</span><br><span class="line">]</span><br><span class="line">输出：1 </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>DFS (一条路走到黑)，看看有几个路可以走</li><li>暂时先不用字典，一步一步来，这样if 的看起来清晰</li></ul><h4 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        rows_count = <span class="built_in">len</span>(grid)</span><br><span class="line">        cols_count = <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">if</span> grid <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        stack = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows_count):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols_count):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    num_islands+=<span class="number">1</span></span><br><span class="line">                    stack.append([i,j])</span><br><span class="line">                    <span class="keyword">while</span> stack:</span><br><span class="line">                        ci,cj = stack.pop()</span><br><span class="line">                        grid[ci][cj] = <span class="string">'0'</span></span><br><span class="line">                        <span class="keyword">if</span> ci&gt;<span class="number">0</span> <span class="keyword">and</span> grid[ci-<span class="number">1</span>][cj]==<span class="string">'1'</span>: </span><br><span class="line">                        <span class="comment">#不能改成elif 要不就变成每次stack pop一个append 一个了， 就没有积压的过程了</span></span><br><span class="line">                            stack.append([ci-<span class="number">1</span>,cj])</span><br><span class="line">                        <span class="keyword">if</span> cj&gt;<span class="number">0</span> <span class="keyword">and</span> grid[ci][cj-<span class="number">1</span>]==<span class="string">'1'</span>:</span><br><span class="line">                            stack.append([ci,cj-<span class="number">1</span>])</span><br><span class="line">                        <span class="keyword">if</span>  rows_count-<span class="number">1</span> &gt;ci <span class="keyword">and</span> grid[ci+<span class="number">1</span>][cj]==<span class="string">'1'</span>:</span><br><span class="line">                            stack.append([ci+<span class="number">1</span>,cj])</span><br><span class="line">                        <span class="keyword">if</span>  cols_count-<span class="number">1</span> &gt;cj <span class="keyword">and</span> grid[ci][cj+<span class="number">1</span>]==<span class="string">'1'</span>:</span><br><span class="line">                            stack.append([ci,cj+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> num_islands</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：$O(m*n)$，其中，m行数，n列数</li><li>空间复杂度：$O(m<em>n)$，再最坏的情况下，整个网格均为陆地，深度优先搜索的深度达到m</em>n</li></ul><h4 id="大佬题解-4"><a href="#大佬题解-4" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC547-Number-of-Provinces-Number-of-Provinces-Number-of-Provinces"><a href="#LC547-Number-of-Provinces-Number-of-Provinces-Number-of-Provinces" class="headerlink" title="(LC547 Number of Provinces) Number of Provinces   Number of Provinces"></a>(LC547 Number of Provinces) Number of Provinces  <a href="https://leetcode-cn.com/problems/number-of-provinces/"> Number of Provinces</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>(看题解发现以前是朋友圈）有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。<br>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。返回矩阵中 省份 的数量。<br>(以前的题)题目描述：好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0][1] 和 M[1][0] 的值都为 1。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">Output: 2 </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><ul><li>deque模块是python标准库collections中的一项，它提供了两端都可以操作的序列，这意味着，在序列的前后你都可以执行添加或删除操作</li></ul><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ul><li>DFS+栈</li></ul><h4 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment">#双向队列 </span></span><br><span class="line">        n = <span class="built_in">len</span>(isConnected)</span><br><span class="line">        visited = <span class="built_in">dict</span>()        </span><br><span class="line">        circles = <span class="number">0</span></span><br><span class="line">        stack = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> visited.get(i):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            stack.append([i,i])</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                i, j = stack.pop()</span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> visited.get(index): <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> isConnected[i][index]: stack.append((i, index))  </span><br><span class="line">                    <span class="keyword">if</span> isConnected[j][index]: stack.append((j, index))   </span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">                visited[j] = <span class="literal">True</span></span><br><span class="line">            circles += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> circles </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-5"><a href="#大佬题解-5" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="被围绕的区域-LC130-被围绕的区域"><a href="#被围绕的区域-LC130-被围绕的区域" class="headerlink" title="被围绕的区域 (LC130 )  被围绕的区域"></a>被围绕的区域 (LC130 )  <a href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的’O’ 用 ‘X’ 填充</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ul><li>把边界的O变为M，中间的O变为x,</li></ul><h4 id="Python3-Code-6"><a href="#Python3-Code-6" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        m = <span class="built_in">len</span>(board)</span><br><span class="line">        n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        stack = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> i == m - <span class="number">1</span> <span class="keyword">or</span> j == n-<span class="number">1</span> ) <span class="keyword">and</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    stack.append([i,j])</span><br><span class="line">                    board[i][j] = <span class="string">'M'</span></span><br><span class="line">                    <span class="keyword">while</span> stack:</span><br><span class="line">                        ci,cj = stack.pop()</span><br><span class="line">                        board[ci][cj] = <span class="string">'M'</span></span><br><span class="line">                        <span class="keyword">if</span> ci &gt; <span class="number">0</span> <span class="keyword">and</span> board[ci-<span class="number">1</span>][cj] == <span class="string">'O'</span>:</span><br><span class="line">                            stack.append([ci-<span class="number">1</span>,cj])</span><br><span class="line">                        <span class="keyword">if</span> cj &gt; <span class="number">0</span> <span class="keyword">and</span> board[ci][cj-<span class="number">1</span>] == <span class="string">'O'</span>:</span><br><span class="line">                            stack.append([ci,cj-<span class="number">1</span>])</span><br><span class="line">                        <span class="keyword">if</span> ci &lt; m -<span class="number">1</span> <span class="keyword">and</span> board[ci+<span class="number">1</span>][cj] == <span class="string">'O'</span>:</span><br><span class="line">                            stack.append([ci+<span class="number">1</span>,cj])</span><br><span class="line">                        <span class="keyword">if</span> cj &lt; n-<span class="number">1</span> <span class="keyword">and</span> board[ci][cj+<span class="number">1</span>] == <span class="string">'O'</span>:</span><br><span class="line">                            stack.append([ci,cj+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'M'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br><span class="line">        <span class="keyword">return</span> board</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-6"><a href="#大佬题解-6" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC417-太平洋大西洋水流问题-太平洋大西洋水流问题"><a href="#LC417-太平洋大西洋水流问题-太平洋大西洋水流问题" class="headerlink" title="(LC417 )太平洋大西洋水流问题   太平洋大西洋水流问题 "></a>(LC417 )太平洋大西洋水流问题   <a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/description/">太平洋大西洋水流问题 </a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。<br>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。<br>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line">返回:</span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-7"><a href="#Python3-Code-7" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-7"><a href="#大佬题解-7" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="BackTracking"><a href="#BackTracking" class="headerlink" title="BackTracking"></a>BackTracking</h2><h3 id="LC17-电话号码的字母组合-电话号码的字母组合"><a href="#LC17-电话号码的字母组合-电话号码的字母组合" class="headerlink" title="(LC17)电话号码的字母组合     电话号码的字母组合 "></a>(LC17)电话号码的字母组合    <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/"> 电话号码的字母组合 </a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = "23"</span><br><span class="line">输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ul><li><p>图解<br><img src= "/img/watermelon.gif" data-lazy-src="https://pic.leetcode-cn.com/38567dcbb6401d88946ca974aacffb5ab27cb1ad54056f02b59016c0cc68b40f-file_1562774451350" style="zoom:70%"></p></li><li><p>回溯</p><ul><li>首先使用哈希表存储每个数字对应的所有的可能字母，然后进行回溯操作。</li><li>回溯过程中维护一个字符串，<h4 id="Python3-Code-8"><a href="#Python3-Code-8" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4></li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        dic = {<span class="string">'2'</span>:<span class="string">'abc'</span>,<span class="string">'3'</span>:<span class="string">"def"</span>,<span class="string">'4'</span>:<span class="string">"ghi"</span>,<span class="string">'5'</span>:<span class="string">"jkl"</span>,<span class="string">'6'</span>:<span class="string">"mno"</span>,<span class="string">'7'</span>:<span class="string">"pqrs"</span>,<span class="string">'8'</span>:<span class="string">"tuv"</span>,<span class="string">'9'</span>:<span class="string">"wxyz"</span>}</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(digits):</span><br><span class="line">                ans.append(<span class="string">''</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> dic[s[<span class="number">0</span>]]:</span><br><span class="line">                path.append(letter)</span><br><span class="line">                backtrack(s[<span class="number">1</span>:])</span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(digits)</span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度： $O(3^M * 4^N$。M是对应三个字母的数字的个数，N是对应是四个字母的数字个数   。</li><li>空间复杂度：$O(M+N)$。M+N是输入数字的总个数。除了返回值之外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用的层数，哈希表的大小与输入无关，可以堪称常数，递归调用层数最大为M+N。</li></ul><h4 id="大佬题解-8"><a href="#大佬题解-8" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC"><a href="#LC" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-9"><a href="#Python3-Code-9" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-9"><a href="#复杂度分析-9" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-9"><a href="#大佬题解-9" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC46-Permutations-Medium-全排列"><a href="#LC46-Permutations-Medium-全排列" class="headerlink" title="(LC46 )  Permutations (Medium)    全排列 "></a>(LC46 )  Permutations (Medium)   <a href="https://leetcode-cn.com/problems/permutations/submissions/"> 全排列 </a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><p>给定一没有重复 数字的序列，返回其所有可能的全排列<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">] </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ul><li><h4 id="Python3-Code-10"><a href="#Python3-Code-10" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="comment">#终止条件：走到树的底层</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment">#剪枝</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">in</span> path:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(num)</span><br><span class="line">                backtrack(s[<span class="number">1</span>:])</span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-10"><a href="#复杂度分析-10" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-10"><a href="#大佬题解-10" class="headerlink" title="大佬题解"></a>大佬题解</h4><ol><li>参考到大佬的一个控制台的输出，有助于理解其中的奥妙<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  递归之前 =&gt; [1]</span><br><span class="line">  递归之前 =&gt; [1, 2]</span><br><span class="line">  递归之前 =&gt; [1, 2, 3]</span><br><span class="line">递归之后 =&gt; [1, 2]</span><br><span class="line">递归之后 =&gt; [1]</span><br><span class="line">  递归之前 =&gt; [1, 3]</span><br><span class="line">  递归之前 =&gt; [1, 3, 2]</span><br><span class="line">递归之后 =&gt; [1, 3]</span><br><span class="line">递归之后 =&gt; [1]</span><br><span class="line">递归之后 =&gt; []</span><br><span class="line">  递归之前 =&gt; [2]</span><br><span class="line">  递归之前 =&gt; [2, 1]</span><br><span class="line">  递归之前 =&gt; [2, 1, 3]</span><br><span class="line">递归之后 =&gt; [2, 1]</span><br><span class="line">递归之后 =&gt; [2]</span><br><span class="line">  递归之前 =&gt; [2, 3]</span><br><span class="line">  递归之前 =&gt; [2, 3, 1]</span><br><span class="line">递归之后 =&gt; [2, 3]</span><br><span class="line">递归之后 =&gt; [2]</span><br><span class="line">递归之后 =&gt; []</span><br><span class="line">  递归之前 =&gt; [3]</span><br><span class="line">  递归之前 =&gt; [3, 1]</span><br><span class="line">  递归之前 =&gt; [3, 1, 2]</span><br><span class="line">递归之后 =&gt; [3, 1]</span><br><span class="line">递归之后 =&gt; [3]</span><br><span class="line">  递归之前 =&gt; [3, 2]</span><br><span class="line">  递归之前 =&gt; [3, 2, 1]</span><br><span class="line">递归之后 =&gt; [3, 2]</span><br><span class="line">递归之后 =&gt; [3]</span><br><span class="line">递归之后 =&gt; []</span><br><span class="line">输出 =&gt; [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] </span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="LC47-全排列II-全排列II"><a href="#LC47-全排列II-全排列II" class="headerlink" title="(LC47 )全排列II    全排列II"></a>(LC47 )全排列II    <a href="https://leetcode-cn.com/problems/permutations-ii/description/">全排列II</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>给定一个可包含重复数字的序列 <code>nums</code>，按任意顺序返回所有不重复的全排列。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></tbody></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-11"><a href="#Python3-Code-11" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans = <span class="built_in">list</span>() </span><br><span class="line">        visited = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums,visited</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">                    ans.append(path[:])</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> visited[i]: </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i]) </span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">                backtrack(nums,visited)</span><br><span class="line">                path.pop(-<span class="number">1</span>) </span><br><span class="line">                visited[i] = <span class="literal">False</span></span><br><span class="line">        backtrack(nums,visited)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-11"><a href="#复杂度分析-11" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-11"><a href="#大佬题解-11" class="headerlink" title="大佬题解"></a>大佬题解</h4><ul><li>分析 LC46 和 lc47是两种全排列，思路是一样的，就是剪枝的方式不同，一个减去的方式是重复的数，一个是重复的位置。</li></ul><h3 id="LC77-组合-组合"><a href="#LC77-组合-组合" class="headerlink" title="(LC77)组合    组合"></a>(LC77)组合    <a href="https://leetcode-cn.com/problems/combinations/description/">组合</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ul><li>回溯</li></ul><h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><ul><li>itertools —- 为高效循环而创建迭代器的函数 <a href="https://docs.python.org/zh-cn/3/library/itertools.html">官方讲解</a> 感觉这个真的骚</li></ul><h4 id="Python3-Code-12"><a href="#Python3-Code-12" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        nums = [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)== k:</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> path: <span class="comment">#注意范围呀</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(path)&gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt; path[-<span class="number">1</span>]:</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrack(nums)<span class="comment">#如果是backtrack(nums[1:]) 注意for i in range(n)的范围啊</span></span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        nums = [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)== k:</span><br><span class="line">                ans.append(path[:])<span class="comment">##浅拷贝，这一步很重要</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">in</span> path: <span class="comment">#注意范围呀</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(path)&gt; <span class="number">0</span> <span class="keyword">and</span> num &lt; path[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span>                </span><br><span class="line">                path.append(num)</span><br><span class="line">                backtrack(nums[<span class="number">1</span>:])<span class="comment">#如果是backtrack(nums[1:]) 注意for i in range(n)的范围啊</span></span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(itertools.combinations(<span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>),k)) </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-12"><a href="#复杂度分析-12" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-12"><a href="#大佬题解-12" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC39-组合总和-组合总和"><a href="#LC39-组合总和-组合总和" class="headerlink" title="(LC39 )组合总和     组合总和 "></a>(LC39 )组合总和    <a href="https://leetcode-cn.com/problems/combination-sum/"> 组合总和 </a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">] </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-13"><a href="#Python3-Code-13" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans =  <span class="built_in">list</span>()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(path) == target:</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(path) &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(path)&gt;<span class="number">0</span> <span class="keyword">and</span> num &lt; path[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(num)</span><br><span class="line">                 </span><br><span class="line">                backtrack(nums)</span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(candidates)</span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-13"><a href="#复杂度分析-13" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-13"><a href="#大佬题解-13" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC40含有相同元素的组合求和-组合总和-II"><a href="#LC40含有相同元素的组合求和-组合总和-II" class="headerlink" title="(LC40含有相同元素的组合求和 )    组合总和 II  "></a>(LC40含有相同元素的组合求和 )    <a href="https://leetcode-cn.com/problems/combination-sum-ii/description/">组合总和 II  </a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>给定一个数组<code>candidates</code>和一个目标数<code>target</code>，找出<code>candidates</code>中所有可以使数字和为<code>target</code>的组合。<code>candidates</code>中的每个数字在每个组合中只能使用一次。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">] </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><ul><li><p>dfs<br>四种情况：<br>· 1. 排列有序，可重复：<br>· 2. 排列有序，不可重复：used（i&gt;0 and candidates[i]==candidates[i-1] and not ·used[i-1]）：去除排列重复<br>· 3. 组合没有序，可重复：start<br>· 4. 组合没有序，不可重复：start+1（+1去除组合重复）已经说明used【i-1】一定不会用上，因此不用used（i&gt;start and candidates[i]==candidates[i-1]）即可 </p></li><li><p>回溯</p></li></ul><h4 id="Python3-Code-14"><a href="#Python3-Code-14" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>  <span class="comment">#DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">target,path,start</span>):</span> <span class="comment">#DFS</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; min_cand:</span><br><span class="line">                <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                    res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                target_new = target - candidates[i]</span><br><span class="line">                path_new = path + [candidates[i]]</span><br><span class="line">                <span class="comment">#i+1 删除重复组合</span></span><br><span class="line">                dfs(target_new,path_new,i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        candidates.sort()</span><br><span class="line">        min_cand = <span class="built_in">min</span>(candidates)</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        dfs(target, path , start)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Backtracking </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">begin, path, residue</span>):</span></span><br><span class="line">            <span class="keyword">if</span> residue == <span class="number">0</span>:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(begin, size):</span><br><span class="line">                <span class="keyword">if</span> candidates[index] &gt; residue:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> index &gt; begin <span class="keyword">and</span> candidates[index - <span class="number">1</span>] == candidates[index]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(candidates[index])</span><br><span class="line">                backtrack(index + <span class="number">1</span>, path, residue - candidates[index])</span><br><span class="line">                path.pop()</span><br><span class="line">        size = <span class="built_in">len</span>(candidates)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="number">0</span>, [], target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-14"><a href="#复杂度分析-14" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-14"><a href="#大佬题解-14" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC216-1-9-数字的组合求和-组合总和-III"><a href="#LC216-1-9-数字的组合求和-组合总和-III" class="headerlink" title="(LC216)1-9 数字的组合求和    组合总和 III  "></a>(LC216)1-9 数字的组合求和    <a href="https://leetcode-cn.com/problems/combination-sum-iii/">组合总和 III  </a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><p>找出所有相加之和为<code>n</code> 的<code>k</code>个数的组合。组合中只允许含有 1-9的正整数，并且每种组合中不存在重复的数字。<br>说明：<br>所有数字都是正整数。解集不能包含重复的组合。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-15"><a href="#Python3-Code-15" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">begin, path, residue</span>):</span></span><br><span class="line">            <span class="keyword">if</span> residue == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(path)== k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(begin, size):</span><br><span class="line">                <span class="keyword">if</span> nums[index] &gt; residue:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                path.append(nums[index])</span><br><span class="line">                backtrack(index+<span class="number">1</span>, path,residue - nums[index])</span><br><span class="line">                path.pop()</span><br><span class="line">        size = <span class="number">9</span></span><br><span class="line">        nums = [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        backtrack(<span class="number">0</span>, [],n)</span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-15"><a href="#复杂度分析-15" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-15"><a href="#大佬题解-15" class="headerlink" title="大佬题解"></a>大佬题解</h4><ol><li><a href="https://leetcode-cn.com/problems/combination-sum-iii/solution/hui-su-jian-zhi-by-liweiwei1419/">回溯 + 剪枝（Java）</a></li></ol><h3 id="LC78-子集-子集"><a href="#LC78-子集-子集" class="headerlink" title="(LC78 )  子集    子集"></a>(LC78 )  子集   <a href="https://leetcode-cn.com/problems/subsets/description/"> 子集</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 互不相同。返回该数组所有可能的子集（幂集）。<br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></tbody></table></figure><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-16"><a href="#Python3-Code-16" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start,path,size</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == size:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(nums)):</span><br><span class="line">                print(path)</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, path, size)</span><br><span class="line">                path.pop( )</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>( <span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">            backtrack(<span class="number">0</span>,[],n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-16"><a href="#复杂度分析-16" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-16"><a href="#大佬题解-16" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC90含有相同元素求子集-子集-II"><a href="#LC90含有相同元素求子集-子集-II" class="headerlink" title="(LC90含有相同元素求子集 )    子集 II"></a>(LC90含有相同元素求子集 )    <a href="https://leetcode-cn.com/problems/subsets-ii/description/">子集 II</a></h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-17"><a href="#Python3-Code-17" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">begin,path,size</span>):</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == size:</span><br><span class="line">                <span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    res.append(path[:])</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin,<span class="built_in">len</span>(nums)):</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, path, size)</span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">            backtrack(<span class="number">0</span>, [], n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-17"><a href="#复杂度分析-17" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-17"><a href="#大佬题解-17" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC131-分割回文串-分割回文串"><a href="#LC131-分割回文串-分割回文串" class="headerlink" title="(LC131)  分割回文串  分割回文串"></a>(LC131)  分割回文串  <a href="https://leetcode-cn.com/problems/palindrome-partitioning/description/">分割回文串</a></h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串 。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "aab"</span><br><span class="line">输出：[["a","a","b"],["aa","b"]]</span><br></pre></td></tr></tbody></table></figure><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-18"><a href="#Python3-Code-18" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ispalindrome</span>(<span class="params">word,left,right</span>):</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> word[left] !=  word[right]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start,path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="built_in">len</span>(s):</span><br><span class="line">                res.append(path[:]) </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> ispalindrome(s, start,i):</span><br><span class="line">                    print(s[start:i+<span class="number">1</span>])</span><br><span class="line">                    path.append(s[start:i+<span class="number">1</span>])</span><br><span class="line">                    backtrack(i+<span class="number">1</span>, path)</span><br><span class="line">                    path.pop()</span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-18"><a href="#复杂度分析-18" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-18"><a href="#大佬题解-18" class="headerlink" title="大佬题解"></a>大佬题解</h4><ol><li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-fa-si-lu-yu-mo-ban-by-fuxuemingzh-azhz/">复制和不复制path</a></li></ol><h3 id="LC-1"><a href="#LC-1" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-19"><a href="#Python3-Code-19" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-19"><a href="#复杂度分析-19" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-19"><a href="#大佬题解-19" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-2"><a href="#LC-2" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-20"><a href="#Python3-Code-20" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-20"><a href="#复杂度分析-20" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-20"><a href="#大佬题解-20" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-3"><a href="#LC-3" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-21"><a href="#Python3-Code-21" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-21"><a href="#复杂度分析-21" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-21"><a href="#大佬题解-21" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-4"><a href="#LC-4" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-22"><a href="#Python3-Code-22" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-22"><a href="#复杂度分析-22" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-22"><a href="#大佬题解-22" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;搜索（BFS-DFS-Backtracking）&quot;&gt;&lt;a href=&quot;#搜索（BFS-DFS-Backtracking）&quot; class=&quot;headerlink&quot; title=&quot;搜索（BFS, DFS, Backtracking）&quot;&gt;&lt;/a&gt;搜索（BFS, DFS, Backtracking）&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;广度优先算法（Breadth-First-Search），简称BFS。深度优先算法（Deep-First-Search），简称DFS。BFS:利用队列先进先出的特性，可以优先遍历横向节点。DFS:利用栈先进后出的特性，可以优先遍历纵向节点。&lt;/p&gt;
&lt;h2 id=&quot;搜索&quot;&gt;&lt;a href=&quot;#搜索&quot; class=&quot;headerlink&quot; title=&quot;搜索&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md&quot;&gt;搜索&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;深度优先搜索和广度优先搜索广泛应用于树和图中。 （1） BFS  (2) DFS  (3) Backtracking&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣算法" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode竞赛(第234场周赛)</title>
    <link href="http://watermelondrip.github.io/2021/03/28/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B234/"/>
    <id>http://watermelondrip.github.io/2021/03/28/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B234/</id>
    <published>2021-03-27T13:00:00.000Z</published>
    <updated>2021-04-01T10:31:26.617Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>排名：  2809 / 4996<br><span id="more"></span></p><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>(5713)[<a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/)https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/)https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/</a>]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 word ，该字符串由数字和小写英文字母组成。</p><p>请你用空格替换每个不是数字的字符。例如，”a123bc34d8ef34” 将会变成 “ 123  34 8  34” 。注意，剩下的这些整数间至少要用一个空格隔开：”123”、”34”、”8” 和 “34” 。</p><p>返回对 word 完成替换后形成的 不同 整数的数目。</p><p>如果两个整数的 不含前导零 的十进制表示不同，则认为这两个整数也不同。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "a123bc34d8ef34"</span><br><span class="line">输出：3</span><br><span class="line">解释：不同的整数有 "123"、"34" 和 "8" 。注意，"34" 只计数一次。</span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDifferentIntegers</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> ch.isdigit():</span><br><span class="line">                arr.append(ch)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr.append(<span class="string">' '</span>)</span><br><span class="line">        s = <span class="string">''</span>.join(arr)</span><br><span class="line">        arr = s.split(<span class="string">' '</span>)</span><br><span class="line">        ss = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(num) &gt; <span class="number">0</span>:</span><br><span class="line">                ss.add(<span class="built_in">int</span>(num))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(ss)</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="2-题目"><a href="#2-题目" class="headerlink" title="2. 题目"></a>2. 题目</h1><p>(5715. 还原排列的最少操作步数)[<a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/</a>]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 0 开始 计数）。</p><p>一步操作中，你将创建一个新数组 arr ，对于每个 i ：</p><p>如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]<br>如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]<br>然后将 arr​​ 赋值​​给 perm 。</p><p>要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：最初，perm = [0,1]</span><br><span class="line">第 1 步操作后，perm = [0,1]</span><br><span class="line">所以，仅需执行 1 步操作</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reinitializePermutation</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        perm = [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        org =  [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line">        </span><br><span class="line">        arr = [<span class="number">0</span>]*n</span><br><span class="line">        <span class="keyword">while</span> arr != org:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    arr[i] = perm[<span class="built_in">int</span>(i //<span class="number">2</span>)]</span><br><span class="line">                  </span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    arr[i] = perm[<span class="built_in">int</span>(n // <span class="number">2</span>) + <span class="built_in">int</span>((i - <span class="number">1</span>) // <span class="number">2</span>)]</span><br><span class="line">                    </span><br><span class="line">            result+=<span class="number">1</span></span><br><span class="line">            perm = arr[:]</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="3-题目"><a href="#3-题目" class="headerlink" title="3. 题目"></a>3. 题目</h1><p>(5714. 替换字符串中的括号内容)[<a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/</a>]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。</p><p>比方说，字符串 “(name)is(age)yearsold” 中，有 两个 括号对，分别包含键 “name” 和 “age” 。<br>你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。</p><p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p><p>将 keyi 和括号用对应的值 valuei 替换。<br>如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 “?” 替换（不需要引号）。<br>knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。</p><p>请你返回替换 所有 括号对后的结果字符串。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "(name)is(age)yearsold", knowledge = [["name","bob"],["age","two"]]</span><br><span class="line">输出："bobistwoyearsold"</span><br><span class="line">解释：</span><br><span class="line">键 "name" 对应的值为 "bob" ，所以将 "(name)" 替换为 "bob" 。</span><br><span class="line">键 "age" 对应的值为 "two" ，所以将 "(age)" 替换为 "two" 。 </span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>字典存储记住呀 （<code>d = {k: v for k, v in knowledge}</code>）</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">self, s: <span class="built_in">str</span>, knowledge: List[List[<span class="built_in">str</span>]]</span>) -&gt; str:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">1</span></span><br><span class="line">        d = {k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> knowledge}</span><br><span class="line">        result = <span class="built_in">str</span>()</span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                left = i</span><br><span class="line">                a = <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                right = i</span><br><span class="line">                key_know = s[left+<span class="number">1</span>:right]</span><br><span class="line">                </span><br><span class="line">                find = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> key_know <span class="keyword">in</span> d:</span><br><span class="line">                    result+=d[key_know]</span><br><span class="line">                    find = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> find == <span class="number">0</span>:</span><br><span class="line">                    result+=<span class="string">'?'</span></span><br><span class="line">                a = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">                    result+= s[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="4-题目"><a href="#4-题目" class="headerlink" title="4. 题目"></a>4. 题目</h1><p>(5716. 好因子的最大数目)[<a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/</a>]</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数 primeFactors 。你需要构造一个正整数 n ，它满足以下条件：</p><p>n 质因数（质因数需要考虑重复的情况）的数目 不超过 primeFactors 个。<br>n 好因子的数目最大化。如果 n 的一个因子可以被 n 的每一个质因数整除，我们称这个因子是 好因子 。比方说，如果 n = 12 ，那么它的质因数为 [2,2,3] ，那么 6 和 12 是好因子，但 3 和 4 不是。<br>请你返回 n 的好因子的数目。由于答案可能会很大，请返回答案对 109 + 7 取余 的结果。</p><p>请注意，一个质数的定义是大于 1 ，且不能被分解为两个小于该数的自然数相乘。一个数 n 的质因子是将 n 分解为若干个质因子，且它们的乘积为 n </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：primeFactors = 5</span><br><span class="line">输出：6</span><br><span class="line">解释：200 是一个可行的 n 。</span><br><span class="line">它有 5 个质因子：[2,2,2,5,5] ，且有 6 个好因子：[10,20,40,50,100,200] 。</span><br><span class="line">不存在别的 n 有至多 5 个质因子，且同时有更多的好因子。 </span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p>以下数学推导总体分为两步：（1) 当所有拆分出的数字相等时，乘积最大。(2)最优拆分数字为3。<a href="https://leetcode-cn.com/problems/integer-break/solution/343-zheng-shu-chai-fen-tan-xin-by-jyd/">戳一戳</a></p></li><li><p>拆分规则：<br>最优： 3。把数字 n 可能拆为多个因子 3 ，余数可能为0,1,2 三种情况。<br>次优： 2。若余数为 2 ；则保留，不再拆为 1+1 。<br>最差： 1 。若余数为 1 ；则应把一份 3+1 替换为2+2，因为 2 <em>2 &gt; 3 </em>1 </p></li><li><p>数学模型<br>已知:</p></li></ul><p>a1, a2, a3, …… an 是质数<br>a1^b1 + a2^b2 + …… + an^bn = sum;<br>b1 + b2 + …… + bn = n; 其中n已知<br>求：</p><p>好因子个数，比如有 3 个 2， 2 个 5，那么好因子个数就相当于在 3个2 里取出3种情况(1个2， 2个2， 3个2)，在 2个5 里取出2种情况(1个5，2个5)，相乘即可，即好因子个数 = 3 <em> 2 = 6<br>上面这种算法其实就是 好因子个数 = b1 </em> b2 <em> …… </em> bn 的最大值<br>那么求好因子个数的最大值就是求：</p><p>已知 b1 + b2 + …… + bn = n<br>求 b1 <em> b2 </em> …… * bn 的最大值</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNiceDivisors</span>(<span class="params">self, primeFactors: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> primeFactors &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> primeFactors </span><br><span class="line"></span><br><span class="line">        a,b = primeFactors//<span class="number">3</span>, primeFactors%<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>: </span><br><span class="line">            result = <span class="built_in">pow</span>(<span class="number">3</span>,a,<span class="number">1000000007</span>) </span><br><span class="line">        <span class="keyword">elif</span> b ==<span class="number">1</span>:</span><br><span class="line">            result = (<span class="built_in">pow</span>(<span class="number">3</span>,a-<span class="number">1</span>,<span class="number">1000000007</span>)*<span class="number">4</span>)   </span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">2</span>:</span><br><span class="line">            result =  (<span class="built_in">pow</span>(<span class="number">3</span>,a,<span class="number">1000000007</span>)*<span class="number">2</span>)  </span><br><span class="line">        <span class="keyword">return</span> result%<span class="number">1000000007</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O( )$  </li><li>空间复杂度：$O( )$  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;排名：  2809 / 4996&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="力扣周赛" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="http://watermelondrip.github.io/2021/03/21/%E5%A0%86heapq%E6%A8%A1%E5%9D%97/"/>
    <id>http://watermelondrip.github.io/2021/03/21/%E5%A0%86heapq%E6%A8%A1%E5%9D%97/</id>
    <published>2021-03-20T22:47:00.000Z</published>
    <updated>2021-04-07T07:48:00.862Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个模块提供了堆队列算法的实现，也成为优先队列算法。<br>堆是一个二叉树，它的每个父节点的值都只会小于或等于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的<code>k</code>，都有<code>heap[k] &lt;= heap[2*k+1]</code>和<code>heap[k] &lt;= heap[2*k+2]</code>。为了便于笔记，不存在的元素被认为是无限大。堆最有趣的特性在于最小的元素总是在根结点：heap[0]。</p><p>这个API与教材的对算法实现有所不同，具体区别有两方面：（a）我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为Python使用从零开始的索引。（b) 我们的pop方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。<br>基于这两个方面，把堆看作原生的Python List也没有什么奇怪的：<code>heap[0]</code>表示最小的元素，同时<code>heap.sort()</code>维护了堆的不变性。<br>要创造一个堆，可以使用list来初始化为<code>[]</code>，或者你也可以通过一个函数<code>heapify()</code>，来把一个list转换成堆。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="heapq-headpush-heap-item"><a href="#heapq-headpush-heap-item" class="headerlink" title="heapq.headpush(heap,item)"></a>heapq.headpush(heap,item)</h2><p>将<code>item</code>的值加入<code>heap</code>中，保持堆的不变性。</p><h2 id="heapq-headpop-heap"><a href="#heapq-headpop-heap" class="headerlink" title="heapq.headpop(heap)"></a>heapq.headpop(heap)</h2><p>弹出并返回<code>heap</code>的最小的元素，保持堆的不变性。如果堆为空，抛出<code>IndexError</code>。使用<code>heap[0]</code>，可以只访问最小的元素而不弹出它。</p><h2 id="heapq-headpop-heap-item"><a href="#heapq-headpop-heap-item" class="headerlink" title="heapq.headpop(heap,item)"></a>heapq.headpop(heap,item)</h2><p>将<code>item</code>放入堆中，然后弹出并返回<code>heap</code>的最小元素。该组合操作比先调用<code>heappush()</code>再调用<code>heappop()</code>运行起来更有效率。</p><h2 id="heapq-heapify-x"><a href="#heapq-heapify-x" class="headerlink" title="heapq.heapify(x)"></a>heapq.heapify(x)</h2><p>将list <code>x</code>转换成堆，原地，线性时间内。</p><h2 id="heapq-heapreplace-heap-item"><a href="#heapq-heapreplace-heap-item" class="headerlink" title="heapq.heapreplace(heap,item)"></a>heapq.heapreplace(heap,item)</h2><p>弹出并返回<code>heap</code>中最小的一项，同时推入新的<code>item</code>。堆的大小不变。如果堆为空则引发<code>IndexError</code>。这个单步骤操作比<code>heappop()</code>加<code>heappush()</code>更高效，并且在使用固定大小的堆时更为适宜。 <code>pop</code>/<code>push</code> 组合总是会从堆中返回一个元素并将其替换为 <code>item</code>。<br>返回的值可能会比添加的 item 更大。 如果不希望如此，可考虑改用 <code>heappushpop()</code>。 它的 <code>push/pop</code> 组合会返回两个值中较小的一个，将较大的值留在堆中。</p><h1 id="创建堆"><a href="#创建堆" class="headerlink" title="创建堆"></a>创建堆</h1><ul><li>heapq有两种方式创建堆，一种是使用一个空列表，然后使用<code>heapq.heappush()</code>函数把值加入堆中，另外一种就是使用<code>heap.heapify(list)</code>转换列表成为堆结构。</li></ul><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数定义：</span></span><br><span class="line"><span class="string">heapq.heappush(heap,item)</span></span><br><span class="line"><span class="string">    - push the value item onto the heap, maintaining the heap invariant</span></span><br><span class="line"><span class="string">heapq.heappop(heap)</span></span><br><span class="line"><span class="string">    - pop and return the smallest item from the heap, maintaining the heap invariant</span></span><br><span class="line"><span class="string">    If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    heapq.heappush(heap,num) <span class="comment">#加入堆</span></span><br><span class="line"></span><br><span class="line">print(heap[<span class="number">0</span>])  <span class="comment"># 如果只是想获取最小值而不是弹出，使用heap[0]</span></span><br><span class="line">print([heapq.heappop(heap) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))])  <span class="comment"># 堆排序结果</span></span><br><span class="line"><span class="comment"># out: [1, 2, 3, 5, 23, 54, 132]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line">print([heapq.heappop(nums) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))])  <span class="comment"># 堆排序结果</span></span><br><span class="line"><span class="comment"># out: [1, 2, 3, 5, 23, 54, 132]</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>heapq</code> 模块还有一个<code>heapq.merge(*iterables)</code> 方法，用于合并多个排序后的序列成一个排序后的序列， 返回排序后的值的迭代器。类似于<code>sorted(itertools.chain(*iterables))</code>，但返回的是可迭代的。</li></ul><h2 id="基本示例-1"><a href="#基本示例-1" class="headerlink" title="基本示例"></a>基本示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数定义：</span></span><br><span class="line"><span class="string">heapq.merge(*iterables)</span></span><br><span class="line"><span class="string">    - Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values.</span></span><br><span class="line"><span class="string">    - Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest).</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">num1 = [<span class="number">32</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">num2 = [<span class="number">23</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">656</span>, <span class="number">324</span>, <span class="number">23</span>, <span class="number">54</span>]</span><br><span class="line">num1 = <span class="built_in">sorted</span>(num1)</span><br><span class="line">num2 = <span class="built_in">sorted</span>(num2)</span><br><span class="line"></span><br><span class="line">res = heapq.merge(num1, num2)</span><br><span class="line">print(<span class="built_in">list</span>(res))</span><br></pre></td></tr></tbody></table></figure><h1 id="访问堆内容"><a href="#访问堆内容" class="headerlink" title="访问堆内容"></a>访问堆内容</h1><ul><li>堆创建好后，可以通过<code>heapq.heappop()</code> 函数弹出堆中最小值。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">43</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">12</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line"></span><br><span class="line">print(heapq.heappop(nums))</span><br><span class="line"><span class="comment"># out: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要所有堆排序后的元素</span></span><br><span class="line">result = [heapq.heappop(nums) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># out: [12, 23, 43, 45]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要删除堆中最小元素并加入一个元素，可以使用<code>heapq.heaprepalce()</code> 函数</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line">heapq.heapreplace(nums, <span class="number">23</span>)</span><br><span class="line">print([heapq.heappop(nums) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))])</span><br><span class="line"><span class="comment"># out: [2, 3, 4, 5, 23]</span></span><br></pre></td></tr></tbody></table></figure><h1 id="获取堆最大或最小值"><a href="#获取堆最大或最小值" class="headerlink" title="获取堆最大或最小值"></a>获取堆最大或最小值</h1><ul><li>如果需要获取堆中最大或最小的范围值，则可以使用<code>heapq.nlargest()</code> 或<code>heapq.nsmallest()</code> 函数</li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数定义：</span></span><br><span class="line"><span class="string">heapq.nlargest(n, iterable[, key])¶</span></span><br><span class="line"><span class="string">    - Return a list with the n largest elements from the dataset defined by iterable. </span></span><br><span class="line"><span class="string">    - key if provided, specifies a function of one argument that is used to extract a comparison key from each element in the iterable: key=str.lower</span></span><br><span class="line"><span class="string">    - Equivalent to: sorted(iterable, key=key, reverse=True)[:n]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums))</span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">[5, 4, 3]</span></span><br><span class="line"><span class="string">[1, 2, 3]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure><ul><li>这两个函数还接受一个key参数，用于dict或其他数据结构类型使用</li></ul><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import heapq</span><br><span class="line">from pprint import pprint #美化打印 </span><br><span class="line">portfolio = [</span><br><span class="line">    {'name': 'IBM', 'shares': 100, 'price': 91.1},</span><br><span class="line">    {'name': 'AAPL', 'shares': 50, 'price': 543.22},</span><br><span class="line">    {'name': 'FB', 'shares': 200, 'price': 21.09},</span><br><span class="line">    {'name': 'HPQ', 'shares': 35, 'price': 31.75},</span><br><span class="line">    {'name': 'YHOO', 'shares': 45, 'price': 16.35},</span><br><span class="line">    {'name': 'ACME', 'shares': 75, 'price': 115.65}</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])</span><br><span class="line">expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])</span><br><span class="line">pprint(cheap)</span><br><span class="line">pprint(expensive)</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">输出：</span><br><span class="line">[{'name': 'YHOO', 'price': 16.35, 'shares': 45},</span><br><span class="line"> {'name': 'FB', 'price': 21.09, 'shares': 200},</span><br><span class="line"> {'name': 'HPQ', 'price': 31.75, 'shares': 35}]</span><br><span class="line">[{'name': 'AAPL', 'price': 543.22, 'shares': 50},</span><br><span class="line"> {'name': 'ACME', 'price': 115.65, 'shares': 75},</span><br><span class="line"> {'name': 'IBM', 'price': 91.1, 'shares': 100}]</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><h1 id="heapq-应用"><a href="#heapq-应用" class="headerlink" title="heapq 应用"></a>heapq 应用</h1><ul><li>实现heap堆排序算法, 该算法和sorted(iterable) 类似，但是它是不稳定的。</li></ul><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">iterable</span>):</span></span><br><span class="line"><span class="meta">... </span>    h = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line"><span class="meta">... </span>        heappush(h, value)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(h))]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapsort([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>])</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>堆的值可以是元组类型，可以实现对带权值的元素进行排序。</li></ul><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">5</span>, <span class="string">'write code'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">7</span>, <span class="string">'release product'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">1</span>, <span class="string">'write spec'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">3</span>, <span class="string">'create tests'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappop(h)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'write spec'</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">主要介绍堆heapq模块</summary>
    
    
    
    <category term="Python" scheme="http://watermelondrip.github.io/categories/Python/"/>
    
    <category term="Python数据类型" scheme="http://watermelondrip.github.io/categories/Python/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
</feed>
