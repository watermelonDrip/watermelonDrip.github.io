<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MAXの瓜园</title>
  
  
  <link href="http://watermelondrip.github.io/atom.xml" rel="self"/>
  
  <link href="http://watermelondrip.github.io/"/>
  <updated>2021-03-13T03:04:26.875Z</updated>
  <id>http://watermelondrip.github.io/</id>
  
  <author>
    <name>Max</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分查找</title>
    <link href="http://watermelondrip.github.io/2021/03/13/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://watermelondrip.github.io/2021/03/13/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2021-03-13T03:04:26.874Z</published>
    <updated>2021-03-13T03:04:26.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找二分查找"><a href="#二分查找二分查找" class="headerlink" title="二分查找二分查找"></a>二分查找<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md#leetcode-%E9%A2%98%E8%A7%A3---%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></h2><p>二分查找也称为折半查找，每次都能查找区间减半，这种折半特性的算法时间复杂度为O(logN)。</p><span id="more"></span><p>##1. (LC69) x 的平方根 <a href="https://leetcode-cn.com/problems/sqrtx/description/">x 的平方根</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现&nbsp;int sqrt(int x)&nbsp;函数。 计算并返回&nbsp;x&nbsp;的平方根，其中&nbsp;x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li> 二分查找</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = x</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid  = (l+r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mid**<span class="number">2</span> &gt; x:</span><br><span class="line">                r = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mid**<span class="number">2</span> &lt; x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p>##2. (LC69) 寻找比目标字母大的最小字母 <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/">寻找比目标字母大的最小字母</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母&nbsp;target，请你寻找在这一有序列表里比目标字母大的最小字母。在比较时，字母是依序循环出现的。<br>举个例子：<br>如果目标字母 target = ‘z’ 并且字符列表为&nbsp;letters = [‘a’, ‘b’]，则答案返回&nbsp;‘a’</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">letters = ["c", "f", "j"]</span><br><span class="line">target = "a"</span><br><span class="line">输出: "c"</span><br></pre></td></tr></tbody></table></figure><h2 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li> 二分查找</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: List[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        num_letters =[]</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> letters:</span><br><span class="line">            num_letters.append(<span class="built_in">ord</span>(ch))</span><br><span class="line">        num_target = <span class="built_in">ord</span>(target)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(num_letters)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (r+l)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mid &gt; num_target:</span><br><span class="line">                ans = mid</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mid &lt; num_target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> letters[ans]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p>##3. (LC278) 第一个错误的版本 <a href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用&nbsp;bool isBadVersion(version)&nbsp;接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5)&nbsp;-&gt; true</span><br><span class="line">调用 isBadVersion(4)&nbsp;-&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></tbody></table></figure><h2 id="前置知识-2"><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li> 二分查找</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (r+l)&gt;&gt;<span class="number">1</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isBadVersion(mid):</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;二分查找二分查找&quot;&gt;&lt;a href=&quot;#二分查找二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md#leetcode-%E9%A2%98%E8%A7%A3---%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE&quot;&gt;二分查找&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;二分查找也称为折半查找，每次都能查找区间减半，这种折半特性的算法时间复杂度为O(logN)。&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://watermelondrip.github.io/2021/03/08/%E8%B4%AA%E5%BF%83/"/>
    <id>http://watermelondrip.github.io/2021/03/08/%E8%B4%AA%E5%BF%83/</id>
    <published>2021-03-08T01:19:11.454Z</published>
    <updated>2021-03-09T12:50:29.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md">贪心</a></h2><p>思路是：(1) 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的 (2)贪心算法一般是先需要排序的。</p><span id="more"></span><p><strong>目录 (Table of Contents)</strong></p><!-- toc --><p>[TOC]</p><p>##1. (LC455) 分发饼干 <a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>对每个孩子 i，都有一个胃口值&nbsp;g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]&nbsp;。如果 s[j]&nbsp;&gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></tbody></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序+贪心：我觉得这个也很好想，因为我们要求分配给最多的小孩的数量，肯定是可着吃的少的孩子先来。因为一个大胖子吃10斤的，可以给10个吃一斤的孩子啊。</li></ol><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: List[<span class="built_in">int</span>], s: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(g) <span class="comment">#greed factor</span></span><br><span class="line">        m = <span class="built_in">len</span>(s) <span class="comment">#size</span></span><br><span class="line">        i = <span class="number">0</span> </span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;m <span class="keyword">and</span> i&lt;n:</span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> g[i]&gt;s[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; m:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></tbody></table></figure><p>####复杂度分析</p><ul><li>时间复杂度： $O( m log m + n logn)$ 其中m和n分别是数组g和s的长度。对两个数组排序的时间复杂度是 $O(mlogm+nlogn)$，遍历数组的时间复杂度是$O(m+n)$。</li><li>空间复杂度：$O(log m + log n)$ 其中m和n分别是数组g和s的长度。主要是排序的额外空间开销。</li></ul><p>##2. (LC435) 无重叠区间 <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a></p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></tbody></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>排序+贪心：这个题还是排序+贪心。为什么这么说呢，首先区间边界没有相互重叠，和第一题的分饼干相似。这种类型的题的思路是，每一步都选的很小心，生怕影响后面的人。</li></ol><h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        points = <span class="built_in">sorted</span>(points,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        print(points)</span><br><span class="line">        right = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt;right:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">                right = points[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p>####复杂度分析</p><ul><li>时间复杂度： $O(n logn)$ 其中n是数组的长度。 </li><li>空间复杂度：$O(log n)$  </li></ul><p>##3. (LC406) 根据身高重建队列 <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">根据身高重建队列</a></p><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。<br>请你重新构造并返回输入数组&nbsp;people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></tbody></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>排序+贪心： </li></ol><h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x:(-x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(people) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> people</span><br><span class="line">        <span class="comment">## 对队列排序，先按h降序，再按k升序</span></span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        new_people = [people[<span class="number">0</span>]]    <span class="comment"># 这个人是从前往后、从上往下看到的第一个人</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> people[<span class="number">1</span>:]:</span><br><span class="line">            new_people.insert(i[<span class="number">1</span>], i)</span><br><span class="line">        <span class="keyword">return</span> new_people</span><br></pre></td></tr></tbody></table></figure><p>####复杂度分析</p><ul><li>时间复杂度： $O( )$   </li><li>空间复杂度：$O( )$  </li></ul><p>##4. (LC763) 划分字母区间 <a href="https://leetcode-cn.com/problems/partition-labels/">划分字母区间</a></p><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：S = "ababcbacadefegdehijhklij"</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 "ababcbaca", "defegde", "hijhklij"。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></tbody></table></figure><p>###知识点</p><ul><li>Python中S为string，S.rindex(a)返回字母a最后一次出现的位置。<br>比如，S = “ABCAAGD”, S.rindex(“A”) = 4.</li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, S</span>):</span>  <span class="comment">#大佬解题</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化返回结果和初始定位</span></span><br><span class="line">        rv = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 两种特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(S) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(S) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> idx &lt;= <span class="built_in">len</span>(S)-<span class="number">1</span>:   <span class="comment"># 当位置指针未到最后一位时</span></span><br><span class="line">            end_idx = S.rindex(S[idx]) <span class="comment"># 末尾指针为位置指针处字母最后一次出现的位置</span></span><br><span class="line">            unique = <span class="built_in">list</span>(<span class="built_in">set</span>(S[idx:end_idx]))  <span class="comment"># 寻找此区间内所有unique字母</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> unique:    <span class="comment"># 遍历所有unique字符</span></span><br><span class="line">                <span class="keyword">if</span> S.rindex(u) &gt; end_idx:  <span class="comment"># 如果该字符最后一次出现超过了末尾指针</span></span><br><span class="line">                    unique += <span class="built_in">list</span>(<span class="built_in">set</span>(S[end_idx:S.rindex(u)]))  <span class="comment"># 在unique中添加新区间的unique字符</span></span><br><span class="line">                    end_idx = S.rindex(u)       <span class="comment"># 迭代末尾指针</span></span><br><span class="line"></span><br><span class="line">            rv.append(end_idx - idx + <span class="number">1</span>)        <span class="comment"># 全部unique遍历完成后，添加长度</span></span><br><span class="line">            idx = end_idx + <span class="number">1</span>                   <span class="comment"># 新的位置指针为上次末尾指针+1</span></span><br><span class="line">        <span class="keyword">return</span> rv </span><br></pre></td></tr></tbody></table></figure><p>####复杂度分析</p><ul><li>时间复杂度： </li><li>空间复杂度： </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;贪心&quot;&gt;&lt;a href=&quot;#贪心&quot; class=&quot;headerlink&quot; title=&quot;贪心&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md&quot;&gt;贪心&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;思路是：(1) 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的 (2)贪心算法一般是先需要排序的。&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="排序" scheme="http://watermelondrip.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆" scheme="http://watermelondrip.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode竞赛(第231场周赛)</title>
    <link href="http://watermelondrip.github.io/2021/03/07/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B231/"/>
    <id>http://watermelondrip.github.io/2021/03/07/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B231/</id>
    <published>2021-03-07T07:35:12.750Z</published>
    <updated>2021-03-07T07:48:34.317Z</updated>
    
    <content type="html"><![CDATA[<p>就做出来第一题和第二题<br> <span id="more"></span></p><h1><span id="1-题目">1. 题目</span></h1><p>(5697.检查二进制字符串字段)[<a href="https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/]">https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/]</a></p><h2><span id="题目描述">题目描述</span></h2><p>给你一个二进制字符串 s ，该字符串不含前导零 。</p><p>如果 s 最多包含 一个由连续的 ‘1’ 组成的字段 ，返回 true​​​ 。否则，返回 false 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1001&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：字符串中的 1 没有形成一个连续字段。</span><br></pre></td></tr></table></figure><h2><span id="思路">思路</span></h2><ol><li>出现01字符串就输出错误</li><li>如果一直为0，则可以</li></ol><h2><span id="反省">反省</span></h2><ol><li><p>这次这个题真不难，但是看题的时候没看明白题。 本题的意思是只要有一个1就算是连续字段，比如“10011”, 输出也是false。 因为第一个数字1就已经算是一个由1组成的字符串了，后面的11是第二个连续1的字段了。</p></li><li><p>map()函数完全可以不用啊，但是既然用了，还不熟知识点那块还是记录一下吧。</p><h2><span id="知识点">知识点</span></h2></li><li><p>map函数的原型是map(function,iterable,…)，它的返回结果是一个列表。 参数function传的是一个函数名，可以是python内置的，也可以是自定义的。参数iterable传的是一个可以迭代的对象，例如列表，元组，字符串。  这个函数的意思是将function应用于iterable的每一个元素，结果以列表的形式返回。 注意到后面，iterable后面有省略号，意思是可以传很多个iterable，如果有额外的iterable参数，并行的从这些参数中取出元素，并调用function。如果一个iterable 参数比另外的iterable参数要短，将以None扩展参数元素</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">c=<span class="string">&quot;zhangkang&quot;</span></span><br><span class="line"></span><br><span class="line">la=<span class="built_in">map</span>(<span class="built_in">str</span>,a)</span><br><span class="line">lb=<span class="built_in">map</span>(<span class="built_in">str</span>,b)</span><br><span class="line">lc=<span class="built_in">map</span>(<span class="built_in">str</span>,c)</span><br><span class="line"></span><br><span class="line">print(la)</span><br><span class="line">print(lb)</span><br><span class="line">print(lc)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>] </span><br></pre></td></tr></table></figure><p>str()是Python的内置函数，这个例子是把列表/元组/字符串的每个元素变成了str 类型，然后以列表的形式返回。当然我们也可以传入自定义的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">n=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">res=<span class="built_in">map</span>(mul,n)</span><br><span class="line">输出：[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>] </span><br></pre></td></tr></table></figure><p>把列表n中的每个元素运行一次mul函数后得到的结果作为最终结果列表的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list3=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">res=<span class="built_in">map</span>(add,list1,list2,list3)</span><br><span class="line">print(res)</span><br><span class="line">输出：[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>] </span><br></pre></td></tr></table></figure><p>并行的从三个列表中各自取出元素然后运行add函数，有人可能会问，如果三个列表长度不一样怎么办，前面已经说了，对于短的那个iterable参数会用None填补。对于上面的例子，如果list3=[1,2]的话，那么这个程序会报错，因为虽然在运行add函数的时候列表list3的最后一个元素会用None填补，但是None和int类型的数是不能相加的。也就是说，除非参数function支持None的运算，否则根本没意义。现在我们看下另一个例子你就明白了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x,y,z</span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">list3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">res = <span class="built_in">map</span>(add, list1, list2, list3)</span><br><span class="line">print(res)</span><br><span class="line">输出：</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="literal">None</span>, <span class="number">4</span>, <span class="number">4</span>), (<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h2><span id="代码">代码</span></h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOnesSegment</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span>  <span class="comment">#大佬解题</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s.count(<span class="string">&#x27;01&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOnesSegment</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span>  <span class="comment"># 本菜</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        s= <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,s))   <span class="comment">#不用map这行      </span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[r] == s[<span class="number">0</span>] <span class="keyword">and</span> r == <span class="number">1</span>:  <span class="comment"># s[r] == &#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> r&lt;n <span class="keyword">and</span> s[r] == s[<span class="number">0</span>]:</span><br><span class="line">                    r+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[r]!= s[<span class="number">0</span>]:</span><br><span class="line">                r+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h1><span id="2-题目">2. 题目</span></h1><p>(5698.构成特定和需要添加的最少元素)[<a href="https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum/]">https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum/]</a></p><h2><span id="题目描述">题目描述</span></h2><p>给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。<br>返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。<br>注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,-1,1], limit &#x3D; 3, goal &#x3D; -4</span><br><span class="line">输出：2</span><br><span class="line">解释：可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 &#x3D; -4 。</span><br></pre></td></tr></table></figure><h2><span id="知识点">知识点</span></h2><ol><li><p>除法：</p><ul><li>传统除法：如果是整数除法则执行地板除，如果是浮点除法则执行精确除法<br><code>&gt;&gt;&gt;1/2   &gt;&gt;&gt;0   &gt;&gt;&gt;1.0/2.0 &gt;&gt;&gt;0.5</code></li><li>地板除法：//除法不管操作数为何种数值类型，总是会舍去小数部分，返回数字序列中比真正的商小的最接近的数字<br>`&gt;&gt;&gt;1//2  &gt;&gt;&gt;0   &gt;&gt;&gt;-1//2  &gt;&gt;&gt;-‘</li></ul></li><li><p>ceil,floor,round</p><ul><li>ceil() 将小数部分一律向整数部分进位，函数返回数字的上入整数 ‘ceil(-45.17): -45’</li><li>floor() 一律舍去，仅保留整数</li><li>round() 四舍五入</li></ul></li></ol><h2><span id="关键点">关键点</span></h2><ul><li>小学数学，反正这类的题要先手写几个例子 </li></ul><h2><span id="代码">代码</span></h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minElements</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], limit: <span class="built_in">int</span>, goal: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> ceil(<span class="built_in">abs</span>(goal - <span class="built_in">sum</span>(nums)) / limit)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;就做出来第一题和第二题&lt;br&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="竞赛" scheme="http://watermelondrip.github.io/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>声学信号处理系列（一）--声学信号处理基础知识</title>
    <link href="http://watermelondrip.github.io/2021/03/07/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%970_%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <id>http://watermelondrip.github.io/2021/03/07/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%970_%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-06T22:35:00.000Z</published>
    <updated>2021-03-07T09:46:24.456Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="声学信号处理系列一声学信号处理基础知识">声学信号处理系列（一）–声学信号处理基础知识</span></h1><p><em>by max</em></p><p><em>2021/03/07</em></p><h2><span id="0写在开始的话">0.写在开始的话</span></h2><p>这个博客系列里，会介绍一些声学信号处理领域相关的基础性知识，以及工业界学术界主流的一些算法应用方向。主要会关注与本人工作相关的一些细分领域，例如：语音增强、声纹识别、麦克风阵列、声学场景识别以及声纹识别反欺骗等诸多方向。随着系列博客文章的积累，会逐渐关注并提供更多应用领域的介绍。本系列旨在记录平时工作中学习到的新知识，也希望能跟别人分享自己的一些心得体会。个人水平有限，如有疏漏错误，敬请批评指正，谢谢！</p><span id="more"></span><h2><span id="1声学基础">1.声学基础</span></h2><p>声音是自然界中非常常见的一种信号之一，我们平时的生活中声音无处不在。人类可以通过声音，来对物体进行感知、辨认和定位。同样，声音也是日常我们互相交流时用于传递信息文字的“载具”。</p><p>初高中物理课上大家应该都学到过，声音的本质是物体振动生成的声波，该声波通过某种介质（例如空气、水和固体）传播并能被人类或者动物的听觉器官所感知。声音的频率一般会以赫兹表示，记为Hz，指每秒钟周期性震动的次数。而分贝是用来表示声音强度的单位，记为dB[1]。</p><h2><span id="2我们如何发出声音">2.我们如何发出声音</span></h2><p>正如上一小节中所介绍的，发出声音需要凭借物体的振动。那么我们人类从口腔中发出各种各样的声音，也正是依靠我们的声带的振动来实现的。具体说来，从我们肺部内排出的气体气流，在经过形态变化的声带结构时，带动声带产生振动，进而生成了声波，声波经过我们的口腔和嘴，传输到外界空气中。在整个过程里，由于每个人类个体的声带器官、口腔腔体和嘴部的生理结构都是各异的，所以也导致我们每个人说出来的话的语音语调，以及包括音色，都是不同的。需要注意的是，由于鼻腔和口腔在人体内部是连通的，也会参与到发声过程中来。</p><p>下图是一个口腔内部的各个器官的展示，体内从肺部出来的气流，经气管-&gt;声带-&gt;咽喉-&gt;口鼻，传出体外。</p><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3541145379,2023942298&fm=15&gp=0.jpg" alt="avatar"></p><h2><span id="3一些基本的专业词汇2">3.一些基本的专业词汇[2]</span></h2><ul><li>音节（Syllable）：说话时一次发出的，具有一个响亮的中心，并被明显感觉到的语音片段。</li><li>音素（Phoneme）：语音发音的最小单位。一个音节可以由一个或多个音素构成。音素可分为元音和辅音两种。</li><li>元音（Vowel）：当声带振动发出的声音气流从咽喉进入口腔并从嘴部唇部出去时，这些声腔完全开放，气流可以顺利通过时所发的音，称为元音。元音构成音节的主干，无论从长度或是能量角度考虑，元音在音节中都占主要部分。决定元音音色的主要因素是舌头的形状及其在口腔中的位置，以及嘴唇的形状等。口腔中当舌头处于不同的舌位高度和舌位前后时，可以发出不同的音素。下图是一个单元音发音舌位示意图：<br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20191123%2Fd414717d0c8647dc979a0f0557cd82d2.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1617682279&t=03c62b6e9c10720fcd1a12f2abdfa02c" alt="avatar"></li><li>辅音（Consonant）：当呼出的气流，由于整个声腔通路上某一部分封闭起来或受到阻碍，气流传播不通畅，而克服发音器官的这种阻碍时所发的音，称为辅音。发辅音时，声带振动的是浊音，声带不振动的是清音。辅音只出现在音节的前端或后端或前后两端，时长和能量相比元音都很小。</li><li>半元音：有时，虽然声道基本畅通，但某处声道较窄，引起轻微的摩擦声，称为半元音。</li></ul><h2><span id="4共振峰formant与基频f0fundamental-frequency">4.共振峰（Formant）与基频F0（Fundamental frequency）</span></h2><p>共振峰和基频F0是语音信号处理中较为重要的概念，所以单独拿出来介绍一下。</p><p>(1)共振峰：前面介绍过发声机理，其中声道可以被等效视为一根横截面非均匀的声管，在发声过程中，该声管起共鸣器的作用。当一个具有相对较大能量的元音激励进入声道时，会引起共振特性，产生一组共振频率，称为共振峰频率，可简称为共振峰。换句话说，共振峰不是特指某一个频率的振动信号，而是代指一组具有不同频率的共振信号，这组信号里，每个信号所处的频率是不同的，但是是连续存在的。</p><p>一般可以用共振峰频率的位置和频带宽度这两个参数来描述一组共振峰。每个不同的元音，都对应着一组不同的共振峰参数。共振峰中的信号通常用F来表示，例如F0，F1，F2…等等。</p><p>(2)基频F0：基频又称基础频率，其定义为共振峰中第一个共振信号的振动频率。共振峰中除基频F0以外，其他共振信号均为口腔共振产生，而基频F0由声带振动产生，其能量一般为共振峰中最强的。有时将音调（pitch）和基频等效看待，二者其实有一些细节上的不同，但平时讨论时可以暂时视为一体。音调反应的是音高的信息，男性和女性的平均音调范围是不同的，男性更低一些，女性更高一些。</p><p>任何为基频整倍数的频率上的信号称为谐波。谐波反应的是音色的信息。</p><p>通常我们可以通过观测语音信号的语谱图，来对共振峰和基频有一个直观的了解。语谱图是将语音的频谱信号以二维形式所描绘出来的图形，该图形横轴为时间，单位通常为秒s，纵轴为频率，单位通常为赫兹Hz。图形上颜色的深浅代表声学信号能量强度的高低。一个典型的反应了共振峰的语谱图如下所示：<br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2F50%2Fc7878e14449512f39a917d29645006cd_hd.jpg&refer=http%3A%2F%2Fpic1.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1617685462&t=866a75dfb48a531d7493557f1d62b2e8" alt="avatar"></p><h2><span id="5我们如何听到声音">5.我们如何听到声音</span></h2><p>人类听到声音的简要过程：空气中的声波传播到人耳内，耳朵内的鼓膜受到声波的声压的作用会产生位移振动，内耳的一个主要器官耳蜗，将这种位移振动的机械信息，转换为生物神经信号，传递给大脑进行处理后，我们就能够获知听到的是什么声音了。具体的介绍请移步参考资料[2]中的2.4.2节，会有更详尽的了解。</p><p>人耳一般能接收并处理的声音的频率范围为20Hz<del>20kHz，强度为-5</del>130dB。在此范围外的声学信号里的音频分量，是人耳处理不到的，一般在语音信号处理领域的问题中不会考虑。但是，凡事无绝对，我们也不能说在这个范围以内的音频分量我们一定能听得到，这就涉及到一个概念叫做听觉掩蔽效应。</p><p>听觉掩蔽效应指的是在一个强信号附近，弱信号将变得听不到，被掩盖掉了。生活中这种例子常见的有：购物商场的大喇叭在外放吵闹的音乐时，两个人的对话可能即使很近也听不清楚。被掩蔽掉的不可闻信号的最大声压级称为掩蔽门限或掩蔽阈值，在这个掩蔽阈值以下的声音都会被掩盖掉。</p><h2><span id="参考资料列表">参考资料列表</span></h2><p>[1] 维基百科-声音词条：<a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E9%9F%B3">https://zh.wikipedia.org/wiki/%E5%A3%B0%E9%9F%B3</a></p><p>[2] 赵力. 语音信号处理[M]. 机械工业出版社, 2016.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;声学信号处理系列（一）–声学信号处理基础知识&quot;&gt;&lt;a href=&quot;#声学信号处理系列（一）–声学信号处理基础知识&quot; class=&quot;headerlink&quot; title=&quot;声学信号处理系列（一）–声学信号处理基础知识&quot;&gt;&lt;/a&gt;声学信号处理系列（一）–声学信号处理基础知识&lt;/h1&gt;&lt;p&gt;&lt;em&gt;by max&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021/03/07&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-写在开始的话&quot;&gt;&lt;a href=&quot;#0-写在开始的话&quot; class=&quot;headerlink&quot; title=&quot;0.写在开始的话&quot;&gt;&lt;/a&gt;0.写在开始的话&lt;/h2&gt;&lt;p&gt;这个博客系列里，会介绍一些声学信号处理领域相关的基础性知识，以及工业界学术界主流的一些算法应用方向。主要会关注与本人工作相关的一些细分领域，例如：语音增强、声纹识别、麦克风阵列、声学场景识别以及声纹识别反欺骗等诸多方向。随着系列博客文章的积累，会逐渐关注并提供更多应用领域的介绍。本系列旨在记录平时工作中学习到的新知识，也希望能跟别人分享自己的一些心得体会。个人水平有限，如有疏漏错误，敬请批评指正，谢谢！&lt;/p&gt;</summary>
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="声学信号处理" scheme="http://watermelondrip.github.io/tags/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>排序 （熟到可以默写）</title>
    <link href="http://watermelondrip.github.io/2021/03/07/%E6%8E%92%E5%BA%8F/"/>
    <id>http://watermelondrip.github.io/2021/03/07/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-06T22:35:00.000Z</published>
    <updated>2021-03-08T01:37:53.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序顺序"><a href="#排序顺序" class="headerlink" title="排序顺序"></a>排序<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%8E%92%E5%BA%8F.md">顺序</a></h2><p>思路是：</p><span id="more"></span><p>（1）快速选择，用于求解第k个元素的问题</p><p>（2）堆:堆的中心就一个，那就是动态求极值。 堆可以用二叉树实现，叫做二叉堆。二叉堆的性质就是堆的性质不变。</p><p> (3) 三向快排： 快排的核心思想是选择一个枢纽，左边的都比枢纽小，右边的都比枢纽大。 然后堆分成的两部分再进行递归快排。 但是如果有很多重复元素的时候呢，因为快排会对一个都是重复元素的数组再进行递归，其实我们已经知道了， 不用再进行递归了，因为已经是有序的了。 怎么实现呢？<br>    - 三向排序： 对于一个数组，一次扫描要有三个指针。</p><p><strong>目录 (Table of Contents)</strong></p><p>[TOCM]</p><p>[TOC]</p><p>##1. (LC215) Kth Element <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">Kth Element</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br> 示例 1：<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的是排序想法，直接把数组排序，然后找到k个就好了</li><li>堆， 堆是一种数据结构，一个很牛的<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ge-chong-pai-xu-suan-fa-tu-xie-zong-jie-by-ke-ai-x/">题解</a>和一个英文<a href="https://towardsdatascience.com/data-structure-heap-23d4c78a6962">解释</a> 和一个中文<a href="https://guguoyu.blog.csdn.net/article/details/81283998?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs">解释</a></li><li><a href="https://docs.python.org/3/library/heapq.html">heapq</a> 模块： 可能在面试过程中，有的面试官不让用，但是这个heapq还是很方便的。 (1)hq.heapqpush(heap,item) ：压入堆的意思，压入的是item （2）hq.heappop(heap)：弹出且返回最小的。hq.heappushpop(heap,item):先压入iem，然后弹出堆里最小的项。</li></ol><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest1</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment">#1. 排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest2</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 2. 最大堆  用heapq模块</span></span><br><span class="line">        <span class="keyword">import</span> heapq <span class="keyword">as</span> hq</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            hq.heappush(heap,i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                hq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest3</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 3.  最大堆， 构造堆模块</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">min_heapify</span>(<span class="params">array, i</span>):</span></span><br><span class="line">            left = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            length = <span class="built_in">len</span>(array) - <span class="number">1</span></span><br><span class="line">            smallest = i</span><br><span class="line">            <span class="keyword">if</span> left &lt;= length <span class="keyword">and</span> array[i] &gt; array[left]:</span><br><span class="line">                smallest = left</span><br><span class="line">            <span class="keyword">if</span> right &lt;= length <span class="keyword">and</span> array[smallest] &gt; array[right]:</span><br><span class="line">                smallest = right</span><br><span class="line">            <span class="keyword">if</span> smallest != i:</span><br><span class="line">                array[i], array[smallest] = array[smallest], array[i]</span><br><span class="line">                min_heapify(array, smallest)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_min_heap</span>(<span class="params">array</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(array)//<span class="number">2</span>)):</span><br><span class="line">                min_heapify(array, i)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">array</span>):</span></span><br><span class="line">            <span class="comment">#array = array.copy()</span></span><br><span class="line">            build_min_heap(array)</span><br><span class="line">            sorted_array = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">                array[<span class="number">0</span>], array[-<span class="number">1</span>] = array[-<span class="number">1</span>], array[<span class="number">0</span>]</span><br><span class="line">                sorted_array.append(array.pop())</span><br><span class="line">                min_heapify(array, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sorted_array</span><br><span class="line">        result = heapsort(nums)</span><br><span class="line">        <span class="keyword">return</span> result[-k]</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest4</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 4. 快速排序 [快速排序](https://jackkuo666.github.io/Data_Structure_with_Python_book/chapter6/section4.html)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">alist, low ,high</span>):</span></span><br><span class="line">            mid_value = alist[low]</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid_value:</span><br><span class="line">                    high-=<span class="number">1</span></span><br><span class="line">                alist[low] = alist[high]</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt;= mid_value:</span><br><span class="line">                    low+=<span class="number">1</span></span><br><span class="line">                alist[high] = alist[low]</span><br><span class="line">            alist[low] = mid_value</span><br><span class="line">            <span class="keyword">return</span> low</span><br><span class="line">        k = <span class="built_in">len</span>(nums) - k</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums) -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            p = partition(nums,low ,high)</span><br><span class="line">            <span class="keyword">if</span> k &lt; p:</span><br><span class="line">                high = p - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> k &gt; p:</span><br><span class="line">                low = p + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[p]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">         </span><br></pre></td></tr></tbody></table></figure><p>##2. (LC347) 前 K 个高频元素 <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前 K 个高频元素</a></p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素<br> 示例 1：<br>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的是排序想法，直接把数组排序，但是不满足时间复杂度的要求， 这里有个一个点是sort()函数，单独有一篇文章讲。</li><li>进一步，为了满足时间复杂度的要求，需要对解法一的排序过程进行改进。因为最终需要返回前k个频率最大的元素，可以想到借助堆这种数据结构。通过维护一个元素数目为k的最小堆，每次都将新的元素与对顶端的元素（也就是堆中频率最小的元素）进行比较，如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中。最终，堆中的k个元素即为前k个高频元素。 其中用到了.items(), #The items() method returns a view object. The view object contains the key-value pairs of the dictionary, as tuples in a list.</li><li>桶排序(bucket sort)，用空间复杂度换取时间复杂度的方法。为每一个数字设置一个桶，桶中是该数字出现的次数，然后对桶进行排序，实际上，上面的排序算法就说使用普通的排序方法对频率桶进行了排序，现在我们使用桶排序对频次惊醒排序。 桶排序为了进一步优化时间复杂度。 先统计数组中元素的频次。接着，将数组中的元素按着出现频次进行分组，即出现频次为i的元素存放在第i个桶，最后从桶中逆序取出前k个元素。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_1</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 1. 排序</span></span><br><span class="line">        freq_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums: <span class="comment"># 统计元素的频率</span></span><br><span class="line">            freq_dict[num] = freq_dict.get(num , <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        freq_dict_sort = <span class="built_in">sorted</span>(freq_dict.items(), key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line">        ret = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            ret.append(freq_dict_sort[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_2</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 2. 堆排序</span></span><br><span class="line">freq_dict = <span class="built_in">dict</span>() <span class="comment"># 统计元素的频率</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">freq_dict[num] = freq_dict.get(num,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 维护一个大小为k的最小堆，使得堆中的元素即为前k个高频元素</span></span><br><span class="line">pq = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> freq_dict.items(): </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pq)&lt; k:</span><br><span class="line">heapq.heappush(pq, (value,key))</span><br><span class="line"><span class="keyword">elif</span> value &gt; pq[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">heapq.heapreplace(pq, (value,key))</span><br><span class="line">ret = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">while</span> pq:</span><br><span class="line">ret.append(heapq.heappop(pq)[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_3</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 3. 桶排序</span></span><br><span class="line">freq_dict = <span class="built_in">dict</span>() <span class="comment"># 统计元素频率</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">freq_dict[num] = freq_dict.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+ <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> freq_dict.items():</span><br><span class="line">bucket[value].append(key)</span><br><span class="line">ret = <span class="built_in">list</span>() <span class="comment">#  逆序取出前k个元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(nums))):</span><br><span class="line"><span class="keyword">if</span> bucket[i]:</span><br><span class="line">ret.extend(bucket[i])</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ret)&gt;=k:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> ret[:k]</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ol><li>排序</li></ol><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(n)$ : 最极端的情况下（每个元素都不同），用于存储元素及其频率的map需要存储n个键值对</li></ul><ol start="2"><li>堆排序</li></ol><ul><li>时间复杂度：$O(nlogk)$ 其中n表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是O(n);接着，遍历用于存储元素频率的map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这一系列操作的时间复杂度是O(nlogk)的；最后，弹出堆中的元素所需要的时间复杂度O(klogk)。因此总的时间复杂度是O(nlogk)</li><li>空间复杂度：$O(n)$</li></ul><ol start="2"><li>桶排序</li></ol><ul><li>时间复杂度：$O(n)$ 数组的长度</li><li>空间复杂度：$O(n)$</li></ul><p>##3. (LC75) 颜色分类 <a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含红色、白色和蓝色，一共&nbsp;n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、&nbsp;1 和 2 分别表示红色、白色和蓝色。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></tbody></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>三路快排</li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul><li>在快排的基础上，将组数分为三个部分，及大于、等于、小于三个部分，其中大于和小于部分继续递归快排  </li><li>（lc官方解题）我们使用一个指针ptr表示头部位置的范围，ptr中存储了一个整数，表示数组nums从位置0到位置ptr - 1都属于【头部】。ptr的初始值为0，表示还没数处于【头部】。 在第一次遍历中，我们从左向右遍历整个数组，如果找到了0，那么就需要将0与【头部】位置的元素位置进行交换，并将【头部】向后扩充一位，结束后头部只有0。第二次同上。但是我们想要一次遍历怎么办，我们就要俩个指针。 </li><li>我们用指针p0 来交换 0， p1来交换1，初始值都是0。当从左向右遍历整个数组时:<br>  (1) 如果找到1， 那么将其与nums[p1]进行交换，并将p1向后移动一个位置。<br>  （2) 如果找到了0， 那么将其与nums[p0]交换的话，可能把1也交换出去。当p0 &lt; p1时，我们需要再将nums[i] 与nums[p1]进行交换，其中</li></ul><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li> 双指针</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        p0 = p1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                nums[i] , nums[p1] = nums[p1] , nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i] , nums[p0] = nums[p0] , nums[i]</span><br><span class="line">                <span class="keyword">if</span> p0 &lt; p1:</span><br><span class="line">                    nums[i] , nums[p1] = nums[p1] , nums[i]</span><br><span class="line">                p0+=<span class="number">1</span></span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="大佬解题"><a href="#大佬解题" class="headerlink" title="大佬解题"></a>大佬解题</h3><ol><li><a href="https://www.cnblogs.com/xugenpeng/p/9950007.html#%E6%8F%8F%E8%BF%B0">【LeetCode题解】347_前K个高频元素（Top-K-Frequent-Elements）</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;排序顺序&quot;&gt;&lt;a href=&quot;#排序顺序&quot; class=&quot;headerlink&quot; title=&quot;排序顺序&quot;&gt;&lt;/a&gt;排序&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%8E%92%E5%BA%8F.md&quot;&gt;顺序&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;思路是：&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="排序" scheme="http://watermelondrip.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆" scheme="http://watermelondrip.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="http://watermelondrip.github.io/2021/03/06/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://watermelondrip.github.io/2021/03/06/%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-03-06T04:55:07.241Z</published>
    <updated>2021-03-06T09:17:46.038Z</updated>
    
    <content type="html"><![CDATA[<p>#双指针 (<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-two-sum">顺序</a>)</p><p>双指针用于遍历数组，两个指针指向不同的元素，从而共同的完成一个任务。</p><span id="more"></span><p>（1）共同完成一个和的target</p><p><strong>目录 (Table of Contents)</strong></p><p>[TOCM]</p><p>[TOC]</p><p>##1. (LC167) 两数之和 II - 输入有序数组   <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">两数之和II</a></p><h3><span id="题目">题目</span></h3><p>给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p><p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p><p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br> 示例 1：</p><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><h3><span id="思路">思路</span></h3><p>双指针<br>如何想到双指针，我觉得首先是这个数组是有序的，然后就是由两个数构成，这就想到了双指针了</p><h3><span id="python3-code">Python3 Code:</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt; right:</span><br><span class="line">            total = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> total &gt; target:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]                </span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$ 只是遍历了一次</li><li>空间复杂度：$O(1)$ 只用了两个额外的变量（不考虑输出变量空间，只考虑额外的）</li></ul><p>##2. (LC633) 两数平方和   <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">两数平方和</a></p><h3><span id="题目">题目</span></h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。</p><p>示例 1：</p><p>输入：c = 5<br>输出：true<br>解释：1 * 1 + 2 * 2 = 5<br>范围：0 &lt;= c &lt;= 2^31 - 1</p><h3><span id="思路">思路</span></h3><p>首先这个又是两个整数的，我们想如果出现两个整数共同来完成一件事，这两个整数在一个范围内，是不是都可以用双指针呢。<br>但是这里面有平方比较麻烦了，所以上面那个不是和吗，我想如果求出c的根号是不是在这附近的数就比较好找了</p><h3><span id="python3-code">Python3 Code:</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span>(<span class="params">self, c: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sqr</span>(<span class="params">c</span>):</span></span><br><span class="line">            x0 = c/<span class="number">2</span></span><br><span class="line">            x1 = x0/<span class="number">2</span> + c/(x0*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">abs</span>(x1-x0) &gt; <span class="number">1</span>:</span><br><span class="line">                x0 = x1</span><br><span class="line">                x1 = x0/<span class="number">2</span> + c/(x0*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> x1</span><br><span class="line">        right,left = <span class="built_in">int</span>(sqr(c)),<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            print(left**<span class="number">2</span> + right**<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> left**<span class="number">2</span> + right**<span class="number">2</span> &gt; c:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> left**<span class="number">2</span> + right**<span class="number">2</span> &lt; c:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> </span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：$O(sqr(c)*n1)$ 只是遍历了一次 def sqrt(c)</p></li><li><p>空间复杂度：$O(1)$ 只用了两个额外的变量</p><p>##3. (LC345) 反转字符串中的元音字母<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" title="反转字符串中的元音字母">反转字符串中的元音字母</a>  </p><h3><span id="题目">题目</span></h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br>示例 1：<br>输入：”hello”<br>输出：”holle”</p><h3><span id="思路">思路</span></h3></li></ul><ol><li><p>首先使用双指针是因为，反转字符串中，是两个两个一对的换，通俗的意思是，如果是简单的反转字母是, ‘abc’ 反转之后变为 ‘cba’</p></li><li><p>有一个概念很重要，就是<a href="https://zhuanlan.zhihu.com/p/34395671" title="可变对象和不可变对象">可变对象和不可变对象</a><br> (1) 可变：list, dic, set （2）不可变：tuple, string, int, float, bool</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 不可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出来，可变对象是可以直接被改变的，而不可变对象则不可以</p><h3><span id="python3-code">Python3 Code:</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">list</span>(s))&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        front = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        vowels = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;I&quot;</span>,<span class="string">&quot;O&quot;</span>,<span class="string">&quot;U&quot;</span>&#125; </span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> front&lt; end:</span><br><span class="line">            <span class="keyword">if</span> s[front] <span class="keyword">in</span> vowels <span class="keyword">and</span> s[end] <span class="keyword">in</span> vowels:</span><br><span class="line">                s[front], s[end] = s[end] , s[front]</span><br><span class="line">                front+=<span class="number">1</span></span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[front] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                front+=<span class="number">1</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure></li></ol><ul><li>时间复杂度：$ $</li><li>空间复杂度：$ $  </li></ul><p>##4. (LC680)  验证回文字符串 Ⅱ <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" title="验证回文字符串 Ⅱ">验证回文字符串 Ⅱ</a></p><h3><span id="题目">题目</span></h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br>示例 1：<br>输入：”hello”<br>输出：”holle”</p><h3><span id="思路">思路</span></h3><ol><li>Lambda 函数<br>lambda 函数是一个小型匿名函数。lambda 函数可以接受任意数量的参数，但只能有一个表达式。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function that returns square of any number</span></span><br><span class="line">&gt;&gt;&gt;sqr = <span class="keyword">lambda</span> x: x * x</span><br><span class="line">&gt;&gt;&gt;sqr(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">100</span></span><br></pre></td></tr></table></figure></li><li> 优美的一行代码<br><a href="https://zhuanlan.zhihu.com/p/345055254" title="25条很棒的Python一行代码，建议收藏！">25条很棒的Python一行代码，建议收藏！</a><h3><span id="python3-code">Python3 Code:</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> s: s == s[::-<span class="number">1</span>]</span><br><span class="line">        strPart = <span class="keyword">lambda</span> s, x: s[:x] + s[x + <span class="number">1</span>:]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strPart(s, left)) <span class="keyword">or</span> isPalindrome(strPart(s, right))</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>时间复杂度：$ $</li><li>空间复杂度：$ $</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;#双指针 (&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-two-sum&quot;&gt;顺序&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;双指针用于遍历数组，两个指针指向不同的元素，从而共同的完成一个任务。&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="双指针" scheme="http://watermelondrip.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Day 1 - Max</title>
    <link href="http://watermelondrip.github.io/2021/03/06/firstday_max/"/>
    <id>http://watermelondrip.github.io/2021/03/06/firstday_max/</id>
    <published>2021-03-06T04:55:07.240Z</published>
    <updated>2021-03-06T09:14:53.171Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="day-1">Day 1</span></h1><p><em>by max</em></p><p><em>2021/02/28</em></p><p>这是在MAX的瓜园写下的第一篇日志，没有具体的内容，仅供测试使用。</p><span id="more"></span><p><strong>建立这个博客网页的主要目的是为了记录刷题过程中的收获，包括题解、算法思路和一些相关资料等。</strong></p><p><code>此网站也会收藏一些平日学习和工作中有价值的资料</code></p><p>网站仍在建设中，更多功能会逐步完善，包括评论功能等，敬请期待！！！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;Day 1&quot;&gt;&lt;/a&gt;Day 1&lt;/h1&gt;&lt;p&gt;&lt;em&gt;by max&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021/02/28&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是在MAX的瓜园写下的第一篇日志，没有具体的内容，仅供测试使用。&lt;/p&gt;</summary>
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="学习笔记" scheme="http://watermelondrip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode lc 395（至少有k个重复字符的最长子串）</title>
    <link href="http://watermelondrip.github.io/2021/03/06/lc395/"/>
    <id>http://watermelondrip.github.io/2021/03/06/lc395/</id>
    <published>2021-03-06T04:55:07.240Z</published>
    <updated>2021-03-06T09:15:22.736Z</updated>
    
    <content type="html"><![CDATA[<p>至少有k个重复字符的最长子串</p><span id="more"></span><p>date: 2021-02-27 16:19:03</p><h2><span id="分类">分类</span></h2><ul><li>递归<h2><span id="题目地址">题目地址</span></h2></li></ul><p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/</a></p><h2><span id="题目描述">题目描述</span></h2><p>给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。（难度中等） </p><p>示例 1：</p><p>输入：s = “aaabb”, k = 3<br>输出：3<br>解释：最长子串为 “aaa” ，其中 ‘a’ 重复了 3 次。<br>示例 2：</p><p>输入：s = “ababbc”, k = 2<br>输出：5<br>解释：最长子串为 “ababb” ，其中 ‘a’ 重复了 2 次， ‘b’ 重复了 3 次。 </p><p>提示：</p><p>1 &lt;= s.length &lt;= 104<br>s 仅由小写英文字母组成<br>1 &lt;= k &lt;= 105</p><h2><span id="前置知识">前置知识</span></h2><ul><li><p>递归</p><h2><span id="公司">公司</span></h2></li><li><p>暂无</p></li></ul><h2><span id="解题思路">解题思路</span></h2><ul><li>首先我是没想出来，看了答案发现了这个思路</li><li>要连续子序列也就是想当于如果出现了个数最少的字母，我们需要从那个最少的字母那里断开这个序列，直到把所有少于k的字母全部断开，然后从断开的所有子序列里找个最长的</li></ul><ul><li>对于split 那个function 还是不太清晰，我觉得有必要我整理一下<ul><li>The split() method splits a string into a list. 比如： txt = “hello, my name is Peter, I am 26 years old”； x = txt.split(“, “)  output: x=[‘hello’, ‘my name is Peter’, ‘I am 26 years old’]<h2><span id="代码">代码</span></h2></li></ul></li></ul><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubstring</span>(<span class="params">self, s, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)&lt;k:  <span class="comment">#base </span></span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s.count(c) &lt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>( self.longestSubstring(t, k) <span class="keyword">for</span> t <span class="keyword">in</span> s.split(c) )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>return 那块，前面self.longestSubstring，前面已经有self,后面的括号里就不要加了</li><li>s.split(c) 这个语句中，如果输入是“aaabb”. 输出是[“aaa”,”,”]</li></ul><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n<em>26)$  n(字符串长度)</em>(字符集) 因为递归最多26次（26个英文字母）</li><li>空间复杂度：$O(26^2)$  每层需要开辟26个字母的空间</li></ul><h2><span id="大佬解题">大佬解题</span></h2><ul><li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/</a></li><li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jiang-yuan-zi-fu-chuan-yi-shu-liang-bu-gou-de-zi-f/">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jiang-yuan-zi-fu-chuan-yi-shu-liang-bu-gou-de-zi-f/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;至少有k个重复字符的最长子串&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="递归" scheme="http://watermelondrip.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的分析</title>
    <link href="http://watermelondrip.github.io/2021/03/06/dataStructure/"/>
    <id>http://watermelondrip.github.io/2021/03/06/dataStructure/</id>
    <published>2021-03-06T04:55:07.239Z</published>
    <updated>2021-03-06T09:15:07.575Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构</p><span id="more"></span><ol><li>内存的物理表现的一系列连续的内存单元，每个内存单元大小是固定的。数据结构只有两个对应基础的数据结构，数组和链表，其他的数据结构都是由他们产生的。</li><li> 数组用来表示连续的内存空间，链表通常用来表示不连续的内存空间。</li><li>不连续内存空间的意思是，链表有数据域和指针域。</li></ol><hr><h2><span id="算法的性能">算法的性能</span></h2><ol><li>一个程序的运行时间主要主要是两个因素：（1）执行每条语句的耗时（2）执行每条语句的频率。</li></ol><hr><h2><span id="数组">数组</span></h2><ol><li>操作简单和支持随机访问</li><li>数组是一段连续的地址空间</li><li>数组使用连续的内存空间，来存储一系列同一数据类型的值。</li></ol><hr><h2><span id="栈">栈</span></h2><ol><li>栈是一种受限的数据结构，LIFO</li><li>常用操作：进栈push, 出栈pop，取栈顶top，isEmply</li><li>是一种逻辑结构</li><li>给数组和链表增加一个限制就是队列</li></ol><hr><h2><span id="队列">队列</span></h2><ol><li>也是一种逻辑结构</li><li>给数组和链表增加一个限制就是队列</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据结构&lt;/p&gt;</summary>
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构" scheme="http://watermelondrip.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="学习笔记" scheme="http://watermelondrip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>python 里 sort(),sorted() 的排序算法 -- Timsort简介</title>
    <link href="http://watermelondrip.github.io/2021/03/06/python%E9%87%8Csort%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://watermelondrip.github.io/2021/03/06/python%E9%87%8Csort%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-06T00:03:00.000Z</published>
    <updated>2021-03-06T11:06:51.613Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="排序算法">排序算法</span></h1><p>python里sort排序是一种名为Timsort的排序方法，其时间复杂度为$O(nlogn)$, 而且这是一种快速的稳定排序方法。<br>一个算法的稳定主要是：在假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则这种排序算法是稳定的；否则成为不稳定的。通俗的说， 就是两个相同的值，在排序位置不发生交换，就说稳定的，否则就说不稳定的。在一些条件下，稳定和不稳定也是相对的。</p><p>##sort()用法 和 sorted()用法的不同</p><ol><li>sort()只能用在列表list上，比如list.sort()。 sorted()is a global function。</li><li>list.sort is insitu，也就是说不增加一个拷贝，也就是说在原list上进行sort。  sorted增加一个新的copy，与原先的list 无关。Because sorted is a global function, it can take any iterable and return a sorted list from that</li><li><h3><span id="python3-code">Python3 Code:</span></h3></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>((<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(&#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;three&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;four&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;five&#x27;</span>:<span class="number">5</span>&#125;)</span><br><span class="line">[<span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">&#x27;this is a string&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;t&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>###大佬blog</p><ol><li><a href="http://https//blog.csdn.net/u010883226/article/details/84403263"> “Python里sort（）的排序算法–Timsort简介”</a></li><li><a href="https://discuss.codecademy.com/t/what-is-the-difference-between-sort-and-sorted/349679/7">What is the difference between sort() and sorted()?</a></li><li><a href="https://www.jianshu.com/p/6b7806c4f54a">Python中的iterable该怎么理解</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;排序算法&quot;&gt;排序算法&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;python里sort排序是一种名为Timsort的排序方法，其时间复杂度为$O(nlogn)$, 而且这是一种快速的稳定排序方法。&lt;br&gt;一个算法的稳定主要是：在假定在待排序的记录序列中，存在多个具有</summary>
      
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="排序" scheme="http://watermelondrip.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>第一天坚持坚持</title>
    <link href="http://watermelondrip.github.io/2021/02/27/firstday/"/>
    <id>http://watermelondrip.github.io/2021/02/27/firstday/</id>
    <published>2021-02-27T05:19:03.000Z</published>
    <updated>2021-03-06T09:15:37.282Z</updated>
    
    <content type="html"><![CDATA[<p>第一次记录一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一次记录一下&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="学习笔记" scheme="http://watermelondrip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
