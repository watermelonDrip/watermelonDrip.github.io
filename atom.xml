<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MAXの瓜园</title>
  
  
  <link href="http://watermelondrip.github.io/atom.xml" rel="self"/>
  
  <link href="http://watermelondrip.github.io/"/>
  <updated>2021-03-29T01:50:24.429Z</updated>
  <id>http://watermelondrip.github.io/</id>
  
  <author>
    <name>快乐地瓜🍠</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="http://watermelondrip.github.io/2021/03/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://watermelondrip.github.io/2021/03/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-03-28T13:42:00.000Z</published>
    <updated>2021-03-29T01:50:24.429Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><hr><span id="more"></span><h1 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><h3 id="递归与动态"><a href="#递归与动态" class="headerlink" title="递归与动态"></a>递归与动态</h3><p>递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。<script type="math/tex">\sigma</script></p><h3 id="分治与动态"><a href="#分治与动态" class="headerlink" title="分治与动态"></a>分治与动态</h3><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。<br>动态规划中的子问题往往不是相互独立的（即子问题重叠）。在求解的过程中，许多子问题的解被反复地使用。为了避免重复计算，动态规划算法采用了填表来保存子问题解的方法。</p><p>; ## 算法分析： </p><p>; ## 时间复杂度： </p><p>; ## 适应条件： </p><p>; ## 应用</p><p>; ## 大佬解释 </p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="LC70-爬楼梯-爬楼梯"><a href="#LC70-爬楼梯-爬楼梯" class="headerlink" title="(LC70 )爬楼梯    爬楼梯"></a>(LC70 )爬楼梯    <a href="https://leetcode-cn.com/problems/climbing-stairs/description/">爬楼梯</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></tbody></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>动态方程： dp[i] = dp[i-1] + dp[i-2]<br>考虑到与dp[i-2] 和 dp[i-1]有关，因此可以用两个变量来存储 dp[i-2] 和 dp[i-1]， 就成为了第三种方法，空间复杂度更低</p><h4 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span><span class="comment">#暴力超时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">k</span>):</span></span><br><span class="line">           <span class="keyword">if</span> k == <span class="number">1</span> <span class="keyword">or</span> k == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> k </span><br><span class="line">            <span class="keyword">return</span> fibonacci(k-<span class="number">1</span>)+ fibonacci(k-<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n)</span><br></pre></td></tr></tbody></table></figure><ul><li><p>复杂度分析<br>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span><span class="comment"># </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        fibonacci = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        fibonacci[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        fibonacci[<span class="number">1</span>] =  <span class="number">1</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            fibonacci[i] = fibonacci[i-<span class="number">1</span>] + fibonacci[i-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> fibonacci[-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li><p>复杂度分析<br>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        pre2 = <span class="number">1</span> </span><br><span class="line">        pre1 = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            cur = pre1 + pre2</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        <span class="keyword">return</span> pre1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li><p>复杂度分析<br>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul></li></ul><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><ol><li><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/zhi-xin-hua-shi-pa-lou-ti-zhi-cong-bao-l-lo1t/">从暴力到动态</a></li></ol><h3 id="LC198-打家劫舍-打家劫舍"><a href="#LC198-打家劫舍-打家劫舍" class="headerlink" title="(LC198) 打家劫舍   打家劫舍"></a>(LC198) 打家劫舍   <a href="https://leetcode-cn.com/problems/house-robber/description/">打家劫舍</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。 </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>动态方程 dp[i] = max(dp[i-1], dp[i-2] + nums[i])</li></ul><h4 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>小知识点们儿（全局局部区别，self参数）</title>
    <link href="http://watermelondrip.github.io/2021/03/29/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%AC%E5%84%BF/"/>
    <id>http://watermelondrip.github.io/2021/03/29/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%AC%E5%84%BF/</id>
    <published>2021-03-28T13:42:00.000Z</published>
    <updated>2021-03-28T13:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h1 id="Python-全局变量-局部变量区"><a href="#Python-全局变量-局部变量区" class="headerlink" title="Python 全局变量-局部变量区"></a>Python 全局变量-局部变量区</h1><p>整理一下<a href="https://www.cnblogs.com/insane-Mr-Li/p/9813226.html">这个</a><br>对于很多初学者来说，对于全局和局部变量容易混淆，我们来尝试解释一下：</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>全局变量：在模块内、在所有函数的外面、在class 外面<br>局部变量：在函数内，在class的方法内</strong></p><ol><li>在子程序中定义的变量成为局部变量，在程序的一开始定义的变量成为全局变量。全局变量作用域是整个程序，局部变量作用域是定义该变量的子程序。</li><li>全局变量没有任何缩进，在任何位置都可以调用</li><li>子程序：如用def定义的函数。</li><li>作用域 ：全局作用域（global)在整个程序运行中都可见。局部作用域：在函数内部、类等内部可见；局部变量使用范围不能超过其所在的局部作用域。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Name =<span class="string">"nicholas"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span>():</span></span><br><span class="line">    print(<span class="string">"change_name"</span>,Name)</span><br><span class="line">change_name()</span><br><span class="line">print(Name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>change_name nicholas</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nicholas</span><br></pre></td></tr></tbody></table></figure><ul><li>分析： <code>Name ="nicholas"</code>就是全局变量，在<code>change_name()</code>函数体内可以直接调用打印出<code>change_name nicholas</code></li></ul><ol><li>当全局变量与局部变量同名时<br>在定义局部变量的子程序内，局部变量起作用；在其他地方全局起作用</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Name =<span class="string">"nicholas"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span>():</span></span><br><span class="line">    Name =<span class="string">"ZhaoSiEr"</span></span><br><span class="line">    print(<span class="string">"change_name"</span>,Name)</span><br><span class="line">change_name()</span><br><span class="line">print(Name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>change_name ZhaoSiEr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nicholas</span><br></pre></td></tr></tbody></table></figure><ul><li>分析：当全局变量与局部变量同名时：在<code>def change_name():</code>函数内部，执行<code>print("change_name",Name)</code>语句时，这里的<code>Name</code>优先调用函数内部的值，函数执行结束后执行<code>print(Name)</code>语句，全局变量<code>Name ="nicholas"</code> 起作用。</li></ul><ol><li><p>如果函数内部无global关键字<br>优先读取局部变量，如果没有局部变量则读取全局变量，此时无法对全局变量进行赋值。 但是对于可变对象可以对内部元素进行操作（如<code>append()</code>,<code>pop()</code>）</p><ul><li>有声明（同名）局部变量<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name =[<span class="string">"Lijing Yi"</span>,<span class="string">"Shaogang Zhang"</span>]</span><br><span class="line">print(<span class="number">1</span>,name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span>():</span></span><br><span class="line">    name =<span class="string">"Dan Li"</span></span><br><span class="line">    print(<span class="string">"Dalao"</span>,name)</span><br><span class="line">change_name()</span><br><span class="line">print(<span class="number">2</span>,name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> [<span class="string">"Lijing Yi"</span>,<span class="string">"Shaogang Zhang"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dalao Dan Li</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> [<span class="string">"Lijing Yi"</span>,<span class="string">"Shaogang Zhang"</span>]</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li>这里无<code>global</code>关键字，执行<code>print(1,name)</code>语句时读取全局变量<code>name =["Lijing Yi","Shaogang Zhang"]</code>，之后执行<code>change_name()</code>函数，在函数里面<code>name ="Dan Li"</code>。执行<code>print("Dalao",name)</code>语句，这里的<code>name</code>优先读取函数内部的局部变量<code>name ="Dan Li"</code>，因此输出<code>Dalao Dan Li</code>。之后<code>change_name()</code>函数结束。执行<code>print(2,name)</code>语句时，这里仍然读取全局变量<code>name =["Lijing Yi","Shaogang Zhang"]</code>。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>搜索（BFS, DFS, Backtracking）</title>
    <link href="http://watermelondrip.github.io/2021/03/29/%E6%90%9C%E7%B4%A2%20/"/>
    <id>http://watermelondrip.github.io/2021/03/29/%E6%90%9C%E7%B4%A2%20/</id>
    <published>2021-03-28T13:42:00.000Z</published>
    <updated>2021-03-28T13:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="搜索（BFS-DFS-Backtracking）"><a href="#搜索（BFS-DFS-Backtracking）" class="headerlink" title="搜索（BFS, DFS, Backtracking）"></a>搜索（BFS, DFS, Backtracking）</h1><hr><p>广度优先算法（Breadth-First-Search），简称BFS。深度优先算法（Deep-First-Search），简称DFS。BFS:利用队列先进先出的特性，可以优先遍历横向节点。DFS:利用栈先进后出的特性，可以优先遍历纵向节点。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md">搜索</a></h2><p>深度优先搜索和广度优先搜索广泛应用于树和图中。 （1） BFS  (2) DFS  (3) Backtracking<br><span id="more"></span></p><h1 id="BFS-广度优先搜索）"><a href="#BFS-广度优先搜索）" class="headerlink" title="BFS (广度优先搜索）"></a>BFS (广度优先搜索）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p>广度优先算法（BFS）：是一种<a href="https://www.xiaoheidiannao.com/13213.html">图形搜索演算法</a>。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点，如果发现目标，则演算终止。</p><h2 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h2><p>BFS是一种盲目搜寻法，目的是系统的展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为主。</p><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>邻接表的时候是$O(|V|+|E|)$。其中，$|V|$是节点的数目，$|E|$是图中边的数目。</p><h2 id="适应条件："><a href="#适应条件：" class="headerlink" title="适应条件："></a>适应条件：</h2><p>对于所有边长度相同的情况，比如地图的模型，BFS第一次遇到目标点，此时就一定是从根节点到目标节点的最短路径（因为每次所有的点都是向外扩张一步，你先遇到，那你就一定最短的了）。<strong>BFS先找到的一定是最短的</strong>。但是如果是加权边的话就会有问题，BFS传回的是经过<strong>边数最少</strong>的解，但是因为加权了，这个解到根节点的<strong>距离</strong>就不一定是最短的了。比如1000+1000是两段，1+1+1是三段，但是由于BFS返回的是是<strong>经过边数最少的的解</strong>，这里就会返回总长度是2000的那个解，但是显然不是距离最短的路径。此时我们就应该采用<strong>Dijkstra最短路算法</strong>解决加权路径的最短路了（这就有点超纲了呀）。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>寻找非加权图(或者所有边权重是一样)中任两点的最短路径。</li><li>寻找其中一个连通分支中的所有节点（扩散性）。</li><li>BFS染色法判断是否为二分图</li><li>BFS也可以运用在算法和爬虫之中。而BFS优先处理自己周围的资源。所以在爬虫可以用于遍历网站，搜寻整个网站的价值信息等等，笔者以前用爬虫+bfs实现过下载网站的模板(17素材的网页模板)。 而在算法中，在迷宫或者无权图中，bfs可以找到最短路径。并且在bfs还有变种的A*等高级算法。并 且bfs经常和优先队列在一起搜索部分有其他规则的目的地。  </li></ol><h2 id="大佬解释BFS"><a href="#大佬解释BFS" class="headerlink" title="大佬解释BFS"></a>大佬解释BFS</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/40151973#:~:text=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88Breadth%2DFirst,%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BB%A5%E6%89%BE%E5%AF%BB%E7%BB%93%E6%9E%9C%E3%80%82">BFS算法介绍</a></li><li><a href="https://zhuanlan.zhihu.com/p/50187643">算法- 从栈 &amp; 队列 到 BFS &amp; DFS</a></li><li><a href="https://www.jianshu.com/p/d2125448270b">用Python实现树的BFS与DFS</a></li><li><a href="https://zhuanlan.zhihu.com/p/141898546">LeetCode | 一文帮你搞定BFS、DFS算法（python版）</a></li></ol><h1 id="DFS-深度优先搜索）"><a href="#DFS-深度优先搜索）" class="headerlink" title="DFS (深度优先搜索）"></a>DFS (深度优先搜索）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h2><p>深度优先搜索（DFS）：也是一种图形搜索演算法。简单的说，DFS是从根节点开始，沿着树的深度遍历树的节点，沿着一条路一直走到底，然后从这条路的尽头的节点回退到上一个节点，再从另一条路开始走到底，不断重复，  如果发现目标，则演算终止。特点是<strong>不撞南墙不回头</strong>，先走完一条路，再换一条路继续走。</p><h2 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a>算法分析：</h2><p>DFS也是一种盲目搜寻法，目的是系统的展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为主。树是图的一个特例，树是如何用深度优先遍历进行遍历的<a href="https://developer.aliyun.com/article/756316">戳这里</a></p><h2 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>邻接表的时候是$O(|V|+|E|)$。其中，$|V|$是节点的数目，$|E|$是图中边的数目。<br>邻接矩阵表示时，查找每个顶点的邻接点所需时间为$O(|V|)$，要查找整个矩阵，故总的时间度为$O(|V|^2)$。</p><h2 id="适应条件：-1"><a href="#适应条件：-1" class="headerlink" title="适应条件："></a>适应条件：</h2><p>广度优先搜索一层一层遍历，每一层得到的所有新节点，用队列存储起来以备下一层遍历的时候再遍历。而深度优先搜索再得到一个新的节点时立即堆新节点进行遍历。从一个节点出发，使用DFS对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS常用来求解这种<strong>可达性</strong>问题。</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>1.dfs可以运用在查找和爬虫中，如果爬虫的话那么更多是优先找到不同链接，可用于统计等。而在查找中比如迷宫类可以利用dfs判断 是否存在路径，出路等等。<a href="https://juejin.cn/post/6844903934616682509">click here</a></p><h2 id="大佬解释BFS-1"><a href="#大佬解释BFS-1" class="headerlink" title="大佬解释BFS"></a>大佬解释BFS</h2><ol><li><a href="https://www.pythonf.cn/read/99825">深度优先搜索（DFS）和广度优先搜索（BFS）</a> </li><li><a href="https://juejin.cn/post/6844903934616682509">深度优先搜索、广度优先搜索(dfs和bfs)详解</a></li></ol><h1 id="BFS-vs-DFS"><a href="#BFS-vs-DFS" class="headerlink" title="BFS vs DFS"></a>BFS vs DFS</h1><p><img src= "/img/watermelon.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200428190053807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTM4OTg=,size_16,color_FFFFFF,t_70" alt="avatar"></p><h2 id="BFS思想："><a href="#BFS思想：" class="headerlink" title="BFS思想："></a>BFS思想：</h2><p>BFS是队列的思想。如下图，BFS从起点<code>A</code>,把<code>A</code>附近的点<code>(B,C)</code>先遍历，遍历完<code>(B,C)</code>入队，然后再以<code>B</code>为起点，遍历<code>B</code>点附近的未被遍历过的点。<strong>呈现扩散趋势</strong>。所以以下图为例，以<code>A</code>点为起点，BFS遍历顺序是：<code>[A,B,C,D,E,F]</code></p><h2 id="DFS思想："><a href="#DFS思想：" class="headerlink" title="DFS思想："></a>DFS思想：</h2><p>DFS是栈的思想。如下图，DFS从起点<code>A</code>（被遍历）,把<code>A</code>附近的点<code>B,C</code>先入栈，由于栈是后进先出，所以<code>C</code>先出栈（被遍历），然后接着<code>C</code>点附近未入栈的<code>D,E</code>点入栈，然后是后入过栈的<code>E</code>点出栈（被遍历），然后接着<code>E</code>点附近找未入过栈的点，但是发现<code>E</code>点附近的点都入过栈，这是没有新的点入栈了，那就开始出栈。所以<code>D</code>点开始出栈（被遍历），然后<code>D</code>点附近没有入过栈的<code>F</code>点入栈，又没有未入过栈的点，点<code>F</code>出栈（被遍历），只剩点<code>B</code>（被遍历）。</p><h1 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h2><ol><li>当题目中出现“所有组合”等类似字眼时，我们第一感觉就要想到用回溯了。</li><li><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但是当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p></li><li><p>Backtracking（回溯）属于DFS</p><ul><li>普通DFS主要用在可达性问题，这种问题只需要执行到特点的位置然后返回即可。而Backtracking主要用于求解排列组合问题，例如有<code>{'a','b','c'}</code>三个字符，求解所有由这三个字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li></ul></li><li><p>Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p><ul><li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素</li><li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li></ul></li><li><p>回溯本质是暴力搜索，再问题的解空间树中，用DFS的方式，从根节点出发搜索整个解空间。如果要找出所有的解，则要搜索整个子树，如果只用找出一个解，则搜到一个解就可以结束搜索。<strong>找出所有可能的组合</strong>的问题，适合用回溯算法。</p></li></ol><h2 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a>算法分析：</h2><h2 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><h2 id="适应条件：-2"><a href="#适应条件：-2" class="headerlink" title="适应条件："></a>适应条件：</h2><h2 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h2><ol><li>回溯法来解决<code>n</code>个<code>for</code>循环问题</li></ol><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>回溯算法专注三个问题:</p><ul><li>路径：已经做出的选择</li><li>选择列表：当前可以做的选择</li><li>结束条件：到达决策树底层，无法再做选择<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径，选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件：</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="大佬解释BFS-2"><a href="#大佬解释BFS-2" class="headerlink" title="大佬解释BFS"></a>大佬解释BFS</h2><ol><li><p>个人认为，充分剪枝的回溯算法和三层嵌套的暴力循环，复杂度是一样的，而不存在什么“暴力循环是O(1)，回溯不是O(1)”的情况。字符串拷贝（构造）在许多语言下应当都类似于数组拷贝，是一个O(|s|)的操作，暴力循环也无法避免数组拷贝，所以在输出集合生产这件事下，回溯 = 暴力循环。至于递归和循环究竟有多少层，画画递归调用栈就看出来了，二者是一模一样的（当然递归需要剪枝）。</p><p> 究其原因，本题说白了是一个每个顶点度最大为3，且半径最大为4的无向图，从中心出发完成遍历。这种图的循环当然好写了，因为规模小呀。而且本题因为状态的出现和游标推移是完全一致的，所以并不需要构造图，循环显得非常易写。</p><p> 脱离性能层面，也且不论代码可读性层面，回溯仍是必须要掌握的算法。虽然回溯算法由于“指数爆炸”通常不适用于大规模的计算，但它仍然是算法领域里一个重要组成，甚至很多时候是最优解。并且，许多时候它逐渐缩小问题规模的思考方式，在特定的问题下，稍加改动就能通向很多其他算法分支——动态规划、记忆化搜索等。</p></li></ol><hr><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><hr><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="LC1091-计算在网格中从原点到特定点的最短路径长度-计算在网格中从原点到特定点的最短路径长度"><a href="#LC1091-计算在网格中从原点到特定点的最短路径长度-计算在网格中从原点到特定点的最短路径长度" class="headerlink" title="(LC1091)计算在网格中从原点到特定点的最短路径长度   计算在网格中从原点到特定点的最短路径长度 "></a>(LC1091)计算在网格中从原点到特定点的最短路径长度   <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">计算在网格中从原点到特定点的最短路径长度 </a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p> 给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：路径途经的所有单元格都的值都是 0 。路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。畅通路径的长度 是该路径途经的单元格总数。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1],[1,0]]</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>Deque(class collections.deque([iterable[,maxlen]])) <a href="collections中 deque的使用">使用戳一戳</a><ul><li>Deque是双边队列（double-ended queue），具有队列和栈的性质，在 list 的基础上增加了移动、旋转和增删等。</li><li>Deque队列是由栈或者queue队列生成的（发音是”deck”,”double-ended queue”的简称）。</li><li>Deque是一个双端队列, 如果要经常从两端append 的数据, 选择这个数据结构就比较好了, 如果要实现随机访问,不建议用这个,请用列表。Deque 优势就是可以从两边append ,appendleft 数据。这一点list 是没有的<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">queue = deque([<span class="string">"Eric"</span>, <span class="string">"John"</span>, <span class="string">"Michael"</span>])</span><br><span class="line">queue.append(<span class="string">"Terry"</span>)           <span class="comment"># Terry 入队</span></span><br><span class="line">queue.append(<span class="string">"Graham"</span>)          <span class="comment"># Graham 入队</span></span><br><span class="line">queue.popleft()                 <span class="comment"># 队首元素出队</span></span><br><span class="line"><span class="comment">#输出: 'Eric'</span></span><br><span class="line">queue.popleft()                 <span class="comment"># 队首元素出队</span></span><br><span class="line"><span class="comment">#输出: 'John'</span></span><br><span class="line">print(queue)                           <span class="comment"># 队列中剩下的元素</span></span><br><span class="line"><span class="comment">#输出: deque(['Michael', 'Terry', 'Graham'])</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>第一次刷这个BFS,毫无头绪，怎么办？首先是看到大佬的一个模板，先偷过来<ul><li>第一步：先构造图<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initial_graph</span>(<span class="params">n, edges</span>):</span></span><br><span class="line">    dict_graph = {}  <span class="comment">#用字典表示</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dict_graph[i] = []</span><br><span class="line">    num_e = <span class="built_in">len</span>(edges)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_e):</span><br><span class="line">        u = edges[i][<span class="number">0</span>] <span class="comment">#用矩阵表示</span></span><br><span class="line">        v = edges[i][<span class="number">1</span>]</span><br><span class="line">        dict_graph[u].append(v)</span><br><span class="line">        dict_graph[v].append(u)</span><br><span class="line">    <span class="keyword">return</span> dict_graph</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><ul><li>第二步：使用队列<br>  BFS适用于层级搜索，队列先进先出，量身定做。python中队列有两种导入方法：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.使用queue  #队列</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line">q = Queue() <span class="comment"># 定义，为什么是这样涉及python的设计，不是很懂</span></span><br><span class="line">q.put(node) <span class="comment"># 放入</span></span><br><span class="line">q.get() <span class="comment"># 出队</span></span><br><span class="line"><span class="comment"># 2.使用deque</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">q = collections.deque() <span class="comment"># 双向队列</span></span><br><span class="line">q.append() <span class="comment"># 入队</span></span><br><span class="line">q.popleft() <span class="comment"># 出队</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>第三步：节点入队</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Queue()定义</span></span><br><span class="line">q.put(start_node)</span><br><span class="line"><span class="comment"># 为防止无向图中回溯，使用set阻断</span></span><br><span class="line">hash_set = <span class="built_in">set</span>()</span><br><span class="line">hash_set.add(start_node)</span><br></pre></td></tr></tbody></table></figure></li><li><p>第四步：BFS主体</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">size = <span class="built_in">len</span>(q)</span><br><span class="line">step += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> iter_num <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">node = q.get() <span class="comment"># current node</span></span><br><span class="line"><span class="comment"># get the neighbor</span></span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> dict_graph[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor == end_node: <span class="comment"># find it!!!!</span></span><br><span class="line"><span class="keyword">return</span> step</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> hash_set:</span><br><span class="line"><span class="keyword">continue</span> <span class="comment"># avoid backtracking</span></span><br><span class="line">hast_set.add(node)</span><br><span class="line">q.put(neighbor)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="comment"># can't find</span></span><br></pre></td></tr></tbody></table></figure></li></ul><ol><li>具体操作<ul><li>本题本身就是矩阵，就不需要重新弄建initial。从头遍历，每次遇到0的时候，将周围8个方向可走的点push进队列，这样就可以将下一步能走的点找到。</li><li>用一个大小为3的数组来保存当前点的坐标，和走到当前点所需要的代价</li><li>由于要找的是花费路径最短的，所以第一个符合循环结束条件的数组，其第三个值就是我们要找的最小代价</li></ul></li></ol><h4 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">or</span> grid[n - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>:  <span class="comment"># 若起始点或终点堵塞，则不可能有这样的路径</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">1</span>  <span class="comment"># 注意题目的描述，是返回从 1 到 k 的路径，第一个节点被定为下标 1，</span></span><br><span class="line">        path = deque()</span><br><span class="line">        path.append([<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 先压入起点</span></span><br><span class="line">        <span class="keyword">while</span> path:  <span class="comment"># BFS模板</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path)):  <span class="comment"># 对BFS的某一层的中所有点向8个方向进行扩展</span></span><br><span class="line">                x, y = path.popleft()</span><br><span class="line">                <span class="keyword">for</span> new_x, new_y <span class="keyword">in</span> [[x - <span class="number">1</span>, y - <span class="number">1</span>], [x - <span class="number">1</span>, y], [x - <span class="number">1</span>, y + <span class="number">1</span>], [x, y - <span class="number">1</span>],</span><br><span class="line">                                     [x, y + <span class="number">1</span>], [x + <span class="number">1</span>, y - <span class="number">1</span>], [x + <span class="number">1</span>, y], [x + <span class="number">1</span>, y + <span class="number">1</span>]]:</span><br><span class="line">                    <span class="comment"># 下面几种continue可以合并一行，这里为看的清楚就分开写了</span></span><br><span class="line">                    <span class="keyword">if</span> new_x == n - <span class="number">1</span> <span class="keyword">and</span> new_y == n - <span class="number">1</span>:  <span class="comment"># 如果扩展的点到达了终点</span></span><br><span class="line">                        <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_x &lt; n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_y &lt; n:  <span class="comment"># 扩展的点超出边界，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">1</span>:  <span class="comment"># 若扩展的点为阻塞，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == -<span class="number">1</span>:  <span class="comment"># 若扩展的点已经访问过，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">0</span>:  <span class="comment"># 若为通畅点</span></span><br><span class="line">                        grid[new_x][new_y] = -<span class="number">1</span>  <span class="comment"># 当前层次下已经访问该点</span></span><br><span class="line">                        path.append([new_x, new_y])  <span class="comment"># 将扩展的点加入path，到下一层的时候继续扩展</span></span><br><span class="line">            res += <span class="number">1</span>  <span class="comment"># 对某一层的元素都求判定过后，距离加1(同一个层次中的所有点的距离距离起点都是相等的）</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC297-完全平方数-完全平方数"><a href="#LC297-完全平方数-完全平方数" class="headerlink" title="(LC297)完全平方数   完全平方数 "></a>(LC297)完全平方数   <a href="https://leetcode-cn.com/problems/perfect-squares/description/">完全平方数 </a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol><li>可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。</li><li><a href="https://leetcode-cn.com/problems/perfect-squares/solution/dong-tai-gui-hua-bfs-zhu-xing-jie-shi-python3-by-2/">广度优先遍历</a></li><li><h4 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([n])  <span class="comment">#必须带[]，否则不是iterable </span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            step +=<span class="number">1</span></span><br><span class="line">            l = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                temp = queue.pop()  <span class="comment"># 不能用 queue.popleft() 因为后面用的是appendleft。前后只能有一个left</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(temp**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">                    x = temp - i**<span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> step</span><br><span class="line">                    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(x)</span><br><span class="line">                        queue.appendleft(x)</span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC127-单词接龙-单词接龙"><a href="#LC127-单词接龙-单词接龙" class="headerlink" title="(LC127 )单词接龙   单词接龙 "></a>(LC127 )单词接龙   <a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙 </a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>序列中第一个单词是 beginWord 。<br>序列中最后一个单词是 endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典 wordList 中的单词。<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog", 返回它的长度 5。 </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>从起点词出发，每次变一个字母，经过n次变换，变成终点词，希望n尽量小。</li><li>我们需要找出邻接关系，比如<code>hit</code>变成一个字母会变成<code>_it</code>，<code>h_t</code>，<code>hi_</code>形式的新词，再看看该新词是否存在于单词表中，如果存在，就找到了一个下一层的转换词。</li><li>同时，要避免重复访问，<code>hot-&gt;dot-&gt;hot</code>这样变回来是没有意义的，徒增转换的长度。</li><li>所以确定了下一个转换词之后， 将它从单词表中删除（单词表里的单词是唯一的）</li><li><code>wordSet=set(wordList)</code>，方便<code>o(1)</code>时间复杂度查找</li><li></li></ol><h4 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([beginWord])</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        wordSet = <span class="built_in">set</span>(wordList)</span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">in</span> wordSet:</span><br><span class="line">            wordSet.remove(beginWord)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            step+=<span class="number">1</span></span><br><span class="line">            l = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                word = queue.pop()</span><br><span class="line">                <span class="keyword">if</span> word == endWord:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">                  <span class="comment"># 开始变化单词（一个位置有26种情况）</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                        new_word = word[:j] + <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">'a'</span>)+i) + word[j+<span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> new_word <span class="keyword">in</span> wordSet: </span><br><span class="line">                            wordSet.remove(new_word)</span><br><span class="line">                            queue.appendleft(new_word)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p> 最坏情况下时间复杂度：O(m*n)，n为字典中单词数量，m为单词长度  </p><ul><li>时间复杂度：$O(m*n)$</li><li>空间复杂度：$O(n)$</li></ul><h4 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h4><hr><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><hr><h3 id="LC695-岛屿的最大面积-岛屿的最大面积"><a href="#LC695-岛屿的最大面积-岛屿的最大面积" class="headerlink" title="(LC695)岛屿的最大面积   岛屿的最大面积 "></a>(LC695)岛屿的最大面积   <a href="https://leetcode-cn.com/problems/max-area-of-island/">岛屿的最大面积 </a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。<br>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]] </span><br></pre></td></tr></tbody></table></figure><br>对于上面这个给定矩阵应返回 6。注意答案不应该是 11，因为岛屿只能包含水平或垂直的四个方向的 1 。<p></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span>  <span class="comment">#grid 是小岛，也就是题目中给的矩阵</span></span><br><span class="line">       <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">       stack = deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       ans = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> i,l <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid): </span><br><span class="line">           <span class="keyword">for</span> j,n <span class="keyword">in</span> <span class="built_in">enumerate</span>(l):    <span class="comment">#[i,j] 是 n 在grid 中的位置（下标[i,j]）</span></span><br><span class="line">               cur = <span class="number">0</span></span><br><span class="line">               stack.append([i,j])</span><br><span class="line">               <span class="keyword">while</span> stack:</span><br><span class="line">                   cur_i, cur_j = stack.pop()</span><br><span class="line">                   <span class="keyword">if</span> cur_i &lt; <span class="number">0</span> <span class="keyword">or</span> cur_j &lt; <span class="number">0</span>  <span class="keyword">or</span> cur_i == <span class="built_in">len</span>(grid) <span class="keyword">or</span> cur_j == <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[cur_i][cur_j]== <span class="number">0</span>:</span><br><span class="line">                       <span class="keyword">continue</span></span><br><span class="line">                   cur+=<span class="number">1</span></span><br><span class="line">                   grid[cur_i][cur_j]=<span class="number">0</span></span><br><span class="line">                   <span class="keyword">for</span> di, dj <span class="keyword">in</span> [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,-<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">1</span>,<span class="number">0</span>]]:</span><br><span class="line">                       next_i , next_j = cur_i + di, cur_j + dj</span><br><span class="line">                       stack.append([next_i,next_j])</span><br><span class="line">               ans = <span class="built_in">max</span>(ans,cur)</span><br><span class="line">       <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC200-岛屿数量-岛屿数量"><a href="#LC200-岛屿数量-岛屿数量" class="headerlink" title="(LC200)岛屿数量   岛屿数量 "></a>(LC200)岛屿数量   <a href="https://leetcode-cn.com/problems/number-of-islands/description/">岛屿数量 </a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  ["1","1","1","1","0"],</span><br><span class="line">  ["1","1","0","1","0"],</span><br><span class="line">  ["1","1","0","0","0"],</span><br><span class="line">  ["0","0","0","0","0"]</span><br><span class="line">]</span><br><span class="line">输出：1 </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>DFS (一条路走到黑)，看看有几个路可以走</li><li>暂时先不用字典，一步一步来，这样if 的看起来清晰</li></ul><h4 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        rows_count = <span class="built_in">len</span>(grid)</span><br><span class="line">        cols_count = <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">if</span> grid <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        stack = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows_count):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols_count):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    num_islands+=<span class="number">1</span></span><br><span class="line">                    stack.append([i,j])</span><br><span class="line">                    <span class="keyword">while</span> stack:</span><br><span class="line">                        ci,cj = stack.pop()</span><br><span class="line">                        grid[ci][cj] = <span class="string">'0'</span></span><br><span class="line">                        <span class="keyword">if</span> ci&gt;<span class="number">0</span> <span class="keyword">and</span> grid[ci-<span class="number">1</span>][cj]==<span class="string">'1'</span>: </span><br><span class="line">                        <span class="comment">#不能改成elif 要不就变成每次stack pop一个append 一个了， 就没有积压的过程了</span></span><br><span class="line">                            stack.append([ci-<span class="number">1</span>,cj])</span><br><span class="line">                        <span class="keyword">if</span> cj&gt;<span class="number">0</span> <span class="keyword">and</span> grid[ci][cj-<span class="number">1</span>]==<span class="string">'1'</span>:</span><br><span class="line">                            stack.append([ci,cj-<span class="number">1</span>])</span><br><span class="line">                        <span class="keyword">if</span>  rows_count-<span class="number">1</span> &gt;ci <span class="keyword">and</span> grid[ci+<span class="number">1</span>][cj]==<span class="string">'1'</span>:</span><br><span class="line">                            stack.append([ci+<span class="number">1</span>,cj])</span><br><span class="line">                        <span class="keyword">if</span>  cols_count-<span class="number">1</span> &gt;cj <span class="keyword">and</span> grid[ci][cj+<span class="number">1</span>]==<span class="string">'1'</span>:</span><br><span class="line">                            stack.append([ci,cj+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> num_islands</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：$O(m*n)$，其中，m行数，n列数</li><li>空间复杂度：$O(m<em>n)$，再最坏的情况下，整个网格均为陆地，深度优先搜索的深度达到m</em>n</li></ul><h4 id="大佬题解-4"><a href="#大佬题解-4" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC547-Number-of-Provinces-Number-of-Provinces-Number-of-Provinces"><a href="#LC547-Number-of-Provinces-Number-of-Provinces-Number-of-Provinces" class="headerlink" title="(LC547 Number of Provinces) Number of Provinces   Number of Provinces"></a>(LC547 Number of Provinces) Number of Provinces  <a href="https://leetcode-cn.com/problems/number-of-provinces/"> Number of Provinces</a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>(看题解发现以前是朋友圈）有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。<br>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。返回矩阵中 省份 的数量。<br>(以前的题)题目描述：好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0][1] 和 M[1][0] 的值都为 1。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">Output: 2 </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><ul><li>deque模块是python标准库collections中的一项，它提供了两端都可以操作的序列，这意味着，在序列的前后你都可以执行添加或删除操作</li></ul><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ul><li>DFS+栈</li></ul><h4 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment">#双向队列 </span></span><br><span class="line">        n = <span class="built_in">len</span>(isConnected)</span><br><span class="line">        visited = <span class="built_in">dict</span>()        </span><br><span class="line">        circles = <span class="number">0</span></span><br><span class="line">        stack = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> visited.get(i):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            stack.append([i,i])</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                i, j = stack.pop()</span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> visited.get(index): <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> isConnected[i][index]: stack.append((i, index))  </span><br><span class="line">                    <span class="keyword">if</span> isConnected[j][index]: stack.append((j, index))   </span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">                visited[j] = <span class="literal">True</span></span><br><span class="line">            circles += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> circles </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-5"><a href="#大佬题解-5" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="被围绕的区域-LC130-被围绕的区域"><a href="#被围绕的区域-LC130-被围绕的区域" class="headerlink" title="被围绕的区域 (LC130 )  被围绕的区域"></a>被围绕的区域 (LC130 )  <a href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的’O’ 用 ‘X’ 填充</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ul><li>把边界的O变为M，中间的O变为x,</li></ul><h4 id="Python3-Code-6"><a href="#Python3-Code-6" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        m = <span class="built_in">len</span>(board)</span><br><span class="line">        n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        stack = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> i == m - <span class="number">1</span> <span class="keyword">or</span> j == n-<span class="number">1</span> ) <span class="keyword">and</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    stack.append([i,j])</span><br><span class="line">                    board[i][j] = <span class="string">'M'</span></span><br><span class="line">                    <span class="keyword">while</span> stack:</span><br><span class="line">                        ci,cj = stack.pop()</span><br><span class="line">                        board[ci][cj] = <span class="string">'M'</span></span><br><span class="line">                        <span class="keyword">if</span> ci &gt; <span class="number">0</span> <span class="keyword">and</span> board[ci-<span class="number">1</span>][cj] == <span class="string">'O'</span>:</span><br><span class="line">                            stack.append([ci-<span class="number">1</span>,cj])</span><br><span class="line">                        <span class="keyword">if</span> cj &gt; <span class="number">0</span> <span class="keyword">and</span> board[ci][cj-<span class="number">1</span>] == <span class="string">'O'</span>:</span><br><span class="line">                            stack.append([ci,cj-<span class="number">1</span>])</span><br><span class="line">                        <span class="keyword">if</span> ci &lt; m -<span class="number">1</span> <span class="keyword">and</span> board[ci+<span class="number">1</span>][cj] == <span class="string">'O'</span>:</span><br><span class="line">                            stack.append([ci+<span class="number">1</span>,cj])</span><br><span class="line">                        <span class="keyword">if</span> cj &lt; n-<span class="number">1</span> <span class="keyword">and</span> board[ci][cj+<span class="number">1</span>] == <span class="string">'O'</span>:</span><br><span class="line">                            stack.append([ci,cj+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'M'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br><span class="line">        <span class="keyword">return</span> board</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-6"><a href="#大佬题解-6" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC417-太平洋大西洋水流问题-太平洋大西洋水流问题"><a href="#LC417-太平洋大西洋水流问题-太平洋大西洋水流问题" class="headerlink" title="(LC417 )太平洋大西洋水流问题   太平洋大西洋水流问题 "></a>(LC417 )太平洋大西洋水流问题   <a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/description/">太平洋大西洋水流问题 </a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。<br>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。<br>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line">返回:</span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-7"><a href="#Python3-Code-7" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-7"><a href="#大佬题解-7" class="headerlink" title="大佬题解"></a>大佬题解</h4><h2 id="BackTracking"><a href="#BackTracking" class="headerlink" title="BackTracking"></a>BackTracking</h2><h3 id="LC17-电话号码的字母组合-电话号码的字母组合"><a href="#LC17-电话号码的字母组合-电话号码的字母组合" class="headerlink" title="(LC17)电话号码的字母组合     电话号码的字母组合 "></a>(LC17)电话号码的字母组合    <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/"> 电话号码的字母组合 </a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = "23"</span><br><span class="line">输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ul><li><p>图解<br><img src= "/img/watermelon.gif" data-lazy-src="https://pic.leetcode-cn.com/38567dcbb6401d88946ca974aacffb5ab27cb1ad54056f02b59016c0cc68b40f-file_1562774451350" style="zoom:70%"></p></li><li><p>回溯</p><ul><li>首先使用哈希表存储每个数字对应的所有的可能字母，然后进行回溯操作。</li><li>回溯过程中维护一个字符串，<h4 id="Python3-Code-8"><a href="#Python3-Code-8" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4></li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        dic = {<span class="string">'2'</span>:<span class="string">'abc'</span>,<span class="string">'3'</span>:<span class="string">"def"</span>,<span class="string">'4'</span>:<span class="string">"ghi"</span>,<span class="string">'5'</span>:<span class="string">"jkl"</span>,<span class="string">'6'</span>:<span class="string">"mno"</span>,<span class="string">'7'</span>:<span class="string">"pqrs"</span>,<span class="string">'8'</span>:<span class="string">"tuv"</span>,<span class="string">'9'</span>:<span class="string">"wxyz"</span>}</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(digits):</span><br><span class="line">                ans.append(<span class="string">''</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> dic[s[<span class="number">0</span>]]:</span><br><span class="line">                path.append(letter)</span><br><span class="line">                backtrack(s[<span class="number">1</span>:])</span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(digits)</span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度： $O(3^M * 4^N$。M是对应三个字母的数字的个数，N是对应是四个字母的数字个数   。</li><li>空间复杂度：$O(M+N)$。M+N是输入数字的总个数。除了返回值之外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用的层数，哈希表的大小与输入无关，可以堪称常数，递归调用层数最大为M+N。</li></ul><h4 id="大佬题解-8"><a href="#大佬题解-8" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC"><a href="#LC" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-9"><a href="#Python3-Code-9" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-9"><a href="#复杂度分析-9" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-9"><a href="#大佬题解-9" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC46-Permutations-Medium-全排列"><a href="#LC46-Permutations-Medium-全排列" class="headerlink" title="(LC46 )  Permutations (Medium)    全排列 "></a>(LC46 )  Permutations (Medium)   <a href="https://leetcode-cn.com/problems/permutations/submissions/"> 全排列 </a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><p>给定一没有重复 数字的序列，返回其所有可能的全排列<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">] </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ul><li><h4 id="Python3-Code-10"><a href="#Python3-Code-10" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="comment">#终止条件：走到树的底层</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment">#剪枝</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">in</span> path:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(num)</span><br><span class="line">                backtrack(s[<span class="number">1</span>:])</span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-10"><a href="#复杂度分析-10" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-10"><a href="#大佬题解-10" class="headerlink" title="大佬题解"></a>大佬题解</h4><ol><li>参考到大佬的一个控制台的输出，有助于理解其中的奥妙<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  递归之前 =&gt; [1]</span><br><span class="line">  递归之前 =&gt; [1, 2]</span><br><span class="line">  递归之前 =&gt; [1, 2, 3]</span><br><span class="line">递归之后 =&gt; [1, 2]</span><br><span class="line">递归之后 =&gt; [1]</span><br><span class="line">  递归之前 =&gt; [1, 3]</span><br><span class="line">  递归之前 =&gt; [1, 3, 2]</span><br><span class="line">递归之后 =&gt; [1, 3]</span><br><span class="line">递归之后 =&gt; [1]</span><br><span class="line">递归之后 =&gt; []</span><br><span class="line">  递归之前 =&gt; [2]</span><br><span class="line">  递归之前 =&gt; [2, 1]</span><br><span class="line">  递归之前 =&gt; [2, 1, 3]</span><br><span class="line">递归之后 =&gt; [2, 1]</span><br><span class="line">递归之后 =&gt; [2]</span><br><span class="line">  递归之前 =&gt; [2, 3]</span><br><span class="line">  递归之前 =&gt; [2, 3, 1]</span><br><span class="line">递归之后 =&gt; [2, 3]</span><br><span class="line">递归之后 =&gt; [2]</span><br><span class="line">递归之后 =&gt; []</span><br><span class="line">  递归之前 =&gt; [3]</span><br><span class="line">  递归之前 =&gt; [3, 1]</span><br><span class="line">  递归之前 =&gt; [3, 1, 2]</span><br><span class="line">递归之后 =&gt; [3, 1]</span><br><span class="line">递归之后 =&gt; [3]</span><br><span class="line">  递归之前 =&gt; [3, 2]</span><br><span class="line">  递归之前 =&gt; [3, 2, 1]</span><br><span class="line">递归之后 =&gt; [3, 2]</span><br><span class="line">递归之后 =&gt; [3]</span><br><span class="line">递归之后 =&gt; []</span><br><span class="line">输出 =&gt; [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] </span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="LC47-全排列II-全排列II"><a href="#LC47-全排列II-全排列II" class="headerlink" title="(LC47 )全排列II    全排列II"></a>(LC47 )全排列II    <a href="https://leetcode-cn.com/problems/permutations-ii/description/">全排列II</a></h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>给定一个可包含重复数字的序列 <code>nums</code>，按任意顺序返回所有不重复的全排列。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></tbody></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-11"><a href="#Python3-Code-11" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans = <span class="built_in">list</span>() </span><br><span class="line">        visited = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums,visited</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">                    ans.append(path[:])</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> visited[i]: </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i]) </span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">                backtrack(nums,visited)</span><br><span class="line">                path.pop(-<span class="number">1</span>) </span><br><span class="line">                visited[i] = <span class="literal">False</span></span><br><span class="line">        backtrack(nums,visited)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-11"><a href="#复杂度分析-11" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-11"><a href="#大佬题解-11" class="headerlink" title="大佬题解"></a>大佬题解</h4><ul><li>分析 LC46 和 lc47是两种全排列，思路是一样的，就是剪枝的方式不同，一个减去的方式是重复的数，一个是重复的位置。</li></ul><h3 id="LC77-组合-组合"><a href="#LC77-组合-组合" class="headerlink" title="(LC77)组合    组合"></a>(LC77)组合    <a href="https://leetcode-cn.com/problems/combinations/description/">组合</a></h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ul><li>回溯</li></ul><h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><ul><li>itertools —- 为高效循环而创建迭代器的函数 <a href="https://docs.python.org/zh-cn/3/library/itertools.html">官方讲解</a> 感觉这个真的骚</li></ul><h4 id="Python3-Code-12"><a href="#Python3-Code-12" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        nums = [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)== k:</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> path: <span class="comment">#注意范围呀</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(path)&gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt; path[-<span class="number">1</span>]:</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrack(nums)<span class="comment">#如果是backtrack(nums[1:]) 注意for i in range(n)的范围啊</span></span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        nums = [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)== k:</span><br><span class="line">                ans.append(path[:])<span class="comment">##浅拷贝，这一步很重要</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">in</span> path: <span class="comment">#注意范围呀</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(path)&gt; <span class="number">0</span> <span class="keyword">and</span> num &lt; path[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span>                </span><br><span class="line">                path.append(num)</span><br><span class="line">                backtrack(nums[<span class="number">1</span>:])<span class="comment">#如果是backtrack(nums[1:]) 注意for i in range(n)的范围啊</span></span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(itertools.combinations(<span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>),k)) </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-12"><a href="#复杂度分析-12" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-12"><a href="#大佬题解-12" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC39-组合总和-组合总和"><a href="#LC39-组合总和-组合总和" class="headerlink" title="(LC39 )组合总和     组合总和 "></a>(LC39 )组合总和    <a href="https://leetcode-cn.com/problems/combination-sum/"> 组合总和 </a></h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">] </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-13"><a href="#Python3-Code-13" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        ans =  <span class="built_in">list</span>()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(path) == target:</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(path) &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(path)&gt;<span class="number">0</span> <span class="keyword">and</span> num &lt; path[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(num)</span><br><span class="line">                 </span><br><span class="line">                backtrack(nums)</span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        backtrack(candidates)</span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-13"><a href="#复杂度分析-13" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-13"><a href="#大佬题解-13" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC40含有相同元素的组合求和-组合总和-II"><a href="#LC40含有相同元素的组合求和-组合总和-II" class="headerlink" title="(LC40含有相同元素的组合求和 )    组合总和 II  "></a>(LC40含有相同元素的组合求和 )    <a href="https://leetcode-cn.com/problems/combination-sum-ii/description/">组合总和 II  </a></h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>给定一个数组<code>candidates</code>和一个目标数<code>target</code>，找出<code>candidates</code>中所有可以使数字和为<code>target</code>的组合。<code>candidates</code>中的每个数字在每个组合中只能使用一次。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">] </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><ul><li><p>dfs<br>四种情况：<br>· 1. 排列有序，可重复：<br>· 2. 排列有序，不可重复：used（i&gt;0 and candidates[i]==candidates[i-1] and not ·used[i-1]）：去除排列重复<br>· 3. 组合没有序，可重复：start<br>· 4. 组合没有序，不可重复：start+1（+1去除组合重复）已经说明used【i-1】一定不会用上，因此不用used（i&gt;start and candidates[i]==candidates[i-1]）即可 </p></li><li><p>回溯</p></li></ul><h4 id="Python3-Code-14"><a href="#Python3-Code-14" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>  <span class="comment">#DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">target,path,start</span>):</span> <span class="comment">#DFS</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; min_cand:</span><br><span class="line">                <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                    res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                target_new = target - candidates[i]</span><br><span class="line">                path_new = path + [candidates[i]]</span><br><span class="line">                <span class="comment">#i+1 删除重复组合</span></span><br><span class="line">                dfs(target_new,path_new,i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        candidates.sort()</span><br><span class="line">        min_cand = <span class="built_in">min</span>(candidates)</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        dfs(target, path , start)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Backtracking </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">begin, path, residue</span>):</span></span><br><span class="line">            <span class="keyword">if</span> residue == <span class="number">0</span>:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(begin, size):</span><br><span class="line">                <span class="keyword">if</span> candidates[index] &gt; residue:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> index &gt; begin <span class="keyword">and</span> candidates[index - <span class="number">1</span>] == candidates[index]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(candidates[index])</span><br><span class="line">                backtrack(index + <span class="number">1</span>, path, residue - candidates[index])</span><br><span class="line">                path.pop()</span><br><span class="line">        size = <span class="built_in">len</span>(candidates)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="number">0</span>, [], target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-14"><a href="#复杂度分析-14" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-14"><a href="#大佬题解-14" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC216-1-9-数字的组合求和-组合总和-III"><a href="#LC216-1-9-数字的组合求和-组合总和-III" class="headerlink" title="(LC216)1-9 数字的组合求和    组合总和 III  "></a>(LC216)1-9 数字的组合求和    <a href="https://leetcode-cn.com/problems/combination-sum-iii/">组合总和 III  </a></h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><p>找出所有相加之和为<code>n</code> 的<code>k</code>个数的组合。组合中只允许含有 1-9的正整数，并且每种组合中不存在重复的数字。<br>说明：<br>所有数字都是正整数。解集不能包含重复的组合。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-15"><a href="#Python3-Code-15" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">begin, path, residue</span>):</span></span><br><span class="line">            <span class="keyword">if</span> residue == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(path)== k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(begin, size):</span><br><span class="line">                <span class="keyword">if</span> nums[index] &gt; residue:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                path.append(nums[index])</span><br><span class="line">                backtrack(index+<span class="number">1</span>, path,residue - nums[index])</span><br><span class="line">                path.pop()</span><br><span class="line">        size = <span class="number">9</span></span><br><span class="line">        nums = [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        backtrack(<span class="number">0</span>, [],n)</span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-15"><a href="#复杂度分析-15" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-15"><a href="#大佬题解-15" class="headerlink" title="大佬题解"></a>大佬题解</h4><ol><li><a href="https://leetcode-cn.com/problems/combination-sum-iii/solution/hui-su-jian-zhi-by-liweiwei1419/">回溯 + 剪枝（Java）</a></li></ol><h3 id="LC78-子集-子集"><a href="#LC78-子集-子集" class="headerlink" title="(LC78 )  子集    子集"></a>(LC78 )  子集   <a href="https://leetcode-cn.com/problems/subsets/description/"> 子集</a></h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 互不相同。返回该数组所有可能的子集（幂集）。<br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></tbody></table></figure><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-16"><a href="#Python3-Code-16" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start,path,size</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == size:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(nums)):</span><br><span class="line">                print(path)</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, path, size)</span><br><span class="line">                path.pop( )</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>( <span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">            backtrack(<span class="number">0</span>,[],n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-16"><a href="#复杂度分析-16" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-16"><a href="#大佬题解-16" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC90含有相同元素求子集-子集-II"><a href="#LC90含有相同元素求子集-子集-II" class="headerlink" title="(LC90含有相同元素求子集 )    子集 II"></a>(LC90含有相同元素求子集 )    <a href="https://leetcode-cn.com/problems/subsets-ii/description/">子集 II</a></h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-17"><a href="#Python3-Code-17" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">begin,path,size</span>):</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == size:</span><br><span class="line">                <span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    res.append(path[:])</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin,<span class="built_in">len</span>(nums)):</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, path, size)</span><br><span class="line">                path.pop(-<span class="number">1</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">            backtrack(<span class="number">0</span>, [], n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-17"><a href="#复杂度分析-17" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-17"><a href="#大佬题解-17" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC131-分割回文串-分割回文串"><a href="#LC131-分割回文串-分割回文串" class="headerlink" title="(LC131)  分割回文串  分割回文串"></a>(LC131)  分割回文串  <a href="https://leetcode-cn.com/problems/palindrome-partitioning/description/">分割回文串</a></h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串 。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "aab"</span><br><span class="line">输出：[["a","a","b"],["aa","b"]]</span><br></pre></td></tr></tbody></table></figure><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-18"><a href="#Python3-Code-18" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ispalindrome</span>(<span class="params">word,left,right</span>):</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> word[left] !=  word[right]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start,path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="built_in">len</span>(s):</span><br><span class="line">                res.append(path[:]) </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> ispalindrome(s, start,i):</span><br><span class="line">                    print(s[start:i+<span class="number">1</span>])</span><br><span class="line">                    path.append(s[start:i+<span class="number">1</span>])</span><br><span class="line">                    backtrack(i+<span class="number">1</span>, path)</span><br><span class="line">                    path.pop()</span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-18"><a href="#复杂度分析-18" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-18"><a href="#大佬题解-18" class="headerlink" title="大佬题解"></a>大佬题解</h4><ol><li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-fa-si-lu-yu-mo-ban-by-fuxuemingzh-azhz/">复制和不复制path</a></li></ol><h3 id="LC-1"><a href="#LC-1" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-19"><a href="#Python3-Code-19" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-19"><a href="#复杂度分析-19" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-19"><a href="#大佬题解-19" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-2"><a href="#LC-2" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-20"><a href="#Python3-Code-20" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-20"><a href="#复杂度分析-20" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-20"><a href="#大佬题解-20" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-3"><a href="#LC-3" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-21"><a href="#Python3-Code-21" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-21"><a href="#复杂度分析-21" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-21"><a href="#大佬题解-21" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-4"><a href="#LC-4" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-22"><a href="#Python3-Code-22" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-22"><a href="#复杂度分析-22" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-22"><a href="#大佬题解-22" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;搜索（BFS-DFS-Backtracking）&quot;&gt;&lt;a href=&quot;#搜索（BFS-DFS-Backtracking）&quot; class=&quot;headerlink&quot; title=&quot;搜索（BFS, DFS, Backtracking）&quot;&gt;&lt;/a&gt;搜索（BFS, DFS, Backtracking）&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;广度优先算法（Breadth-First-Search），简称BFS。深度优先算法（Deep-First-Search），简称DFS。BFS:利用队列先进先出的特性，可以优先遍历横向节点。DFS:利用栈先进后出的特性，可以优先遍历纵向节点。&lt;/p&gt;
&lt;h2 id=&quot;搜索&quot;&gt;&lt;a href=&quot;#搜索&quot; class=&quot;headerlink&quot; title=&quot;搜索&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md&quot;&gt;搜索&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;深度优先搜索和广度优先搜索广泛应用于树和图中。 （1） BFS  (2) DFS  (3) Backtracking&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode竞赛(第234场周赛)</title>
    <link href="http://watermelondrip.github.io/2021/03/28/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B234/"/>
    <id>http://watermelondrip.github.io/2021/03/28/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B234/</id>
    <published>2021-03-27T13:00:00.000Z</published>
    <updated>2021-03-29T01:06:51.527Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>排名：  2809 / 4996<br><span id="more"></span></p><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>(5713. <a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/)https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/)https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/</a>]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 word ，该字符串由数字和小写英文字母组成。</p><p>请你用空格替换每个不是数字的字符。例如，”a123bc34d8ef34” 将会变成 “ 123  34 8  34” 。注意，剩下的这些整数间至少要用一个空格隔开：”123”、”34”、”8” 和 “34” 。</p><p>返回对 word 完成替换后形成的 不同 整数的数目。</p><p>如果两个整数的 不含前导零 的十进制表示不同，则认为这两个整数也不同。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "a123bc34d8ef34"</span><br><span class="line">输出：3</span><br><span class="line">解释：不同的整数有 "123"、"34" 和 "8" 。注意，"34" 只计数一次。</span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDifferentIntegers</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> ch.isdigit():</span><br><span class="line">                arr.append(ch)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr.append(<span class="string">' '</span>)</span><br><span class="line">        s = <span class="string">''</span>.join(arr)</span><br><span class="line">        arr = s.split(<span class="string">' '</span>)</span><br><span class="line">        ss = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(num) &gt; <span class="number">0</span>:</span><br><span class="line">                ss.add(<span class="built_in">int</span>(num))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(ss)</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="2-题目"><a href="#2-题目" class="headerlink" title="2. 题目"></a>2. 题目</h1><p>(5715. 还原排列的最少操作步数)[<a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/</a>]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 0 开始 计数）。</p><p>一步操作中，你将创建一个新数组 arr ，对于每个 i ：</p><p>如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]<br>如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]<br>然后将 arr​​ 赋值​​给 perm 。</p><p>要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：最初，perm = [0,1]</span><br><span class="line">第 1 步操作后，perm = [0,1]</span><br><span class="line">所以，仅需执行 1 步操作</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reinitializePermutation</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        perm = [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        org =  [ _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line">        </span><br><span class="line">        arr = [<span class="number">0</span>]*n</span><br><span class="line">        <span class="keyword">while</span> arr != org:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    arr[i] = perm[<span class="built_in">int</span>(i //<span class="number">2</span>)]</span><br><span class="line">                  </span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    arr[i] = perm[<span class="built_in">int</span>(n // <span class="number">2</span>) + <span class="built_in">int</span>((i - <span class="number">1</span>) // <span class="number">2</span>)]</span><br><span class="line">                    </span><br><span class="line">            result+=<span class="number">1</span></span><br><span class="line">            perm = arr[:]</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="3-题目"><a href="#3-题目" class="headerlink" title="3. 题目"></a>3. 题目</h1><p>(5714. 替换字符串中的括号内容)[<a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/</a>]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。</p><p>比方说，字符串 “(name)is(age)yearsold” 中，有 两个 括号对，分别包含键 “name” 和 “age” 。<br>你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。</p><p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p><p>将 keyi 和括号用对应的值 valuei 替换。<br>如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 “?” 替换（不需要引号）。<br>knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。</p><p>请你返回替换 所有 括号对后的结果字符串。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "(name)is(age)yearsold", knowledge = [["name","bob"],["age","two"]]</span><br><span class="line">输出："bobistwoyearsold"</span><br><span class="line">解释：</span><br><span class="line">键 "name" 对应的值为 "bob" ，所以将 "(name)" 替换为 "bob" 。</span><br><span class="line">键 "age" 对应的值为 "two" ，所以将 "(age)" 替换为 "two" 。 </span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>字典存储记住呀 （<code>d = {k: v for k, v in knowledge}</code>）</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">self, s: <span class="built_in">str</span>, knowledge: List[List[<span class="built_in">str</span>]]</span>) -&gt; str:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">1</span></span><br><span class="line">        d = {k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> knowledge}</span><br><span class="line">        result = <span class="built_in">str</span>()</span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                left = i</span><br><span class="line">                a = <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                right = i</span><br><span class="line">                key_know = s[left+<span class="number">1</span>:right]</span><br><span class="line">                </span><br><span class="line">                find = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> key_know <span class="keyword">in</span> d:</span><br><span class="line">                    result+=d[key_know]</span><br><span class="line">                    find = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> find == <span class="number">0</span>:</span><br><span class="line">                    result+=<span class="string">'?'</span></span><br><span class="line">                a = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">                    result+= s[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="4-题目"><a href="#4-题目" class="headerlink" title="4. 题目"></a>4. 题目</h1><p>(5716. 好因子的最大数目)[<a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/</a>]</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数 primeFactors 。你需要构造一个正整数 n ，它满足以下条件：</p><p>n 质因数（质因数需要考虑重复的情况）的数目 不超过 primeFactors 个。<br>n 好因子的数目最大化。如果 n 的一个因子可以被 n 的每一个质因数整除，我们称这个因子是 好因子 。比方说，如果 n = 12 ，那么它的质因数为 [2,2,3] ，那么 6 和 12 是好因子，但 3 和 4 不是。<br>请你返回 n 的好因子的数目。由于答案可能会很大，请返回答案对 109 + 7 取余 的结果。</p><p>请注意，一个质数的定义是大于 1 ，且不能被分解为两个小于该数的自然数相乘。一个数 n 的质因子是将 n 分解为若干个质因子，且它们的乘积为 n </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：primeFactors = 5</span><br><span class="line">输出：6</span><br><span class="line">解释：200 是一个可行的 n 。</span><br><span class="line">它有 5 个质因子：[2,2,2,5,5] ，且有 6 个好因子：[10,20,40,50,100,200] 。</span><br><span class="line">不存在别的 n 有至多 5 个质因子，且同时有更多的好因子。 </span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p>以下数学推导总体分为两步：（1) 当所有拆分出的数字相等时，乘积最大。(2)最优拆分数字为3。<a href="https://leetcode-cn.com/problems/integer-break/solution/343-zheng-shu-chai-fen-tan-xin-by-jyd/">戳一戳</a></p></li><li><p>拆分规则：<br>最优： 3。把数字 n 可能拆为多个因子 3 ，余数可能为0,1,2 三种情况。<br>次优： 2。若余数为 2 ；则保留，不再拆为 1+1 。<br>最差： 1 。若余数为 1 ；则应把一份 3+1 替换为2+2，因为 2 <em>2 &gt; 3 </em>1 </p></li><li><p>数学模型<br>已知:</p></li></ul><p>a1, a2, a3, …… an 是质数<br>a1^b1 + a2^b2 + …… + an^bn = sum;<br>b1 + b2 + …… + bn = n; 其中n已知<br>求：</p><p>好因子个数，比如有 3 个 2， 2 个 5，那么好因子个数就相当于在 3个2 里取出3种情况(1个2， 2个2， 3个2)，在 2个5 里取出2种情况(1个5，2个5)，相乘即可，即好因子个数 = 3 <em> 2 = 6<br>上面这种算法其实就是 好因子个数 = b1 </em> b2 <em> …… </em> bn 的最大值<br>那么求好因子个数的最大值就是求：</p><p>已知 b1 + b2 + …… + bn = n<br>求 b1 <em> b2 </em> …… * bn 的最大值</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNiceDivisors</span>(<span class="params">self, primeFactors: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> primeFactors &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> primeFactors </span><br><span class="line"></span><br><span class="line">        a,b = primeFactors//<span class="number">3</span>, primeFactors%<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>: </span><br><span class="line">            result = <span class="built_in">pow</span>(<span class="number">3</span>,a,<span class="number">1000000007</span>) </span><br><span class="line">        <span class="keyword">elif</span> b ==<span class="number">1</span>:</span><br><span class="line">            result = (<span class="built_in">pow</span>(<span class="number">3</span>,a-<span class="number">1</span>,<span class="number">1000000007</span>)*<span class="number">4</span>)   </span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">2</span>:</span><br><span class="line">            result =  (<span class="built_in">pow</span>(<span class="number">3</span>,a,<span class="number">1000000007</span>)*<span class="number">2</span>)  </span><br><span class="line">        <span class="keyword">return</span> result%<span class="number">1000000007</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O( )$  </li><li>空间复杂度：$O( )$  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;排名：  2809 / 4996&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>堆heapq模块</title>
    <link href="http://watermelondrip.github.io/2021/03/21/%E5%A0%86heapq%E6%A8%A1%E5%9D%97/"/>
    <id>http://watermelondrip.github.io/2021/03/21/%E5%A0%86heapq%E6%A8%A1%E5%9D%97/</id>
    <published>2021-03-20T22:47:00.000Z</published>
    <updated>2021-03-20T22:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="堆heapq模块"><a href="#堆heapq模块" class="headerlink" title="堆heapq模块"></a>堆heapq模块</h1><hr><hr><p>这个模块提供了堆队列算法的实现，也成为优先队列算法。<br>堆是一个二叉树，它的每个父节点的值都只会小于或等于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的<code>k</code>，都有<code>heap[k] &lt;= heap[2*k+1]</code>和<code>heap[k] &lt;= heap[2*k+2]</code>。为了便于笔记，不存在的元素被认为是无限大。堆最有趣的特性在于最小的元素总是在根结点：heap[0]。</p><span id="more"></span><p>这个API与教材的对算法实现有所不同，具体区别有两方面：（a）我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为Python使用从零开始的索引。（b) 我们的pop方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。<br>基于这两个方面，把堆看作原生的Python List也没有什么奇怪的：<code>heap[0]</code>表示最小的元素，同时<code>heap.sort()</code>维护了堆的不变性。<br>要创造一个堆，可以使用list来初始化为<code>[]</code>，或者你也可以通过一个函数<code>heapify()</code>，来把一个list转换成堆。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="heapq-headpush-heap-item"><a href="#heapq-headpush-heap-item" class="headerlink" title="heapq.headpush(heap,item)"></a>heapq.headpush(heap,item)</h2><p>将<code>item</code>的值加入<code>heap</code>中，保持堆的不变性。</p><h2 id="heapq-headpop-heap"><a href="#heapq-headpop-heap" class="headerlink" title="heapq.headpop(heap)"></a>heapq.headpop(heap)</h2><p>弹出并返回<code>heap</code>的最小的元素，保持堆的不变性。如果堆为空，抛出<code>IndexError</code>。使用<code>heap[0]</code>，可以只访问最小的元素而不弹出它。</p><h2 id="heapq-headpop-heap-item"><a href="#heapq-headpop-heap-item" class="headerlink" title="heapq.headpop(heap,item)"></a>heapq.headpop(heap,item)</h2><p>将<code>item</code>放入堆中，然后弹出并返回<code>heap</code>的最小元素。该组合操作比先调用<code>heappush()</code>再调用<code>heappop()</code>运行起来更有效率。</p><h2 id="heapq-heapify-x"><a href="#heapq-heapify-x" class="headerlink" title="heapq.heapify(x)"></a>heapq.heapify(x)</h2><p>将list <code>x</code>转换成堆，原地，线性时间内。</p><h2 id="heapq-heapreplace-heap-item"><a href="#heapq-heapreplace-heap-item" class="headerlink" title="heapq.heapreplace(heap,item)"></a>heapq.heapreplace(heap,item)</h2><p>弹出并返回<code>heap</code>中最小的一项，同时推入新的<code>item</code>。堆的大小不变。如果堆为空则引发<code>IndexError</code>。这个单步骤操作比<code>heappop()</code>加<code>heappush()</code>更高效，并且在使用固定大小的堆时更为适宜。 <code>pop</code>/<code>push</code> 组合总是会从堆中返回一个元素并将其替换为 <code>item</code>。<br>返回的值可能会比添加的 item 更大。 如果不希望如此，可考虑改用 <code>heappushpop()</code>。 它的 <code>push/pop</code> 组合会返回两个值中较小的一个，将较大的值留在堆中。</p><h1 id="创建堆"><a href="#创建堆" class="headerlink" title="创建堆"></a>创建堆</h1><ul><li>heapq有两种方式创建堆，一种是使用一个空列表，然后使用<code>heapq.heappush()</code>函数把值加入堆中，另外一种就是使用<code>heap.heapify(list)</code>转换列表成为堆结构。</li></ul><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数定义：</span></span><br><span class="line"><span class="string">heapq.heappush(heap,item)</span></span><br><span class="line"><span class="string">    - push the value item onto the heap, maintaining the heap invariant</span></span><br><span class="line"><span class="string">heapq.heappop(heap)</span></span><br><span class="line"><span class="string">    - pop and return the smallest item from the heap, maintaining the heap invariant</span></span><br><span class="line"><span class="string">    If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    heapq.heappush(heap,num) <span class="comment">#加入堆</span></span><br><span class="line"></span><br><span class="line">print(heap[<span class="number">0</span>])  <span class="comment"># 如果只是想获取最小值而不是弹出，使用heap[0]</span></span><br><span class="line">print([heapq.heappop(heap) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))])  <span class="comment"># 堆排序结果</span></span><br><span class="line"><span class="comment"># out: [1, 2, 3, 5, 23, 54, 132]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line">print([heapq.heappop(nums) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))])  <span class="comment"># 堆排序结果</span></span><br><span class="line"><span class="comment"># out: [1, 2, 3, 5, 23, 54, 132]</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>heapq</code> 模块还有一个<code>heapq.merge(*iterables)</code> 方法，用于合并多个排序后的序列成一个排序后的序列， 返回排序后的值的迭代器。类似于<code>sorted(itertools.chain(*iterables))</code>，但返回的是可迭代的。</li></ul><h2 id="基本示例-1"><a href="#基本示例-1" class="headerlink" title="基本示例"></a>基本示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数定义：</span></span><br><span class="line"><span class="string">heapq.merge(*iterables)</span></span><br><span class="line"><span class="string">    - Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values.</span></span><br><span class="line"><span class="string">    - Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest).</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">num1 = [<span class="number">32</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">num2 = [<span class="number">23</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">656</span>, <span class="number">324</span>, <span class="number">23</span>, <span class="number">54</span>]</span><br><span class="line">num1 = <span class="built_in">sorted</span>(num1)</span><br><span class="line">num2 = <span class="built_in">sorted</span>(num2)</span><br><span class="line"></span><br><span class="line">res = heapq.merge(num1, num2)</span><br><span class="line">print(<span class="built_in">list</span>(res))</span><br></pre></td></tr></tbody></table></figure><h1 id="访问堆内容"><a href="#访问堆内容" class="headerlink" title="访问堆内容"></a>访问堆内容</h1><ul><li>堆创建好后，可以通过<code>heapq.heappop()</code> 函数弹出堆中最小值。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">43</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">12</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line"></span><br><span class="line">print(heapq.heappop(nums))</span><br><span class="line"><span class="comment"># out: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要所有堆排序后的元素</span></span><br><span class="line">result = [heapq.heappop(nums) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># out: [12, 23, 43, 45]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要删除堆中最小元素并加入一个元素，可以使用<code>heapq.heaprepalce()</code> 函数</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line">heapq.heapreplace(nums, <span class="number">23</span>)</span><br><span class="line">print([heapq.heappop(nums) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))])</span><br><span class="line"><span class="comment"># out: [2, 3, 4, 5, 23]</span></span><br></pre></td></tr></tbody></table></figure><h1 id="获取堆最大或最小值"><a href="#获取堆最大或最小值" class="headerlink" title="获取堆最大或最小值"></a>获取堆最大或最小值</h1><ul><li>如果需要获取堆中最大或最小的范围值，则可以使用<code>heapq.nlargest()</code> 或<code>heapq.nsmallest()</code> 函数</li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数定义：</span></span><br><span class="line"><span class="string">heapq.nlargest(n, iterable[, key])¶</span></span><br><span class="line"><span class="string">    - Return a list with the n largest elements from the dataset defined by iterable. </span></span><br><span class="line"><span class="string">    - key if provided, specifies a function of one argument that is used to extract a comparison key from each element in the iterable: key=str.lower</span></span><br><span class="line"><span class="string">    - Equivalent to: sorted(iterable, key=key, reverse=True)[:n]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums))</span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">[5, 4, 3]</span></span><br><span class="line"><span class="string">[1, 2, 3]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure><ul><li>这两个函数还接受一个key参数，用于dict或其他数据结构类型使用</li></ul><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import heapq</span><br><span class="line">from pprint import pprint #美化打印 </span><br><span class="line">portfolio = [</span><br><span class="line">    {'name': 'IBM', 'shares': 100, 'price': 91.1},</span><br><span class="line">    {'name': 'AAPL', 'shares': 50, 'price': 543.22},</span><br><span class="line">    {'name': 'FB', 'shares': 200, 'price': 21.09},</span><br><span class="line">    {'name': 'HPQ', 'shares': 35, 'price': 31.75},</span><br><span class="line">    {'name': 'YHOO', 'shares': 45, 'price': 16.35},</span><br><span class="line">    {'name': 'ACME', 'shares': 75, 'price': 115.65}</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])</span><br><span class="line">expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])</span><br><span class="line">pprint(cheap)</span><br><span class="line">pprint(expensive)</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">输出：</span><br><span class="line">[{'name': 'YHOO', 'price': 16.35, 'shares': 45},</span><br><span class="line"> {'name': 'FB', 'price': 21.09, 'shares': 200},</span><br><span class="line"> {'name': 'HPQ', 'price': 31.75, 'shares': 35}]</span><br><span class="line">[{'name': 'AAPL', 'price': 543.22, 'shares': 50},</span><br><span class="line"> {'name': 'ACME', 'price': 115.65, 'shares': 75},</span><br><span class="line"> {'name': 'IBM', 'price': 91.1, 'shares': 100}]</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><h1 id="heapq-应用"><a href="#heapq-应用" class="headerlink" title="heapq 应用"></a>heapq 应用</h1><ul><li>实现heap堆排序算法, 该算法和sorted(iterable) 类似，但是它是不稳定的。</li></ul><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">iterable</span>):</span></span><br><span class="line"><span class="meta">... </span>    h = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line"><span class="meta">... </span>        heappush(h, value)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(h))]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapsort([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>])</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>堆的值可以是元组类型，可以实现对带权值的元素进行排序。</li></ul><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">5</span>, <span class="string">'write code'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">7</span>, <span class="string">'release product'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">1</span>, <span class="string">'write spec'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">3</span>, <span class="string">'create tests'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappop(h)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'write spec'</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;堆heapq模块&quot;&gt;&lt;a href=&quot;#堆heapq模块&quot; class=&quot;headerlink&quot; title=&quot;堆heapq模块&quot;&gt;&lt;/a&gt;堆heapq模块&lt;/h1&gt;&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;这个模块提供了堆队列算法的实现，也成为优先队列算法。&lt;br&gt;堆是一个二叉树，它的每个父节点的值都只会小于或等于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的&lt;code&gt;k&lt;/code&gt;，都有&lt;code&gt;heap[k] &amp;lt;= heap[2*k+1]&lt;/code&gt;和&lt;code&gt;heap[k] &amp;lt;= heap[2*k+2]&lt;/code&gt;。为了便于笔记，不存在的元素被认为是无限大。堆最有趣的特性在于最小的元素总是在根结点：heap[0]。&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode竞赛(第233场周赛)</title>
    <link href="http://watermelondrip.github.io/2021/03/21/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B233/"/>
    <id>http://watermelondrip.github.io/2021/03/21/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B233/</id>
    <published>2021-03-20T13:00:00.000Z</published>
    <updated>2021-03-21T09:52:47.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>排名：  2547 / 5009<br><span id="more"></span></p><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>(5709. 最大升序子数组和)[<a href="https://leetcode-cn.com/contest/weekly-contest-233/problems/maximum-ascending-subarray-sum/">https://leetcode-cn.com/contest/weekly-contest-233/problems/maximum-ascending-subarray-sum/</a>]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。子数组是数组中的一个连续数字序列。<br>已知子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，若对所有<code>i（l &lt;= i &lt; r）</code>，<code>numsi &lt; numsi+1</code> 都成立，则称这一子数组为升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,20,30,5,10,50]</span><br><span class="line">输出：65</span><br><span class="line">解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。</span><br></pre></td></tr></tbody></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAscendingSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">         </span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                ans+= nums[i]</span><br><span class="line">                result = <span class="built_in">max</span>(result,ans)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = <span class="built_in">max</span>(result,ans)</span><br><span class="line">                ans = nums[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$ 遍历一遍</li><li>空间复杂度：$O(1)$  </li></ul><h1 id="2-题目"><a href="#2-题目" class="headerlink" title="2. 题目"></a>2. 题目</h1><p>(5710. 积压订单中的订单总数)[<a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/">https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/</a>]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>太长了，自己点连接看，谢谢~</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-堆知识点"><a href="#1-堆知识点" class="headerlink" title="1. 堆知识点"></a>1. 堆知识点</h3><p>引用一下堆的那个文章 </p><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNumberOfBacklogOrders</span>(<span class="params">self, orders: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        sell_minHeap = []</span><br><span class="line">        buy_maxHeap = []</span><br><span class="line">        heapq.heapify(sell_minHeap)</span><br><span class="line">        heapq.heapify(buy_maxHeap)</span><br><span class="line">        <span class="keyword">for</span> price, cnt , t <span class="keyword">in</span> orders:</span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span>:  <span class="comment">#买，就找最小的sell</span></span><br><span class="line">                <span class="keyword">while</span> cnt &gt; <span class="number">0</span> <span class="keyword">and</span>  sell_minHeap <span class="keyword">and</span> sell_minHeap[<span class="number">0</span>][<span class="number">0</span>] &lt;= price:    <span class="comment">#sell的价格小。能买到</span></span><br><span class="line">                    <span class="keyword">if</span> cnt &gt; sell_minHeap[<span class="number">0</span>][<span class="number">1</span>]:    <span class="comment">#买很多</span></span><br><span class="line">                        cnt -= sell_minHeap[<span class="number">0</span>][<span class="number">1</span>]   <span class="comment">#最小售价的买了</span></span><br><span class="line">                        heapq.heappop(sell_minHeap)</span><br><span class="line">                    <span class="keyword">elif</span> cnt == sell_minHeap[<span class="number">0</span>][<span class="number">1</span>]: <span class="comment">#刚好买了</span></span><br><span class="line">                        cnt = <span class="number">0</span></span><br><span class="line">                        heapq.heappop(sell_minHeap)</span><br><span class="line">                    <span class="keyword">elif</span> cnt &lt; sell_minHeap[<span class="number">0</span>][<span class="number">1</span>]:  <span class="comment">#买完，堆里还能剩下</span></span><br><span class="line">                        tmp = sell_minHeap[<span class="number">0</span>][<span class="number">1</span>] - cnt</span><br><span class="line">                        cnt = <span class="number">0</span></span><br><span class="line">                        new_ = [sell_minHeap[<span class="number">0</span>][<span class="number">0</span>], tmp]</span><br><span class="line">                        heapq.heappop(sell_minHeap)</span><br><span class="line">                        heapq.heappush(sell_minHeap, new_)</span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">                    heapq.heappush(buy_maxHeap, [(-<span class="number">1</span>)*price, cnt])</span><br><span class="line">            <span class="keyword">else</span>:       <span class="comment">#卖，找价格最高的buy </span></span><br><span class="line">                <span class="keyword">while</span> cnt &gt; <span class="number">0</span> <span class="keyword">and</span> buy_maxHeap <span class="keyword">and</span> (-<span class="number">1</span>)*buy_maxHeap[<span class="number">0</span>][<span class="number">0</span>] &gt;= price:</span><br><span class="line">                    <span class="keyword">if</span> cnt &gt; buy_maxHeap[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">                        cnt -= buy_maxHeap[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">                        heapq.heappop(buy_maxHeap)</span><br><span class="line">                    <span class="keyword">elif</span> cnt == buy_maxHeap[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">                        cnt = <span class="number">0</span></span><br><span class="line">                        heapq.heappop(buy_maxHeap)</span><br><span class="line">                    <span class="keyword">elif</span> cnt &lt; buy_maxHeap[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">                        tmp = buy_maxHeap[<span class="number">0</span>][<span class="number">1</span>] - cnt</span><br><span class="line">                        cnt = <span class="number">0</span></span><br><span class="line">                        new_ = [buy_maxHeap[<span class="number">0</span>][<span class="number">0</span>], tmp]</span><br><span class="line">                        heapq.heappop(buy_maxHeap)</span><br><span class="line">                        heapq.heappush(buy_maxHeap, new_)</span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">                    heapq.heappush(sell_minHeap, [price, cnt])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> sell_minHeap:</span><br><span class="line">            res += sell_minHeap[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            res %= <span class="number">1000000007</span></span><br><span class="line">            heapq.heappop(sell_minHeap)</span><br><span class="line">        <span class="keyword">while</span> buy_maxHeap:</span><br><span class="line">            res += buy_maxHeap[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            res %= <span class="number">1000000007</span></span><br><span class="line">            heapq.heappop(buy_maxHeap)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(nlogn)$ 堆排序</li><li>空间复杂度：$O(1)$  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;排名：  2547 / 5009&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://watermelondrip.github.io/2021/03/20/%E9%93%BE%E8%A1%A8/"/>
    <id>http://watermelondrip.github.io/2021/03/20/%E9%93%BE%E8%A1%A8/</id>
    <published>2021-03-20T09:07:53.852Z</published>
    <updated>2021-03-25T00:33:01.497Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>链表<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md#7-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C">刷题顺序</a></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><ul><li>Important notice: 涉及到链表的操作，一定要在纸上把过程先画出来，再写程序！不要断链子。</li></ul><span id="more"></span><ul><li>注意<a href="https://zhuanlan.zhihu.com/p/53691100">防止锻链</a>，因为一旦把节点的指针反向了，当前的指针就不再指向下一个节点了，因为也就i不能再继续往后遍历了，也就不能把这个完整的链表进行反转了，这种情况称作断链。为了解决断链的情况，我们就需要再节点指针反向之前，就把当前节点的下一个节点先记下来，等到当前节点的指针完成反转之后，遍历指针直接移动到刚刚被记住的那个节点，这样就能防止锻炼的情况了。具体操作如下：<a href="https://zhuanlan.zhihu.com/p/53691100">讲解1</a></li><li></li><li>注意：我们经常需要定义一个哨兵节点<code>prehead</code>，这可以在最后让我们比较容易地返回合并后的链表。</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol><li>双指针：</li><li>栈：</li></ol><!-- more --><h2 id="1-LC160-相交链表-相交链表"><a href="#1-LC160-相交链表-相交链表" class="headerlink" title="1. (LC160) 相交链表 相交链表"></a>1. (LC160) 相交链表 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">相交链表</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>图解</li></ol><p><img src= "/img/watermelon.gif" data-lazy-src="https://pic.leetcode-cn.com/1614527163-BKaiqs-Picture1.png" alt=""></p><ol><li>数学思维</li></ol><ul><li>我们假设<code>A</code>的头节点到交汇点的距离为<code>a</code>， <code>B</code>的头节点到交汇点的距离为<code>b</code>，交会点最后的距离为<code>c</code>。</li><li><code>A</code>指针<code>cur_A</code>总共走了<code>a+b-c</code>步，<code>B</code>指针<code>cur_B</code>总共走了<code>b+a-c</code>步，所以会两个指针相同，达到终止条件。当没有交点的时候，<code>A</code>指针<code>cur_A</code>总共走了<code>a+b</code>步，<code>B</code>指针<code>cur_B</code>总共走了<code>b+a</code>步，也会两个指针相同指向null，达到终止条件。</li></ul><ol><li>思路总结</li></ol><ul><li>链表来说，首先是先动手走一走，再一个如果碰到交点问题，要看看怎么才能得到一个等式。</li></ul><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span>  <span class="comment">#双指针</span></span><br><span class="line">        cur_A = headA</span><br><span class="line">        cur_B = headB</span><br><span class="line">        <span class="keyword">while</span> cur_A != cur_B:</span><br><span class="line">            cur_A = cur_A.<span class="built_in">next</span> <span class="keyword">if</span> cur_A <span class="keyword">else</span> headB</span><br><span class="line">            cur_B = cur_B.<span class="built_in">next</span> <span class="keyword">if</span> cur_B <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> cur_A</span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n+m)$ n是链表A的长度，m是链表B的长度  </li><li>空间复杂度：$O(1)$  </li></ul><h2 id="2-LC2206-反转链表-反转链表"><a href="#2-LC2206-反转链表-反转链表" class="headerlink" title="2. (LC2206) 反转链表 反转链表"></a>2. (LC2206) 反转链表 <a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>反转一个单链表。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>双指针：为了防止断链子，要保持下一个节点<code>temp</code>和前一个节点<code>pre</code></li><li>递归：和双指针是一样的逻辑，同样是当<code>cur</code>为空的时候循环结束，不断将<code>cur</code>指向<code>pre</code>的过程。递归的这个好绕啊，第一遍没太理解，先记下来吧。一个很好的解释，慢慢理解，<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">戳这里</a></li><li>栈：最简单的一种方式就是使用栈，因为栈是先进后出的，实现原理是把链表点一个个入栈，当全部入栈之后在一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。</li></ol><h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span> <span class="comment">#双指针</span></span><br><span class="line">        cur = head</span><br><span class="line">        pre = <span class="literal">None</span>        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span> <span class="comment">#递归</span></span><br><span class="line"><span class="comment"># 递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span>==<span class="literal">None</span>):</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line"><span class="comment"># 这里的cur就是最后一个节点</span></span><br><span class="line">cur = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line"><span class="comment"># 这里请配合动画演示理解</span></span><br><span class="line"><span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line"><span class="comment"># 而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line"><span class="comment"># 所以head.next.next 就是5-&gt;4</span></span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line"><span class="comment"># 防止链表循环，需要将head.next设置为空</span></span><br><span class="line">head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line"><span class="keyword">return</span> cur </span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        stack = [<span class="literal">None</span>]</span><br><span class="line">        <span class="comment"># 把链表节点全部放到栈中</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            stack.append(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        head = stack.pop()</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 栈中的结点全部出栈，然后重新连成一个新的链表</span></span><br><span class="line">        <span class="keyword">while</span> stack: </span><br><span class="line">            cur.<span class="built_in">next</span> = stack.pop()</span><br><span class="line">            cur =cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 最后一个结点就是反转前的头结点，一定要让他的next</span></span><br><span class="line">        <span class="comment"># 等于空，否则会构成环</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O( )$ n是链表的长度，  </li><li>空间复杂度：$O( )$  </li></ul><h2 id="3-LC21-合并两个有序链表-合并两个有序链表"><a href="#3-LC21-合并两个有序链表-合并两个有序链表" class="headerlink" title="3. (LC21) 合并两个有序链表 合并两个有序链表"></a>3. (LC21) 合并两个有序链表 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>迭代<ul><li>首先，我们设定一个哨兵节点<code>prehead</code>，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个<code>prev</code>指针，我们需要做的是调整它的<code>next</code>指针。然后我们重复以下过程，直到<code>l1</code>或者<code>l2</code>指向<code>null</code>。在循环终止的时候，<code>l1</code>和<code>l2</code>至多有一个是非空的。</li></ul></li><li>递归</li></ol><h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    dummy = ListNode()</span><br><span class="line">    cur = dummy </span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = l1</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = l2</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n+m)$, 其中n和m个链表长度</li><li>空间复杂度：$O(1)$  </li></ul><h2 id="4-LC83-从有序链表中删除重复节点-从有序链表中删除重复节点"><a href="#4-LC83-从有序链表中删除重复节点-从有序链表中删除重复节点" class="headerlink" title="4. (LC83) 从有序链表中删除重复节点 从有序链表中删除重复节点"></a>4. (LC83) 从有序链表中删除重复节点 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/">从有序链表中删除重复节点</a></h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></tbody></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h3 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        curnext = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> curnext:</span><br><span class="line">            <span class="keyword">if</span> cur.val == curnext.val:</span><br><span class="line">                curnext = curnext.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = curnext    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = curnext</span><br><span class="line">                curnext = curnext.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n)$ n是链表的长度。因为列表中的每个节点都检查一次以确定它是否重复，所以总运行时间为$O(n)$</li><li>空间复杂度：$O(1)$，没有使用额外的空间</li></ul><h3 id="LC19-删除链表的倒数第-N-个结点-删除链表的倒数第-N-个结点"><a href="#LC19-删除链表的倒数第-N-个结点-删除链表的倒数第-N-个结点" class="headerlink" title="(LC19)删除链表的倒数第 N 个结点   删除链表的倒数第 N 个结点"></a>(LC19)删除链表的倒数第 N 个结点   <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/">删除链表的倒数第 N 个结点</a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>进阶：你能尝试使用一趟扫描实现吗？<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC"><a href="#LC" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-1"><a href="#LC-1" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-6"><a href="#Python3-Code-6" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-2"><a href="#LC-2" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-7"><a href="#Python3-Code-7" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-3"><a href="#LC-3" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-8"><a href="#Python3-Code-8" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-4"><a href="#大佬题解-4" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-4"><a href="#LC-4" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-9"><a href="#Python3-Code-9" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-5"><a href="#大佬题解-5" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-5"><a href="#LC-5" class="headerlink" title="(LC )      "></a>(LC )    <a href="">  </a></h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-10"><a href="#Python3-Code-10" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-6"><a href="#大佬题解-6" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md#7-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C&quot;&gt;刷题顺序&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Important notice: 涉及到链表的操作，一定要在纸上把过程先画出来，再写程序！不要断链子。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>声学信号处理系列（一）声学信号处理基础知识</title>
    <link href="http://watermelondrip.github.io/2021/03/20/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%970_%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <id>http://watermelondrip.github.io/2021/03/20/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%970_%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-19T13:00:00.000Z</published>
    <updated>2021-03-20T06:19:02.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="声学信号处理系列（一）声学信号处理基础知识"><a href="#声学信号处理系列（一）声学信号处理基础知识" class="headerlink" title="声学信号处理系列（一）声学信号处理基础知识"></a>声学信号处理系列（一）声学信号处理基础知识</h1><p><em>by max</em></p><p><em>2021/03/07</em></p><h2 id="0-写在开始的话"><a href="#0-写在开始的话" class="headerlink" title="0.写在开始的话"></a>0.写在开始的话</h2><p>这个博客系列里，会介绍一些声学信号处理领域相关的基础性知识，以及工业界学术界主流的一些算法应用方向。主要会关注与本人工作相关的一些细分领域，例如：语音增强、声纹识别、麦克风阵列、声学场景识别以及声纹识别反欺骗等诸多方向。随着系列博客文章的积累，会逐渐关注并提供更多应用领域的介绍。本系列旨在记录平时工作中学习到的新知识，也希望能跟别人分享自己的一些心得体会。个人水平有限，如有疏漏错误，敬请批评指正，谢谢！</p><h2 id="1-声学基础"><a href="#1-声学基础" class="headerlink" title="1.声学基础"></a>1.声学基础</h2><p>声音是自然界中非常常见的一种信号之一，我们平时的生活中声音无处不在。人类可以通过声音，来对物体进行感知、辨认和定位。同样，声音也是日常我们互相交流时用于传递信息文字的“载具”。</p><p>初高中物理课上大家应该都学到过，声音的本质是物体振动生成的声波，该声波通过某种介质（例如空气、水和固体）传播并能被人类或者动物的听觉器官所感知。声音的频率一般会以赫兹表示，记为Hz，指每秒钟周期性震动的次数。而分贝是用来表示声音强度的单位，记为dB[1]。</p><h2 id="2-我们如何发出声音"><a href="#2-我们如何发出声音" class="headerlink" title="2.我们如何发出声音"></a>2.我们如何发出声音</h2><p>正如上一小节中所介绍的，发出声音需要凭借物体的振动。那么我们人类从口腔中发出各种各样的声音，也正是依靠我们的声带的振动来实现的。具体说来，从我们肺部内排出的气体气流，在经过形态变化的声带结构时，带动声带产生振动，进而生成了声波，声波经过我们的口腔和嘴，传输到外界空气中。在整个过程里，由于每个人类个体的声带器官、口腔腔体和嘴部的生理结构都是各异的，所以也导致我们每个人说出来的话的语音语调，以及包括音色，都是不同的。需要注意的是，由于鼻腔和口腔在人体内部是连通的，也会参与到发声过程中来。</p><p>下图是一个口腔内部的各个器官的展示，体内从肺部出来的气流，经气管-&gt;声带-&gt;咽喉-&gt;口鼻，传出体外。</p><p><img src= "/img/watermelon.gif" data-lazy-src="https://i.loli.net/2021/03/20/thUDC8LeM3imOoA.png" style="zoom:70%"></p><h2 id="3-一些基本的专业词汇-2"><a href="#3-一些基本的专业词汇-2" class="headerlink" title="3.一些基本的专业词汇[2]"></a>3.一些基本的专业词汇[2]</h2><ul><li>音节（Syllable）：说话时一次发出的，具有一个响亮的中心，并被明显感觉到的语音片段。</li><li>音素（Phoneme）：语音发音的最小单位。一个音节可以由一个或多个音素构成。音素可分为元音和辅音两种。</li><li>元音（Vowel）：当声带振动发出的声音气流从咽喉进入口腔并从嘴部唇部出去时，这些声腔完全开放，气流可以顺利通过时所发的音，称为元音。元音构成音节的主干，无论从长度或是能量角度考虑，元音在音节中都占主要部分。决定元音音色的主要因素是舌头的形状及其在口腔中的位置，以及嘴唇的形状等。口腔中当舌头处于不同的舌位高度和舌位前后时，可以发出不同的音素。下图是一个单元音发音舌位示意图：<br><img src= "/img/watermelon.gif" data-lazy-src="https://i.loli.net/2021/03/20/4aPrTg651YZvBfV.gif" style="zoom:70%"></li><li>辅音（Consonant）：当呼出的气流，由于整个声腔通路上某一部分封闭起来或受到阻碍，气流传播不通畅，而克服发音器官的这种阻碍时所发的音，称为辅音。发辅音时，声带振动的是浊音，声带不振动的是清音。辅音只出现在音节的前端或后端或前后两端，时长和能量相比元音都很小。</li><li>半元音：有时，虽然声道基本畅通，但某处声道较窄，引起轻微的摩擦声，称为半元音。</li></ul><h2 id="4-共振峰（Formant）与基频F0（Fundamental-frequency）"><a href="#4-共振峰（Formant）与基频F0（Fundamental-frequency）" class="headerlink" title="4.共振峰（Formant）与基频F0（Fundamental frequency）"></a>4.共振峰（Formant）与基频F0（Fundamental frequency）</h2><p>共振峰和基频F0是语音信号处理中较为重要的概念，所以单独拿出来介绍一下。</p><p>(1)共振峰：前面介绍过发声机理，其中声道可以被等效视为一根横截面非均匀的声管，在发声过程中，该声管起共鸣器的作用。当一个具有相对较大能量的元音激励进入声道时，会引起共振特性，产生一组共振频率，称为共振峰频率，可简称为共振峰。换句话说，共振峰不是特指某一个频率的振动信号，而是代指一组具有不同频率的共振信号，这组信号里，每个信号所处的频率是不同的，但是是连续存在的。</p><p>一般可以用共振峰频率的位置和频带宽度这两个参数来描述一组共振峰。每个不同的元音，都对应着一组不同的共振峰参数。共振峰中的信号通常用F来表示，例如F0，F1，F2…等等。</p><p>(2)基频F0：基频又称基础频率，其定义为共振峰中第一个共振信号的振动频率。共振峰中除基频F0以外，其他共振信号均为口腔共振产生，而基频F0由声带振动产生，其能量一般为共振峰中最强的。有时将音调（pitch）和基频等效看待，二者其实有一些细节上的不同，但平时讨论时可以暂时视为一体。音调反应的是音高的信息，男性和女性的平均音调范围是不同的，男性更低一些，女性更高一些。</p><p>任何为基频整倍数的频率上的信号称为谐波。谐波反应的是音色的信息。</p><p>通常我们可以通过观测语音信号的语谱图，来对共振峰和基频有一个直观的了解。语谱图是将语音的频谱信号以二维形式所描绘出来的图形，该图形横轴为时间，单位通常为秒s，纵轴为频率，单位通常为赫兹Hz。图形上颜色的深浅代表声学信号能量强度的高低。一个典型的反应了共振峰的语谱图如下所示：<br><img src= "/img/watermelon.gif" data-lazy-src="https://i.loli.net/2021/03/20/5OrJYEweRg8p1Iq.png" style="zoom:40%"></p><h2 id="5-我们如何听到声音"><a href="#5-我们如何听到声音" class="headerlink" title="5.我们如何听到声音"></a>5.我们如何听到声音</h2><p>人类听到声音的简要过程：空气中的声波传播到人耳内，耳朵内的鼓膜受到声波的声压的作用会产生位移振动，内耳的一个主要器官耳蜗，将这种位移振动的机械信息，转换为生物神经信号，传递给大脑进行处理后，我们就能够获知听到的是什么声音了。具体的介绍请移步参考资料[2]中的2.4.2节，会有更详尽的了解。</p><p>人耳一般能接收并处理的声音的频率范围为20Hz到20kHz，强度为-5至130dB。在此范围外的声学信号里的音频分量，是人耳处理不到的，一般在语音信号处理领域的问题中不会考虑。但是，凡事无绝对，我们也不能说在这个范围以内的音频分量我们一定能听得到，这就涉及到一个概念叫做听觉掩蔽效应。</p><p>听觉掩蔽效应指的是在一个强信号附近，弱信号将变得听不到，被掩盖掉了。生活中这种例子常见的有：购物商场的大喇叭在外放吵闹的音乐时，两个人的对话可能即使很近也听不清楚。被掩蔽掉的不可闻信号的最大声压级称为掩蔽门限或掩蔽阈值，在这个掩蔽阈值以下的声音都会被掩盖掉。</p><h2 id="参考资料列表"><a href="#参考资料列表" class="headerlink" title="参考资料列表"></a>参考资料列表</h2><p>[1] 维基百科-声音词条：<a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E9%9F%B3">https://zh.wikipedia.org/wiki/%E5%A3%B0%E9%9F%B3</a></p><p>[2] 赵力. 语音信号处理[M]. 机械工业出版社, 2016.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="声学信号处理" scheme="http://watermelondrip.github.io/tags/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://watermelondrip.github.io/2021/03/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://watermelondrip.github.io/2021/03/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2021-03-18T01:07:13.083Z</published>
    <updated>2021-03-18T01:12:50.709Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><hr><p>二分查找也称为折半查找，每次都能查找区间减半，这种折半特性的算法时间复杂度为O(logN)。二分查找不要求序列有序。要求每一次二分后可以定位target在左侧还是右侧，只要能定位target在哪就可以。<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md#leetcode-%E9%A2%98%E8%A7%A3---%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a><br><span id="more"></span></p><h1 id="二分查找解题思路-and-解题思路（熟到默写）"><a href="#二分查找解题思路-and-解题思路（熟到默写）" class="headerlink" title="二分查找解题思路 and 解题思路（熟到默写）"></a>二分查找<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">解题思路</a> and <a href="https://www.jianshu.com/p/88333f1f02a7">解题思路</a>（熟到默写）</h1><ul><li>第一步：通过比较中值与右值来确定最小值的位置范围，进而确定边界收缩的方向。</li><li>第二步：分析问题，首先是while循环里的细节问题。这里循环不变的是 <code>left&lt;right</code>, 并且要保证左闭右开区间里面始终套住最小值。中间值的计算是：<code>mid  = left + (right - left)/2</code>。 这是整数除法是向下取整的地板除，<code>mid</code>更靠近<code>left</code>，再结合<code>while</code>循环的条件<code>left&lt;right</code>，可以知道<code>left&lt;=mid</code> ,<code>right&gt;mid</code>，即在<code>while</code>循环内，<code>mid</code>始终小于<code>right</code>。因此在<code>while</code>循环内，<code>nums[mid]</code>要么大于要么小于 <code>nums[right]</code>，不会等于。这样<code>else{right = mid;}</code>这句判断可以改为更精确的 <code>else if (nums[mid] &lt; nums[right]){right = mid;}</code></li><li>第三步<code>while</code> 循环退出的条件。 如果输入数组只有一个数，左右边界位置重合，<code>left == right</code>，不会进去<code>while</code>循环，直接输出。如果输入数组只有一个数，左右边界位置重合，<code>left == right</code>，不会进入<code>while</code>循环，直接输出。如果输入数组多于一个数，循环到最后，会只剩两个数，<code>nums[left] == nums[mid]</code>，以及<code>nums[right]</code>，这里的位置<code>left == mid == right -1</code>。如果<code>nums[left] == nums[mid] &gt; nums[right]</code>，则左边大，右边小，需要执行<code>left = mid + 1</code>，使得<code>left == right</code>，左右边界位置重合，循环结束，<code>nums[left]</code>与<code>nums[right]</code>都保存了最小值。 如果<code>nums[left] == nums[mid] &lt; nums[right]</code>，则左边小，右边大，会执行<code>right = mid</code>，使得<code>left == right</code>， 左右边界位置重合，循环结束，<code>nums[left]</code>、<code>nums[right]</code>、<code>nums[mid]</code>都保存了最小值。</li></ul><hr><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><hr><h2 id="LC69-x-的平方根-x-的平方根"><a href="#LC69-x-的平方根-x-的平方根" class="headerlink" title="(LC69) x 的平方根 x 的平方根"></a>(LC69) x 的平方根 <a href="https://leetcode-cn.com/problems/sqrtx/description/">x 的平方根</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>二分查找</li></ul><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul><li>第一步：左闭右开：<code>left</code>有效，<code>right</code>无效。<code>left == mid == right -1</code></li><li>第二步： 使用<code>left&lt;right</code> 作为while循环条件<code>nums[left] == nums[right]</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment">#左闭右开</span></span><br><span class="line">        l,r = <span class="number">0</span>,x//<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid  = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">            print(mid)</span><br><span class="line">            <span class="keyword">if</span> mid**<span class="number">2</span> &gt; x:</span><br><span class="line">                r = mid-<span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l  = mid </span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="LC69-寻找比目标字母大的最小字母-寻找比目标字母大的最小字母"><a href="#LC69-寻找比目标字母大的最小字母-寻找比目标字母大的最小字母" class="headerlink" title="(LC69) 寻找比目标字母大的最小字母 寻找比目标字母大的最小字母"></a>(LC69) 寻找比目标字母大的最小字母 <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/">寻找比目标字母大的最小字母</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。在比较时，字母是依序循环出现的。<br>举个例子：<br>如果目标字母 target = ‘z’ 并且字符列表为 letters = [‘a’, ‘b’]，则答案返回 ‘a’</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">letters = ["c", "f", "j"]</span><br><span class="line">target = "a"</span><br><span class="line">输出: "c"</span><br></pre></td></tr></tbody></table></figure><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>二分查找</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>第一步：左闭右开：<code>left</code>有效，<code>right</code>无效。<code>left == mid == right -1</code>，保证左闭右开区间里面始终套住最小值</li><li>第二步： 使用<code>left&lt;right</code> 作为while循环条件<code>nums[left] == nums[right]</code></li><li>第三步： 这是循环前升序排列的， 左边比右边大，而且我们要找的是最小值，肯定是偏向左找。这个系统本身就是左右不对称的，本身就有方向性，即使做了旋转，这个不对称性还是存在的，算法的不对称来源于系统本身的不对称。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: List[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        num_letters =[]</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> letters:</span><br><span class="line">            num_letters.append(<span class="built_in">ord</span>(ch))</span><br><span class="line">        num_target = <span class="built_in">ord</span>(target)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(num_letters)</span><br><span class="line">        mid = (r+l)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;  r:</span><br><span class="line">            mid = (r+l)&gt;&gt;<span class="number">1</span> </span><br><span class="line">            <span class="keyword">if</span> mid == <span class="built_in">len</span>(num_letters): <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> num_letters[mid] &gt; num_target:</span><br><span class="line">                r = mid </span><br><span class="line">            <span class="keyword">elif</span> num_letters[mid] &lt;= num_target:</span><br><span class="line">                l = mid+<span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> l == <span class="built_in">len</span>(num_letters): <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> letters[r]</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="LC278-第一个错误的版本-第一个错误的版本"><a href="#LC278-第一个错误的版本-第一个错误的版本" class="headerlink" title="(LC278) 第一个错误的版本 第一个错误的版本"></a>(LC278) 第一个错误的版本 <a href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5)&nbsp;-&gt; true</span><br><span class="line">调用 isBadVersion(4)&nbsp;-&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></tbody></table></figure><h3 id="前置知识-2"><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>二分查找</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>第一步：左闭右开：<code>left</code>有效，<code>right</code>无效。<code>left == mid == right -1</code>，保证左闭右开区间里面始终套住最小值</li><li>第二步： 使用<code>left&lt;right</code> 作为while循环条件<code>nums[left] == nums[right]</code> ，</li><li>第三步： 如果isBadVersion(mid)返回false， 我们知道<code>mid</code>左侧的所有版本都是正确的版本。所以left = mid +1，下一次的搜索空间变为<code>[mid+1, right)</code>。如果isBadVersion(mid)返回true， 我们知道<code>mid</code>右侧的所有版本都不是第一个错误的版本。所以’right = mid+1’。，下一次的搜索空间变为<code>[left, mid+1)</code>。当某一次操作后，<code>left</code> 和 <code>right</code>的值相等，此时他们就表示了第一个错误版本的位置</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">1</span>, n</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:  <span class="comment">#左闭右开</span></span><br><span class="line">            mid = (r + l) &gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isBadVersion(mid):</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(logn)$。搜索空间每次减少一半，因此时间复杂度为$O(logn)$。</li><li>空间复杂度：$O(1)$</li></ul><h2 id="LC153-寻找旋转排序数组中的最小值-寻找旋转排序数组中的最小值"><a href="#LC153-寻找旋转排序数组中的最小值-寻找旋转排序数组中的最小值" class="headerlink" title="(LC153) 寻找旋转排序数组中的最小值 寻找旋转排序数组中的最小值"></a>(LC153) 寻找旋转排序数组中的最小值 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为[4,5,6,7,0,1,2] 。<br>请找出其中最小的元素。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="前置知识-3"><a href="#前置知识-3" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>二分查找</li></ul><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><ul><li>第一步：左闭右开：<code>left</code>有效，<code>right</code>无效。<code>left == mid == right -1</code></li><li>第二步： 使用<code>left&lt;right</code> 作为while循环条件<code>nums[left] == nums[right]</code></li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="comment">#左闭右开</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            <span class="comment">#偏向左找</span></span><br><span class="line">            mid = (r+l)&gt;&gt;<span class="number">1</span></span><br><span class="line">            print(mid,r,l)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[r]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br><span class="line">            </span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(log n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;二分查找也称为折半查找，每次都能查找区间减半，这种折半特性的算法时间复杂度为O(logN)。二分查找不要求序列有序。要求每一次二分后可以定位target在左侧还是右侧，只要能定位target在哪就可以。&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md#leetcode-%E9%A2%98%E8%A7%A3---%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE&quot;&gt;二分查找&lt;/a&gt;&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>分治</title>
    <link href="http://watermelondrip.github.io/2021/03/18/%E5%88%86%E6%B2%BB/"/>
    <id>http://watermelondrip.github.io/2021/03/18/%E5%88%86%E6%B2%BB/</id>
    <published>2021-03-17T13:52:00.000Z</published>
    <updated>2021-03-17T13:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%88%86%E6%B2%BB.md">分治</a></h2><h3 id="思路是："><a href="#思路是：" class="headerlink" title="思路是："></a>思路是：</h3><p>(1) 将一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分为更小的子问题—-分 （2) 将最后子问题可以简单的直接求解—-“治” （3) 将所有子问题的解合并起来就说原问题的解—-“合”<br><span id="more"></span></p><p><strong>目录 (Table of Contents)</strong></p><!-- toc --><p>[TOC]</p><h3 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h3><p>（1） 将问题的规模缩小到一定的程度就可以容易地解决<br>（2） 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。<br>（3） 利用该问题分解出的子问题的解可以合并为该问题的解。<br>（4） 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算计算复杂度一般是随着问题规模的增加而增加； 第二个特征是应用分治法的前提它也是大多数问题可以解决的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具有第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p><h2 id="1-LC241-为运算表达式设计优先级-为运算表达式设计优先级"><a href="#1-LC241-为运算表达式设计优先级-为运算表达式设计优先级" class="headerlink" title="1. (LC241) 为运算表达式设计优先级 为运算表达式设计优先级"></a>1. (LC241) 为运算表达式设计优先级 <a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">为运算表达式设计优先级</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: "2-1-1"</span><br><span class="line">输出: [0, 2]</span><br><span class="line">解释: </span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></tbody></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>分治： 自顶向下地拆分子问题</li><li>分解：每一步都针对一个运算符分割表达式。</li><li>解决：递归停止条件，无运算符只有数字</li><li>合并</li><li>递归的方式去寻找子问题和原问题解的关系。 可以通过运算符把整个式子分成两部分，两部分再利用递归解决。</li></ul><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i,char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>]:</span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:i])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">'+'</span>:</span><br><span class="line">                            res.append(r+l)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">'-'</span>:</span><br><span class="line">                            res.append(l-r)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">'*'</span>:</span><br><span class="line">                            res.append(l*r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h2 id="2-LC95-不同的二叉搜索树-II-不同的二叉搜索树-II"><a href="#2-LC95-不同的二叉搜索树-II-不同的二叉搜索树-II" class="headerlink" title="2. (LC95) 不同的二叉搜索树 II 不同的二叉搜索树 II"></a>2. (LC95) 不同的二叉搜索树 II <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">&nbsp; [1,null,3,2],</span><br><span class="line">&nbsp; [3,2,null,1],</span><br><span class="line">&nbsp; [3,1,null,null,2],</span><br><span class="line">&nbsp; [2,1,3],</span><br><span class="line">&nbsp; [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></tbody></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>分治： 自顶向下地拆分子问题</li><li>分解：每一步都针对一个运算符分割表达式。</li><li>解决：递归停止条件，无运算符只有数字</li><li>合并</li><li>递归的方式去寻找子问题和原问题解的关系。 可以通过运算符把整个式子分成两部分，两部分再利用递归解决。通过利用查找二叉树的性质。左子树的所有值小于根节点，右子树的所有值都大于根节点。<ul><li>我们需要把1作为根节点，[]空作为左子树，[2,…,n] 的所有可能作为右子树</li><li>n 作为根节点，[1,..,n]的所有可能作为左子树，[]作为右子树</li><li>至于上面提到的 [2,…,n]的所有可能以及其他可能，可以利用上面的方法，把每个数字作为根节点，然后把所有可能的左子树和右子树组合起来即可。</li><li>如果只有一个数字，那么所有可能就说一种情况，把该数字作为一棵树。而如果是[]，那么返回null。</li></ul></li></ul><h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_gen</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> [TreeNode(nums[<span class="number">0</span>])]</span><br><span class="line">            </span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> _gen(nums[:i]):</span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> _gen(nums[i+<span class="number">1</span>:]):</span><br><span class="line">                        ans.append(TreeNode(nums[i], left = left, right = right))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> _gen(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)))</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h2 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/44213575">“python算法实现-分治法”</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;分治&quot;&gt;&lt;a href=&quot;#分治&quot; class=&quot;headerlink&quot; title=&quot;分治&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%88%86%E6%B2%BB.md&quot;&gt;分治&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;思路是：&quot;&gt;&lt;a href=&quot;#思路是：&quot; class=&quot;headerlink&quot; title=&quot;思路是：&quot;&gt;&lt;/a&gt;思路是：&lt;/h3&gt;&lt;p&gt;(1) 将一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分为更小的子问题—-分 （2) 将最后子问题可以简单的直接求解—-“治” （3) 将所有子问题的解合并起来就说原问题的解—-“合”&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>双指针（easy篇）</title>
    <link href="http://watermelondrip.github.io/2021/03/18/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://watermelondrip.github.io/2021/03/18/%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-03-17T13:52:00.000Z</published>
    <updated>2021-03-17T13:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="双指针-顺序"><a href="#双指针-顺序" class="headerlink" title="双指针 (顺序)"></a>双指针 (<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-two-sum">顺序</a>)</h1><hr><p>双指针用于遍历数组，两个指针指向不同的元素，从而共同的完成一个任务。<br>（1）共同完成一个和的target<br>（2）从后往前，从前往后，两边夹击，快慢指针</p><p><strong>目录 (Table of Contents)</strong></p><p>[TOCM]</p><p>[TOC]</p><h2 id="1-LC167-两数之和-II-输入有序数组-两数之和II"><a href="#1-LC167-两数之和-II-输入有序数组-两数之和II" class="headerlink" title="1. (LC167) 两数之和 II - 输入有序数组   两数之和II"></a>1. (LC167) 两数之和 II - 输入有序数组   <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">两数之和II</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p><p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p><p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br> 示例 1：</p><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>双指针<br>如何想到双指针，我觉得首先是这个数组是有序的，然后就是由两个数构成，这就想到了双指针了</p><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt; right:</span><br><span class="line">            total = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> total &gt; target:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]                </span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n)$ 只是遍历了一次</li><li>空间复杂度：$O(1)$ 只用了两个额外的变量（不考虑输出变量空间，只考虑额外的）</li></ul><h2 id="2-LC633-两数平方和-两数平方和"><a href="#2-LC633-两数平方和-两数平方和" class="headerlink" title="2. (LC633) 两数平方和   两数平方和"></a>2. (LC633) 两数平方和   <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">两数平方和</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。</p><p>示例 1：</p><p>输入：c = 5<br>输出：true<br>解释：1 <em> 1 + 2 </em> 2 = 5<br>范围：0 &lt;= c &lt;= 2^31 - 1</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先这个又是两个整数的，我们想如果出现两个整数共同来完成一件事，这两个整数在一个范围内，是不是都可以用双指针呢。<br>但是这里面有平方比较麻烦了，所以上面那个不是和吗，我想如果求出c的根号是不是在这附近的数就比较好找了</p><h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span>(<span class="params">self, c: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sqr</span>(<span class="params">c</span>):</span></span><br><span class="line">            x0 = c/<span class="number">2</span></span><br><span class="line">            x1 = x0/<span class="number">2</span> + c/(x0*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">abs</span>(x1-x0) &gt; <span class="number">1</span>:</span><br><span class="line">                x0 = x1</span><br><span class="line">                x1 = x0/<span class="number">2</span> + c/(x0*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> x1</span><br><span class="line">        right,left = <span class="built_in">int</span>(sqr(c)),<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            print(left**<span class="number">2</span> + right**<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> left**<span class="number">2</span> + right**<span class="number">2</span> &gt; c:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> left**<span class="number">2</span> + right**<span class="number">2</span> &lt; c:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> </span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(sqr(c)*n1)$ 只是遍历了一次 def sqrt(c)</li><li>空间复杂度：$O(1)$ 只用了两个额外的变量</li></ul><h2 id="3-LC345-反转字符串中的元音字母反转字符串中的元音字母"><a href="#3-LC345-反转字符串中的元音字母反转字符串中的元音字母" class="headerlink" title="3. (LC345) 反转字符串中的元音字母反转字符串中的元音字母"></a>3. (LC345) 反转字符串中的元音字母<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" title="反转字符串中的元音字母">反转字符串中的元音字母</a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br>示例 1：<br>输入：”hello”<br>输出：”holle”</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><p>首先使用双指针是因为，反转字符串中，是两个两个一对的换，通俗的意思是，如果是简单的反转字母是, ‘abc’ 反转之后变为 ‘cba’</p></li><li><p>有一个概念很重要，就是<a href="https://zhuanlan.zhihu.com/p/34395671" title="可变对象和不可变对象">可变对象和不可变对象</a><br> (1) 可变：list, dic, set （2）不可变：tuple, string, int, float, bool</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 不可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></tbody></table></figure><p>从上面的例子可以看出来，可变对象是可以直接被改变的，而不可变对象则不可以</p><h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">list</span>(s))&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        front = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        vowels = {<span class="string">"a"</span>,<span class="string">"e"</span>,<span class="string">"i"</span>,<span class="string">"o"</span>,<span class="string">"u"</span>,<span class="string">"A"</span>,<span class="string">"E"</span>,<span class="string">"I"</span>,<span class="string">"O"</span>,<span class="string">"U"</span>} </span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> front&lt; end:</span><br><span class="line">            <span class="keyword">if</span> s[front] <span class="keyword">in</span> vowels <span class="keyword">and</span> s[end] <span class="keyword">in</span> vowels:</span><br><span class="line">                s[front], s[end] = s[end] , s[front]</span><br><span class="line">                front+=<span class="number">1</span></span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[front] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                front+=<span class="number">1</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li>时间复杂度：$ $</li><li>空间复杂度：$ $  </li></ul><h2 id="4-LC680-验证回文字符串-Ⅱ-验证回文字符串-Ⅱ"><a href="#4-LC680-验证回文字符串-Ⅱ-验证回文字符串-Ⅱ" class="headerlink" title="4. (LC680)  验证回文字符串 Ⅱ 验证回文字符串 Ⅱ"></a>4. (LC680)  验证回文字符串 Ⅱ <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" title="验证回文字符串 Ⅱ">验证回文字符串 Ⅱ</a></h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br>示例 1：<br>输入：”hello”<br>输出：”holle”</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>Lambda 函数<br>lambda 函数是一个小型匿名函数。lambda 函数可以接受任意数量的参数，但只能有一个表达式。<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function that returns square of any number</span></span><br><span class="line">&gt;&gt;&gt;sqr = <span class="keyword">lambda</span> x: x * x</span><br><span class="line">&gt;&gt;&gt;sqr(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">100</span></span><br></pre></td></tr></tbody></table></figure></li><li>优美的一行代码<br><a href="https://zhuanlan.zhihu.com/p/345055254" title="25条很棒的Python一行代码，建议收藏！">25条很棒的Python一行代码，建议收藏！</a><h3 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> s: s == s[::-<span class="number">1</span>]</span><br><span class="line">        strPart = <span class="keyword">lambda</span> s, x: s[:x] + s[x + <span class="number">1</span>:]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strPart(s, left)) <span class="keyword">or</span> isPalindrome(strPart(s, right))</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li>时间复杂度：$ $</li><li>空间复杂度：$ $  </li></ul><h2 id="5-LC88-合并两个有序数组合并两个有序数组-合并两个有序数组"><a href="#5-LC88-合并两个有序数组合并两个有序数组-合并两个有序数组" class="headerlink" title="5. (LC88)  合并两个有序数组合并两个有序数组  合并两个有序数组"></a>5. (LC88)  合并两个有序数组合并两个有序数组  <a href="https://leetcode-cn.com/problems/merge-sorted-array/description/">合并两个有序数组</a></h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p><p>示例 1：</p><p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p> 需要从尾开始遍历， 否则在num1上归并得到的值会覆盖还未进行归并比较的值</p><h3 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># two get pointers for nums1 and nums2</span></span><br><span class="line">       p1 = m - <span class="number">1</span></span><br><span class="line">       p2 = n - <span class="number">1</span></span><br><span class="line">       <span class="comment"># set pointer for nums1</span></span><br><span class="line">       p = m + n - <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment"># while there are still elements to compare</span></span><br><span class="line">       <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">and</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">               nums1[p] = nums2[p2]</span><br><span class="line">               p2 -= <span class="number">1</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               nums1[p] =  nums1[p1]</span><br><span class="line">               p1 -= <span class="number">1</span></span><br><span class="line">           p -= <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment"># add missing elements from nums2</span></span><br><span class="line">       nums1[:p2 + <span class="number">1</span>] = nums2[:p2 + <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n+m) $</li><li>空间复杂度：$O(1) $没有额外的变量产生  </li></ul><h2 id="6-LC141-环形链表-环形链表-环形链表"><a href="#6-LC141-环形链表-环形链表-环形链表" class="headerlink" title="6. (LC141)   环形链表 环形链表  环形链表"></a>6. (LC141)   环形链表 环形链表  <a href="https://leetcode-cn.com/problems/linked-list-cycle/description/">环形链表</a></h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>(1) 从力扣官网上看到的<a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">龟兔赛跑算法</a></p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><ul><li><p>细节： 为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p><ul><li>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</li></ul></li></ul><h3 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="7-LC141-通过删除字母匹配到字典里最长单词-通过删除字母匹配到字典里最长单词"><a href="#7-LC141-通过删除字母匹配到字典里最长单词-通过删除字母匹配到字典里最长单词" class="headerlink" title="7. (LC141)  通过删除字母匹配到字典里最长单词  通过删除字母匹配到字典里最长单词"></a>7. (LC141)  通过删除字母匹配到字典里最长单词  <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">通过删除字母匹配到字典里最长单词</a></h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例 1:</p><p>输入:<br>s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]<br>输出:<br>“apple”</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>(1)  首先是字符串字典顺序是啥意? 只听说过数的运算，字符串怎么进行运算呢？字符串运算是灵活，又有点复杂的。<a href="https://zhuanlan.zhihu.com/p/91137723">python字符串数据类型</a>。其中我们讲一下字符串的关系运算，采用 ‘&lt;’, ‘&lt;=’, ‘&gt;’, ‘&gt;=’, ‘==’, ‘!=’ 关系运算符对两个字符串进行比较，其实是依次对两个字符串同位置上字符的ADCII 码进行比较。需要注意的是如果如果第一个字符能比较出大小来，不会往后比较，第一个字符相同的话，才往后进行比较<br>(2)  这个题进行双指针也是挺明显的，首先是两个字符串进行遍历的比较。第二是前面也有提到的是，字符串是可变的，所以可以进行比较的。</p><h3 id="Python3-Code-6"><a href="#Python3-Code-6" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        len_ans = <span class="number">0</span></span><br><span class="line">        ans = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> dst <span class="keyword">in</span> dictionary:</span><br><span class="line">            i = <span class="number">0</span> </span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(dst):<span class="comment"># 先判断是不是符合条件的字符串</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == dst[j]:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(dst): <span class="comment">#判断是不是字典序最小的</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; len_ans:</span><br><span class="line">                    len_ans,ans = <span class="built_in">len</span>(dst), dst</span><br><span class="line">                <span class="keyword">elif</span> j == len_ans <span class="keyword">and</span> dst &lt; ans:</span><br><span class="line">                    len_ans,ans = <span class="built_in">len</span>(dst), dst</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>排序 （熟到可以默写）</title>
    <link href="http://watermelondrip.github.io/2021/03/18/%E6%8E%92%E5%BA%8F/"/>
    <id>http://watermelondrip.github.io/2021/03/18/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-17T13:52:00.000Z</published>
    <updated>2021-03-17T13:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="排序顺序"><a href="#排序顺序" class="headerlink" title="排序顺序"></a>排序<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%8E%92%E5%BA%8F.md">顺序</a></h2><p>思路是：</p><p>（1）快速选择，用于求解第k个元素的问题</p><p>（2）堆:堆的中心就一个，那就是动态求极值。 堆可以用二叉树实现，叫做二叉堆。二叉堆的性质就是堆的性质不变。</p><p> (3) 三向快排： 快排的核心思想是选择一个枢纽，左边的都比枢纽小，右边的都比枢纽大。 然后堆分成的两部分再进行递归快排。 但是如果有很多重复元素的时候呢，因为快排会对一个都是重复元素的数组再进行递归，其实我们已经知道了， 不用再进行递归了，因为已经是有序的了。 怎么实现呢？</p><pre><code>- 三向排序： 对于一个数组，一次扫描要有三个指针。</code></pre><p><strong>目录 (Table of Contents)</strong></p><p>[TOCM]</p><p>[TOC]</p><h2 id="1-LC215-Kth-Element-Kth-Element"><a href="#1-LC215-Kth-Element-Kth-Element" class="headerlink" title="1. (LC215) Kth Element Kth Element"></a>1. (LC215) Kth Element <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">Kth Element</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br> 示例 1：<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的是排序想法，直接把数组排序，然后找到k个就好了</li><li>堆， 堆是一种数据结构，一个很牛的<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ge-chong-pai-xu-suan-fa-tu-xie-zong-jie-by-ke-ai-x/">题解</a>和一个英文<a href="https://towardsdatascience.com/data-structure-heap-23d4c78a6962">解释</a> 和一个中文<a href="https://guguoyu.blog.csdn.net/article/details/81283998?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs">解释</a></li><li><a href="https://docs.python.org/3/library/heapq.html">heapq</a> 模块： 可能在面试过程中，有的面试官不让用，但是这个heapq还是很方便的。 (1)hq.heapqpush(heap,item) ：压入堆的意思，压入的是item （2）hq.heappop(heap)：弹出且返回最小的。hq.heappushpop(heap,item):先压入iem，然后弹出堆里最小的项。</li></ol><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest1</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment">#1. 排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest2</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 2. 最大堆  用heapq模块</span></span><br><span class="line">        <span class="keyword">import</span> heapq <span class="keyword">as</span> hq</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            hq.heappush(heap,i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                hq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest3</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 3.  最大堆， 构造堆模块</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">min_heapify</span>(<span class="params">array, i</span>):</span></span><br><span class="line">            left = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            length = <span class="built_in">len</span>(array) - <span class="number">1</span></span><br><span class="line">            smallest = i</span><br><span class="line">            <span class="keyword">if</span> left &lt;= length <span class="keyword">and</span> array[i] &gt; array[left]:</span><br><span class="line">                smallest = left</span><br><span class="line">            <span class="keyword">if</span> right &lt;= length <span class="keyword">and</span> array[smallest] &gt; array[right]:</span><br><span class="line">                smallest = right</span><br><span class="line">            <span class="keyword">if</span> smallest != i:</span><br><span class="line">                array[i], array[smallest] = array[smallest], array[i]</span><br><span class="line">                min_heapify(array, smallest)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_min_heap</span>(<span class="params">array</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(array)//<span class="number">2</span>)):</span><br><span class="line">                min_heapify(array, i)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">array</span>):</span></span><br><span class="line">            <span class="comment">#array = array.copy()</span></span><br><span class="line">            build_min_heap(array)</span><br><span class="line">            sorted_array = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">                array[<span class="number">0</span>], array[-<span class="number">1</span>] = array[-<span class="number">1</span>], array[<span class="number">0</span>]</span><br><span class="line">                sorted_array.append(array.pop())</span><br><span class="line">                min_heapify(array, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sorted_array</span><br><span class="line">        result = heapsort(nums)</span><br><span class="line">        <span class="keyword">return</span> result[-k]</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest4</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 4. 快速排序 [快速排序](https://jackkuo666.github.io/Data_Structure_with_Python_book/chapter6/section4.html)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">alist, low ,high</span>):</span></span><br><span class="line">            mid_value = alist[low]</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid_value:</span><br><span class="line">                    high-=<span class="number">1</span></span><br><span class="line">                alist[low] = alist[high]</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt;= mid_value:</span><br><span class="line">                    low+=<span class="number">1</span></span><br><span class="line">                alist[high] = alist[low]</span><br><span class="line">            alist[low] = mid_value</span><br><span class="line">            <span class="keyword">return</span> low</span><br><span class="line">        k = <span class="built_in">len</span>(nums) - k</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums) -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            p = partition(nums,low ,high)</span><br><span class="line">            <span class="keyword">if</span> k &lt; p:</span><br><span class="line">                high = p - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> k &gt; p:</span><br><span class="line">                low = p + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[p]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">         </span><br></pre></td></tr></tbody></table></figure><h2 id="2-LC347-前-K-个高频元素-前-K-个高频元素"><a href="#2-LC347-前-K-个高频元素-前-K-个高频元素" class="headerlink" title="2. (LC347) 前 K 个高频元素 前 K 个高频元素"></a>2. (LC347) 前 K 个高频元素 <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前 K 个高频元素</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素<br> 示例 1：<br>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的是排序想法，直接把数组排序，但是不满足时间复杂度的要求， 这里有个一个点是sort()函数，单独有一篇文章讲。</li><li>进一步，为了满足时间复杂度的要求，需要对解法一的排序过程进行改进。因为最终需要返回前k个频率最大的元素，可以想到借助堆这种数据结构。通过维护一个元素数目为k的最小堆，每次都将新的元素与对顶端的元素（也就是堆中频率最小的元素）进行比较，如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中。最终，堆中的k个元素即为前k个高频元素。 其中用到了.items(), #The items() method returns a view object. The view object contains the key-value pairs of the dictionary, as tuples in a list.</li><li>桶排序(bucket sort)，用空间复杂度换取时间复杂度的方法。为每一个数字设置一个桶，桶中是该数字出现的次数，然后对桶进行排序，实际上，上面的排序算法就说使用普通的排序方法对频率桶进行了排序，现在我们使用桶排序对频次惊醒排序。 桶排序为了进一步优化时间复杂度。 先统计数组中元素的频次。接着，将数组中的元素按着出现频次进行分组，即出现频次为i的元素存放在第i个桶，最后从桶中逆序取出前k个元素。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_1</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 1. 排序</span></span><br><span class="line">        freq_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums: <span class="comment"># 统计元素的频率</span></span><br><span class="line">            freq_dict[num] = freq_dict.get(num , <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        freq_dict_sort = <span class="built_in">sorted</span>(freq_dict.items(), key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line">        ret = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            ret.append(freq_dict_sort[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_2</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 2. 堆排序</span></span><br><span class="line">freq_dict = <span class="built_in">dict</span>() <span class="comment"># 统计元素的频率</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">freq_dict[num] = freq_dict.get(num,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 维护一个大小为k的最小堆，使得堆中的元素即为前k个高频元素</span></span><br><span class="line">pq = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> freq_dict.items(): </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pq)&lt; k:</span><br><span class="line">heapq.heappush(pq, (value,key))</span><br><span class="line"><span class="keyword">elif</span> value &gt; pq[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">heapq.heapreplace(pq, (value,key))</span><br><span class="line">ret = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">while</span> pq:</span><br><span class="line">ret.append(heapq.heappop(pq)[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_3</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 3. 桶排序</span></span><br><span class="line">freq_dict = <span class="built_in">dict</span>() <span class="comment"># 统计元素频率</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">freq_dict[num] = freq_dict.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+ <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> freq_dict.items():</span><br><span class="line">bucket[value].append(key)</span><br><span class="line">ret = <span class="built_in">list</span>() <span class="comment">#  逆序取出前k个元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(nums))):</span><br><span class="line"><span class="keyword">if</span> bucket[i]:</span><br><span class="line">ret.extend(bucket[i])</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ret)&gt;=k:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> ret[:k]</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ol><li>排序</li></ol><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(n)$ : 最极端的情况下（每个元素都不同），用于存储元素及其频率的map需要存储n个键值对</li></ul><ol><li>堆排序</li></ol><ul><li>时间复杂度：$O(nlogk)$ 其中n表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是O(n);接着，遍历用于存储元素频率的map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这一系列操作的时间复杂度是O(nlogk)的；最后，弹出堆中的元素所需要的时间复杂度O(klogk)。因此总的时间复杂度是O(nlogk)</li><li>空间复杂度：$O(n)$</li></ul><ol><li>桶排序</li></ol><ul><li>时间复杂度：$O(n)$ 数组的长度</li><li>空间复杂度：$O(n)$</li></ul><h2 id="3-LC75-颜色分类-颜色分类"><a href="#3-LC75-颜色分类-颜色分类" class="headerlink" title="3. (LC75) 颜色分类 颜色分类"></a>3. (LC75) 颜色分类 <a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></tbody></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>三路快排</li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul><li>在快排的基础上，将组数分为三个部分，及大于、等于、小于三个部分，其中大于和小于部分继续递归快排  </li><li>（lc官方解题）我们使用一个指针ptr表示头部位置的范围，ptr中存储了一个整数，表示数组nums从位置0到位置ptr - 1都属于【头部】。ptr的初始值为0，表示还没数处于【头部】。 在第一次遍历中，我们从左向右遍历整个数组，如果找到了0，那么就需要将0与【头部】位置的元素位置进行交换，并将【头部】向后扩充一位，结束后头部只有0。第二次同上。但是我们想要一次遍历怎么办，我们就要俩个指针。 </li><li>我们用指针p0 来交换 0， p1来交换1，初始值都是0。当从左向右遍历整个数组时:<br>  (1) 如果找到1， 那么将其与nums[p1]进行交换，并将p1向后移动一个位置。<br>  （2) 如果找到了0， 那么将其与nums[p0]交换的话，可能把1也交换出去。当p0 &lt; p1时，我们需要再将nums[i] 与nums[p1]进行交换，其中</li></ul><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>双指针</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        p0 = p1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                nums[i] , nums[p1] = nums[p1] , nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i] , nums[p0] = nums[p0] , nums[i]</span><br><span class="line">                <span class="keyword">if</span> p0 &lt; p1:</span><br><span class="line">                    nums[i] , nums[p1] = nums[p1] , nums[i]</span><br><span class="line">                p0+=<span class="number">1</span></span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="大佬解题"><a href="#大佬解题" class="headerlink" title="大佬解题"></a>大佬解题</h3><ol><li><a href="https://www.cnblogs.com/xugenpeng/p/9950007.html#%E6%8F%8F%E8%BF%B0">【LeetCode题解】347_前K个高频元素（Top-K-Frequent-Elements）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>经典到默写的</title>
    <link href="http://watermelondrip.github.io/2021/03/18/%E7%86%9F%E5%88%B0%E9%BB%98%E5%86%99/"/>
    <id>http://watermelondrip.github.io/2021/03/18/%E7%86%9F%E5%88%B0%E9%BB%98%E5%86%99/</id>
    <published>2021-03-17T13:52:00.000Z</published>
    <updated>2021-03-23T12:43:25.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>默写吧<br><span id="more"></span></p><h2 id="1-基于分治的快速排序"><a href="#1-基于分治的快速排序" class="headerlink" title="1. 基于分治的快速排序"></a>1. 基于分治的快速排序</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul><li>每次取list 的第一个元素，把剩下的元素与第一个元素比较，此时生成两个list,less中存放的就是余下的所有比第一个元素小的list, greater 中存放的是余下的所有比第一个元素大的list。然后循环递归，当基线条件只有一个元素或0个元素时停止，并返回结果。</li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def quick_sort(arr):</span><br><span class="line">if len(arr)&lt;2:</span><br><span class="line">return arr</span><br><span class="line">else:</span><br><span class="line">pivot = arr[0]</span><br><span class="line">less = [i for i in arr[1:] if i&lt;=pivot]  </span><br><span class="line">greater = [i for i in arr[1:] if i&gt;pivot]</span><br><span class="line">return quick_sort(less) + pivot + quick_sort(greater)</span><br><span class="line">if __name__ == "__main__":</span><br><span class="line"> </span><br><span class="line">    arr = [5,7,9,3,6,1,4,2]</span><br><span class="line">print(quick_sort(arr))</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/watermelon.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ2OTAxNS8yMDE5MDMvMTQ2OTAxNS0yMDE5MDMyNjE4MTQ1MzY3My0xODk3MDkyNTUwLnBuZw?x-oss-process=image/format,png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;默写吧&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://watermelondrip.github.io/2021/03/18/%E8%B4%AA%E5%BF%83/"/>
    <id>http://watermelondrip.github.io/2021/03/18/%E8%B4%AA%E5%BF%83/</id>
    <published>2021-03-17T13:52:00.000Z</published>
    <updated>2021-03-26T01:46:14.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md">贪心</a></h2><p>思路是：(1) 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的 (2)贪心算法一般是先需要排序的。<br><span id="more"></span></p><h2 id="1-LC455-分发饼干-分发饼干"><a href="#1-LC455-分发饼干-分发饼干" class="headerlink" title="1. (LC455) 分发饼干 分发饼干"></a>1. (LC455) 分发饼干 <a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></tbody></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>排序+贪心：我觉得这个也很好想，因为我们要求分配给最多的小孩的数量，肯定是可着吃的少的孩子先来。因为一个大胖子吃10斤的，可以给10个吃一斤的孩子啊。</p></li><li><p>贪心贪在哪里：</p><ul><li>在示例中可以看到，在计算起点的时候，一定从g[i] 最小的开始计算， 也就是优先给需求低的分配最下尺寸的饼干，这就是贪心的地方。</li><li>局部最优：每个小孩得到的饼干最少化，多一点都不给，多给浪费的呀</li><li>全局最优：保障让每一个饼干刚好满足当前的小朋友，就可以使得最后满足的人数最多。</li></ul></li></ul><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: List[<span class="built_in">int</span>], s: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(g) <span class="comment">#greed factor</span></span><br><span class="line">        m = <span class="built_in">len</span>(s) <span class="comment">#size</span></span><br><span class="line">        i = <span class="number">0</span> </span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;m <span class="keyword">and</span> i&lt;n:</span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> g[i]&gt;s[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; m:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度： $O( m log m + n logn)$ 其中m和n分别是数组g和s的长度。对两个数组排序的时间复杂度是 $O(mlogm+nlogn)$，遍历数组的时间复杂度是$O(m+n)$。</li><li>空间复杂度：$O(log m + log n)$ 其中m和n分别是数组g和s的长度。主要是排序的额外空间开销。</li></ul><h2 id="2-LC435-无重叠区间-无重叠区间"><a href="#2-LC435-无重叠区间-无重叠区间" class="headerlink" title="2. (LC435) 无重叠区间 无重叠区间"></a>2. (LC435) 无重叠区间 <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></tbody></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>排序+贪心：这个题还是排序+贪心。为什么这么说呢，首先区间边界没有相互重叠，和第一题的分饼干相似。这种类型的题的思路是，每一步都选的很小心，生怕影响后面的人。</li></ol><h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        points = <span class="built_in">sorted</span>(points,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        print(points)</span><br><span class="line">        right = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt;right:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">                right = points[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度： $O(n logn)$ 其中n是数组的长度。 </li><li>空间复杂度：$O(log n)$  </li></ul><h2 id="3-LC406-根据身高重建队列-根据身高重建队列"><a href="#3-LC406-根据身高重建队列-根据身高重建队列" class="headerlink" title="3. (LC406) 根据身高重建队列 根据身高重建队列"></a>3. (LC406) 根据身高重建队列 <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">根据身高重建队列</a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。<br>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></tbody></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>排序+贪心： </li></ol><h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x:(-x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(people) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> people</span><br><span class="line">        <span class="comment">## 对队列排序，先按h降序，再按k升序</span></span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        new_people = [people[<span class="number">0</span>]]    <span class="comment"># 这个人是从前往后、从上往下看到的第一个人</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> people[<span class="number">1</span>:]:</span><br><span class="line">            new_people.insert(i[<span class="number">1</span>], i)</span><br><span class="line">        <span class="keyword">return</span> new_people</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度： $O(n^2)$，其中n是数组people的长度。我们需要O(n log n) 的时间进行排序，随后需要O(n^2)的时间遍历每一个人并将他们放入队列中。由于前者在渐近意义下小于后者，因此总时间复杂度为  O(n^2)</li><li>空间复杂度：$O( log n )$  </li></ul><h2 id="4-LC53-最大子序和-最大子序和"><a href="#4-LC53-最大子序和-最大子序和" class="headerlink" title="4. (LC53) 最大子序和 最大子序和"></a>4. (LC53) 最大子序和 <a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例1：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>-贪心， 贪心竟然这么难想</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ul><li>贪心贪在哪里（<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/53-zui-da-zi-xu-he-bao-li-tan-xin-dong-t-jkeq/">详解</a>）？<ul><li>如果在示例中可以看到 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心的地方！</li><li>局部最优：当前 “ 连续和 ”为负数的时候立即放弃，从下一个元素重新计算 “ 连续和 ”， 因为负数加上下一个“连续和”只会越来越小。</li><li>全局最优：选取最大“连续和”  </li><li>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br><span class="line">        ans = -inf</span><br><span class="line">        result = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> ans&gt;<span class="number">0</span>:</span><br><span class="line">                ans += nums[i] </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = nums[i]</span><br><span class="line">            result = <span class="built_in">max</span>(result,ans)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="5-LC53-用最少数量的箭引爆气球-用最少数量的箭引爆气球"><a href="#5-LC53-用最少数量的箭引爆气球-用最少数量的箭引爆气球" class="headerlink" title="5. (LC53) 用最少数量的箭引爆气球 用最少数量的箭引爆气球"></a>5. (LC53) 用最少数量的箭引爆气球 <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/">用最少数量的箭引爆气球</a></h2><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例1：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</span><br></pre></td></tr></tbody></table></figure><h2 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><p>-贪心+排序</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                   [10.........16]</span><br><span class="line">   [2..........8]</span><br><span class="line">[1.......6]</span><br><span class="line">            [7.........12]</span><br></pre></td></tr></tbody></table></figure><ul><li>贪心贪在<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/tu-jie-tan-tao-wei-shi-yao-yao-an-qu-jian-de-you-d/">哪里</a>？</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        points = <span class="built_in">sorted</span>(points,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        print(points)</span><br><span class="line">        right = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt;right:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">                right = points[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;贪心&quot;&gt;&lt;a href=&quot;#贪心&quot; class=&quot;headerlink&quot; title=&quot;贪心&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md&quot;&gt;贪心&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;思路是：(1) 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的 (2)贪心算法一般是先需要排序的。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="排序" scheme="http://watermelondrip.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆" scheme="http://watermelondrip.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>声学信号处理系列（二）说话人识别</title>
    <link href="http://watermelondrip.github.io/2021/03/13/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%971_%E8%AF%B4%E8%AF%9D%E4%BA%BA%E8%AF%86%E5%88%AB/"/>
    <id>http://watermelondrip.github.io/2021/03/13/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%971_%E8%AF%B4%E8%AF%9D%E4%BA%BA%E8%AF%86%E5%88%AB/</id>
    <published>2021-03-12T13:00:00.000Z</published>
    <updated>2021-03-20T06:19:35.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="声学信号处理系列（二）说话人识别"><a href="#声学信号处理系列（二）说话人识别" class="headerlink" title="声学信号处理系列（二）说话人识别"></a>声学信号处理系列（二）说话人识别</h1><p><em>by max</em></p><p><em>2021/03/13</em></p><p>“闻其声，知其人”</p><p>说话人识别(speaker recognition)是语音信号处理中一个非常贴近实际生活应用的研究领域，其主要目的是通过对语音信号进行处理来对讲话者的身份进行识别、确认和分类。除了通过一个人的长相，我们也可以通过其声音，来在众多讲话人中将某一特定说话人认出来。这背后的主要原理，是利用语音中承载的与每个人类个体身份有关的声学信息来实现的。在系列第一篇文章里我们介绍了声学信号的一些基本特征，例如共振峰等，就可以作为识别说话人的依据。更多的具体原理我们在后面会介绍，首先来看说话人识别的两个基本任务。</p><h2 id="1-说话人识别的两个基本任务"><a href="#1-说话人识别的两个基本任务" class="headerlink" title="1.说话人识别的两个基本任务"></a>1.说话人识别的两个基本任务</h2><p>说话人识别可以分为说话人辨认(speaker identification)和说话人确认(speaker verification)两个基本任务[1]。在说话人辨认中，给定一条语音，我们需要在已注册的说话人中找到这句话是谁说的。而在说话人确认中，我们需要对说话人所声明的身份进行核验，确认其身份是否真实。一个比较形象的示意图如下所示：</p><p><img src= "/img/watermelon.gif" data-lazy-src="https://i.loli.net/2021/03/20/zVXIacumEiJLqlb.png" style="zoom:80%"></p><h2 id="2-说话人辨认"><a href="#2-说话人辨认" class="headerlink" title="2.说话人辨认"></a>2.说话人辨认</h2><p>一般在说话人辨认任务中，我们对来自一条未知说话人的语音进行处理和分析，将其与已注册的各个已知说话人的模型进行比对。当我们找到一个最佳匹配的说话人模型时，就认为该未知语音是来自该最佳匹配模型背后的说话人。换句话说，我们可以把说话人辨认看做是一个1对N的分类任务，我们需要将1条未知的测试样例，正确归类入N个已知类别其中的一个类别里。</p><p>那么不难想到，假如说话人辨认系统接收到的语音，与所有已注册说话人的模型全部不匹配该怎么办？这种情况我们称之为“开集说话人辨认问题”，即未知语音可能来自于说话人注册集集外的某个说话人，该说话人的身份并没有提前保存于系统模型匹配库中。此时系统是无法对该语音进行正确分类的，一般会将其归类于“其他”或者是“未授权用户”这种类别里。与之相对的就是“闭集说话人辨认问题”，未知语音已知肯定来自于某个已注册的说话人。一般来说，闭集系统比较适用于人数较少的应用场景，例如政府机关或私人安保场景等等。而开集系统则广泛部署于各类生活场景中[2]。</p><h2 id="3-说话人确认"><a href="#3-说话人确认" class="headerlink" title="3.说话人确认"></a>3.说话人确认</h2><p>在说话人确认任务中，我们需要通过一条语音去确定一个说话人的身份是其所声明的真实身份。实现原理是，我们将该条语音去与其声明的说话人模型进行对比，符合该身份则判定接受，否则判定拒绝。这里我们与说话人辨认对比的话，可以看到说话人确认其实本质是一个1对1的分类任务。</p><p>在与声明的说话人模型进行比对时，由于判决分数一般在一个连续数值范围内，所以我们需要设立一个固定的阈值来帮助判定。当判决分数高于该阈值时，判定为接受，反之，当判决分数低于该阈值时，判定为拒绝。这个阈值的选取，对于说话人确认系统的准确性十分重要。阈值定的过高，则可有助于减小误检率，即“将本该拒绝的误判为接受”(漏检false acceptance)这种情况的发生次数减少。但也会导致“将本该接受的误判为拒绝”(误检false rejection)这种情况发生的风险变大。那么反之，假如阈值设置得过低，则“将本该拒绝的误判为接受”这种情况的几率会上升。</p><h2 id="4-两个任务的区别和联系"><a href="#4-两个任务的区别和联系" class="headerlink" title="4.两个任务的区别和联系"></a>4.两个任务的区别和联系</h2><p>Speaker identification 和 speaker verification 的主要区别在于二者需要进行判决的类别数目的不同。具体说来，在说话人辨认里，我们需要在N个可能的结果中选择一个，N这里等于说话人的人数；而在说话人确认里，我们只需要在“接收”和“拒绝”两个可能的结果中选择一个，而不用考虑系统所面对的说话人的人数。因此，当N越大时，说话人辨认系统的性能会随之下降，而说话人确认系统的性能是不受N的影响的。极端情况时，当某个说话人群体的集体声学特性比较特殊时，说话人确认系统的准确性也会受影响。举个例子，一个主要为英语国家人群服务的说话人确认系统，可能当面对汉语国家人群时，系统的准确性会有所下降。</p><h2 id="5-系统评价指标"><a href="#5-系统评价指标" class="headerlink" title="5.系统评价指标"></a>5.系统评价指标</h2><p>说话人辨认系统的评价指标与通常的分类任务的评价指标是类似的，这里我们暂时只介绍说话人确认系统的评价指标。有对说话人辨认评价指标感兴趣的读者可以参考此博客[3]以便了解更多。</p><p>通常，我们使用DET曲线去衡量一个说话人确认系统的有效性。DET曲线全称为 Detection Error Trade-off曲线。该曲线可以通过计算FRR(false rejection rate，也可称为false negative rate)和FAR(false acceptance rate，也可称为false positive rate)这两种事件的概率来描绘出来。在一个二维图纸上，我们令纵轴代表FRR，横轴代表FAR，即可画出类似下图的DET曲线图。</p><p><img src= "/img/watermelon.gif" data-lazy-src="https://i.loli.net/2021/03/20/2zIguxCaSl9DcNX.png" style="zoom:150%"></p><p>图中红色曲线为DET曲线，其与蓝色对角线的交叉点，定义为EER(equal error rate)点，在该点上FRR=FAR。一般EER的值越低，代表一个系统的性能越好。通常我们将横纵轴的数值以对数尺度进行转换，以便能更全面更直观地观察到系统在一个大范围上的表现。</p><h2 id="6-文本有关-vs-文本无关"><a href="#6-文本有关-vs-文本无关" class="headerlink" title="6.文本有关 vs 文本无关"></a>6.文本有关 vs 文本无关</h2><p>一个说话人识别系统，可以基于文本相关去设计，也可以基于文本无关。顾名思义，文本相关指的是说话人需要讲出固定的一句话，来让系统进行验证。而文本无关的系统里，说话人可以说出任意一句话，来令识别系统进行分析处理。文本无关相比文本有关的系统，使用场景更灵活方便，但安全性方面会有一定的下降。系统的设计难度上，文本有关的系统相对较简单一些，我们可以沿着时间轴按顺序检验每个文本单元的声学特征，将其与说话人已注册的声纹进行匹配，根据该句话从头到尾的累积准确率，最终以达到识别的目的。由于这种文本有关的设计与每个音素音节在时间上强相关，所以基于该方法设计的系统通常可以取得比文本无关的系统更高的识别率。</p><p>相比下来，文本无关的系统常应用于法庭取证或者安保监控等场景，此类场景无法要求说话人提供指定文本段的语音样本，所以基于文本无关的系统的重要性也正在逐渐进入公众视野。而且，基于文本无关的识别系统，更符合人类自然的识别能力，我们不需要身边的亲人朋友说出指定的话语就可以轻松地识别出他们的身份，同理，当我们听到一句来自陌生人的语音时，我们也能很快地识别出我们不认识该说话人。而且这种识别系统也更人性化，当识别前端接收到的语音有卡顿或者遗漏时，不需要说话人不停地重复识别口令，减少了识别耗费的时间成本，使用场景也更广泛和人性化。</p><p>除了文本有关和文本无关这两大类系统以外，还有一个文本提示型系统(text-prompted)。该系统的提出主要是为了更进一步的提升识别系统的鲁棒性。文本无关和文本相关的系统可能会面临一个实际性的安全问题，就是会有“黑客”可能想冒充某个特定说话人的身份，去入侵说话人识别系统。具体手段通常会使用录音回放设备，提前取得已注册说话人的语音口令，然后回放给说话人识别系统进而取得授权。因此，文本提示型系统里，系统会随机生成一串数字或一句文本，待识别人只需要跟着给出的提示念出语音即可。</p><h2 id="7-结语"><a href="#7-结语" class="headerlink" title="7.结语"></a>7.结语</h2><p>说话人识别系统是语音识别领域的一个主要方向，基于该系统设计的各种安防系统和应用APP已经在日常生活中比较常见了。虽然有文本提示型识别系统来提升识别系统的鲁棒性和安全性，但说话人识别系统近年来正面临着越来越严峻的安全问题。</p><p>在博客系列的下一篇文章中，我们会介绍与说话人识别相关的另一个新领域 — “说话人识别反欺骗系统”。</p><h2 id="参考资料列表"><a href="#参考资料列表" class="headerlink" title="参考资料列表"></a>参考资料列表</h2><p>[1] “Speaker recognition”词条 — <a href="http://www.scholarpedia.org/article/Speaker_recognition#Speaker_Identification_and_Verification">http://www.scholarpedia.org/article/Speaker_recognition#Speaker_Identification_and_Verification</a><br>[2] Togneri, R., &amp; Pullella, D. (2011). An overview of speaker identification: Accuracy and robustness issues. IEEE circuits and systems magazine, 11(2), 23-61.<br>[3] “The 5 Classification Evaluation metrics every Data Scientist must know” — <a href="https://towardsdatascience.com/the-5-classification-evaluation-metrics-you-must-know-aa97784ff226">https://towardsdatascience.com/the-5-classification-evaluation-metrics-you-must-know-aa97784ff226</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="声学信号处理" scheme="http://watermelondrip.github.io/tags/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode竞赛(第231场周赛)</title>
    <link href="http://watermelondrip.github.io/2021/03/07/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B231/"/>
    <id>http://watermelondrip.github.io/2021/03/07/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B231/</id>
    <published>2021-03-07T07:35:12.750Z</published>
    <updated>2021-03-07T07:48:34.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 就做出来第一题和第二题<br> <span id="more"></span></p><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>(5697.检查二进制字符串字段)[<a href="https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/">https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/</a>]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二进制字符串 s ，该字符串不含前导零 。</p><p>如果 s 最多包含 一个由连续的 ‘1’ 组成的字段 ，返回 true​​​ 。否则，返回 false 。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "1001"</span><br><span class="line">输出：false</span><br><span class="line">解释：字符串中的 1 没有形成一个连续字段。</span><br></pre></td></tr></tbody></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>出现01字符串就输出错误</li><li>如果一直为0，则可以</li></ol><h2 id="反省"><a href="#反省" class="headerlink" title="反省"></a>反省</h2><ol><li>这次这个题真不难，但是看题的时候没看明白题。 本题的意思是只要有一个1就算是连续字段，比如“10011”, 输出也是false。 因为第一个数字1就已经算是一个由1组成的字符串了，后面的11是第二个连续1的字段了。</li><li>map()函数完全可以不用啊，但是既然用了，还不熟知识点那块还是记录一下吧。</li></ol><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>map函数的原型是map(function,iterable,…)，它的返回结果是一个列表。 参数function传的是一个函数名，可以是python内置的，也可以是自定义的。参数iterable传的是一个可以迭代的对象，例如列表，元组，字符串。  这个函数的意思是将function应用于iterable的每一个元素，结果以列表的形式返回。 注意到后面，iterable后面有省略号，意思是可以传很多个iterable，如果有额外的iterable参数，并行的从这些参数中取出元素，并调用function。如果一个iterable 参数比另外的iterable参数要短，将以None扩展参数元素</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">c=<span class="string">"zhangkang"</span></span><br><span class="line"></span><br><span class="line">la=<span class="built_in">map</span>(<span class="built_in">str</span>,a)</span><br><span class="line">lb=<span class="built_in">map</span>(<span class="built_in">str</span>,b)</span><br><span class="line">lc=<span class="built_in">map</span>(<span class="built_in">str</span>,c)</span><br><span class="line"></span><br><span class="line">print(la)</span><br><span class="line">print(lb)</span><br><span class="line">print(lc)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line">[<span class="string">'z'</span>, <span class="string">'h'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>, <span class="string">'k'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>] </span><br></pre></td></tr></tbody></table></figure><p>str()是Python的内置函数，这个例子是把列表/元组/字符串的每个元素变成了str 类型，然后以列表的形式返回。当然我们也可以传入自定义的函数</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">n=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">res=<span class="built_in">map</span>(mul,n)</span><br><span class="line">输出：[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>] </span><br></pre></td></tr></tbody></table></figure><p>把列表n中的每个元素运行一次mul函数后得到的结果作为最终结果列表的元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list3=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">res=<span class="built_in">map</span>(add,list1,list2,list3)</span><br><span class="line">print(res)</span><br><span class="line">输出：[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>] </span><br></pre></td></tr></tbody></table></figure><p>并行的从三个列表中各自取出元素然后运行add函数，有人可能会问，如果三个列表长度不一样怎么办，前面已经说了，对于短的那个iterable参数会用None填补。对于上面的例子，如果list3=[1,2]的话，那么这个程序会报错，因为虽然在运行add函数的时候列表list3的最后一个元素会用None填补，但是None和int类型的数是不能相加的。也就是说，除非参数function支持None的运算，否则根本没意义。现在我们看下另一个例子你就明白了<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x,y,z</span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">list3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">res = <span class="built_in">map</span>(add, list1, list2, list3)</span><br><span class="line">print(res)</span><br><span class="line">输出：</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="literal">None</span>, <span class="number">4</span>, <span class="number">4</span>), (<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">5</span>)]</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOnesSegment</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span>  <span class="comment">#大佬解题</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s.count(<span class="string">'01'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOnesSegment</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span>  <span class="comment"># 本菜</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        s= <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,s))   <span class="comment">#不用map这行      </span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[r] == s[<span class="number">0</span>] <span class="keyword">and</span> r == <span class="number">1</span>:  <span class="comment"># s[r] == '1'</span></span><br><span class="line">                <span class="keyword">while</span> r&lt;n <span class="keyword">and</span> s[r] == s[<span class="number">0</span>]:</span><br><span class="line">                    r+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[r]!= s[<span class="number">0</span>]:</span><br><span class="line">                r+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h1 id="2-题目"><a href="#2-题目" class="headerlink" title="2. 题目"></a>2. 题目</h1><p>(5698.构成特定和需要添加的最少元素)[<a href="https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum/">https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum/</a>]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。<br>返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。<br>注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,-1,1], limit = 3, goal = -4</span><br><span class="line">输出：2</span><br><span class="line">解释：可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 = -4 。</span><br></pre></td></tr></tbody></table></figure><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>除法：</p><ul><li><p>传统除法：如果是整数除法则执行地板除，如果是浮点除法则执行精确除法<br><code>&gt;&gt;&gt;1/2   &gt;&gt;&gt;0   &gt;&gt;&gt;1.0/2.0 &gt;&gt;&gt;0.5</code></p></li><li><p>地板除法：//除法不管操作数为何种数值类型，总是会舍去小数部分，返回数字序列中比真正的商小的最接近的数字<br>`&gt;&gt;&gt;1//2  &gt;&gt;&gt;0   &gt;&gt;&gt;-1//2  &gt;&gt;&gt;-‘</p></li></ul></li><li><p>ceil,floor,round</p><ul><li>ceil() 将小数部分一律向整数部分进位，函数返回数字的上入整数 ‘ceil(-45.17): -45’</li><li>floor() 一律舍去，仅保留整数</li><li>round() 四舍五入</li></ul></li></ol><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>小学数学，反正这类的题要先手写几个例子 </li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul><li>语言支持：Python3</li></ul><p>Python3 Code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minElements</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], limit: <span class="built_in">int</span>, goal: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> ceil(<span class="built_in">abs</span>(goal - <span class="built_in">sum</span>(nums)) / limit)</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>令 n 为数组长度。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; 就做出来第一题和第二题&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://watermelondrip.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="竞赛" scheme="http://watermelondrip.github.io/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Day 1 - Max</title>
    <link href="http://watermelondrip.github.io/2021/03/06/firstday_max/"/>
    <id>http://watermelondrip.github.io/2021/03/06/firstday_max/</id>
    <published>2021-03-06T04:55:07.240Z</published>
    <updated>2021-03-06T09:14:53.171Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p><em>by max</em></p><p><em>2021/02/28</em></p><p>这是在MAX的瓜园写下的第一篇日志，没有具体的内容，仅供测试使用。<br><span id="more"></span></p><p><strong>建立这个博客网页的主要目的是为了记录刷题过程中的收获，包括题解、算法思路和一些相关资料等。</strong></p><p><code>此网站也会收藏一些平日学习和工作中有价值的资料</code></p><p>网站仍在建设中，更多功能会逐步完善，包括评论功能等，敬请期待！！！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;Day 1&quot;&gt;&lt;/a&gt;Day 1&lt;/h1&gt;&lt;p&gt;&lt;em&gt;by max&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021/02/28&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是在MAX的瓜园写下的第一篇日志，没有具体的内容，仅供测试使用。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="学习笔记" scheme="http://watermelondrip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的分析</title>
    <link href="http://watermelondrip.github.io/2021/03/06/dataStructure/"/>
    <id>http://watermelondrip.github.io/2021/03/06/dataStructure/</id>
    <published>2021-03-06T04:55:07.239Z</published>
    <updated>2021-03-06T09:15:07.575Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据结构<br><span id="more"></span></p><ol><li>内存的物理表现的一系列连续的内存单元，每个内存单元大小是固定的。数据结构只有两个对应基础的数据结构，数组和链表，其他的数据结构都是由他们产生的。</li><li>数组用来表示连续的内存空间，链表通常用来表示不连续的内存空间。</li><li>不连续内存空间的意思是，链表有数据域和指针域。</li></ol><hr><h2 id="算法的性能"><a href="#算法的性能" class="headerlink" title="算法的性能"></a>算法的性能</h2><h2 id="1-一个程序的运行时间主要主要是两个因素：（1）执行每条语句的耗时（2）执行每条语句的频率。"><a href="#1-一个程序的运行时间主要主要是两个因素：（1）执行每条语句的耗时（2）执行每条语句的频率。" class="headerlink" title="1. 一个程序的运行时间主要主要是两个因素：（1）执行每条语句的耗时（2）执行每条语句的频率。"></a>1. 一个程序的运行时间主要主要是两个因素：（1）执行每条语句的耗时（2）执行每条语句的频率。</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li>操作简单和支持随机访问</li><li>数组是一段连续的地址空间</li><li>数组使用连续的内存空间，来存储一系列同一数据类型的值。</li></ol><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol><li>栈是一种受限的数据结构，LIFO</li><li>常用操作：进栈push, 出栈pop，取栈顶top，isEmply</li><li>是一种逻辑结构</li><li>给数组和链表增加一个限制就是队列</li></ol><hr><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ol><li>也是一种逻辑结构</li><li>给数组和链表增加一个限制就是队列</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据结构&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="数据结构" scheme="http://watermelondrip.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="学习笔记" scheme="http://watermelondrip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>python 里 sort(),sorted() 的排序算法 -- Timsort简介</title>
    <link href="http://watermelondrip.github.io/2021/03/06/python%E9%87%8Csort%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://watermelondrip.github.io/2021/03/06/python%E9%87%8Csort%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-06T00:03:00.000Z</published>
    <updated>2021-03-26T00:51:26.927Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>python里sort排序是一种名为Timsort的排序方法，其时间复杂度为$O(nlogn)$, 而且这是一种快速的稳定排序方法。<br>一个算法的稳定主要是：在假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则这种排序算法是稳定的；否则成为不稳定的。通俗的说， 就是两个相同的值，在排序位置不发生交换，就说稳定的，否则就说不稳定的。在一些条件下，稳定和不稳定也是相对的。</p><h2 id="sort-用法-和-sorted-用法的不同"><a href="#sort-用法-和-sorted-用法的不同" class="headerlink" title="sort()用法 和 sorted()用法的不同"></a>sort()用法 和 sorted()用法的不同</h2><ol><li>sort()只能用在列表list上，比如list.sort()。 sorted()is a global function。</li><li>list.sort is insitu，也就是说不增加一个拷贝，也就是说在原list上进行sort。  sorted增加一个新的copy，与原先的list 无关。</li></ol><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>((<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>({<span class="string">'one'</span>:<span class="number">1</span>, <span class="string">'two'</span>:<span class="number">2</span>,<span class="string">'three'</span>:<span class="number">3</span>,<span class="string">'four'</span>:<span class="number">4</span>,<span class="string">'five'</span>:<span class="number">5</span>})</span><br><span class="line">[<span class="string">'five'</span>, <span class="string">'four'</span>, <span class="string">'one'</span>, <span class="string">'three'</span>, <span class="string">'two'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">'this is a string'</span>)</span><br><span class="line">[<span class="string">' '</span>, <span class="string">' '</span>, <span class="string">' '</span>, <span class="string">'a'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'i'</span>, <span class="string">'i'</span>, <span class="string">'n'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'s'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'t'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="大佬blog"><a href="#大佬blog" class="headerlink" title="大佬blog"></a>大佬blog</h3><ol><li><a href="http://https://blog.csdn.net/u010883226/article/details/84403263"> “Python里sort（）的排序算法—Timsort简介”</a></li><li><a href="https://discuss.codecademy.com/t/what-is-the-difference-between-sort-and-sorted/349679/7">What is the difference between sort() and sorted()?</a></li><li><a href="https://www.jianshu.com/p/6b7806c4f54a">Python中的iterable该怎么理解</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="python" scheme="http://watermelondrip.github.io/tags/python/"/>
    
    <category term="排序" scheme="http://watermelondrip.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>第一天坚持坚持</title>
    <link href="http://watermelondrip.github.io/2021/02/27/firstday/"/>
    <id>http://watermelondrip.github.io/2021/02/27/firstday/</id>
    <published>2021-02-27T05:19:03.000Z</published>
    <updated>2021-03-06T09:15:37.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次记录一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="知识及记录" scheme="http://watermelondrip.github.io/categories/%E7%9F%A5%E8%AF%86%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="学习笔记" scheme="http://watermelondrip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
