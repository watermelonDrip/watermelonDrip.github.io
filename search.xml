<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构的分析</title>
    <url>/2021/03/06/dataStructure/</url>
    <content><![CDATA[<p>数据结构</p>
<span id="more"></span>

<ol>
<li>内存的物理表现的一系列连续的内存单元，每个内存单元大小是固定的。数据结构只有两个对应基础的数据结构，数组和链表，其他的数据结构都是由他们产生的。</li>
<li> 数组用来表示连续的内存空间，链表通常用来表示不连续的内存空间。</li>
<li>不连续内存空间的意思是，链表有数据域和指针域。</li>
</ol>
<hr>
<h2><span id="算法的性能">算法的性能</span></h2><ol>
<li>一个程序的运行时间主要主要是两个因素：（1）执行每条语句的耗时（2）执行每条语句的频率。</li>
</ol>
<hr>
<h2><span id="数组">数组</span></h2><ol>
<li>操作简单和支持随机访问</li>
<li>数组是一段连续的地址空间</li>
<li>数组使用连续的内存空间，来存储一系列同一数据类型的值。</li>
</ol>
<hr>
<h2><span id="栈">栈</span></h2><ol>
<li>栈是一种受限的数据结构，LIFO</li>
<li>常用操作：进栈push, 出栈pop，取栈顶top，isEmply</li>
<li>是一种逻辑结构</li>
<li>给数组和链表增加一个限制就是队列</li>
</ol>
<hr>
<h2><span id="队列">队列</span></h2><ol>
<li>也是一种逻辑结构</li>
<li>给数组和链表增加一个限制就是队列</li>
</ol>
]]></content>
      <categories>
        <category>知识及记录</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 1 - Max</title>
    <url>/2021/03/06/firstday_max/</url>
    <content><![CDATA[<h1><span id="day-1">Day 1</span></h1><p><em>by max</em></p>
<p><em>2021/02/28</em></p>
<p>这是在MAX的瓜园写下的第一篇日志，没有具体的内容，仅供测试使用。</p>
<span id="more"></span>

<p><strong>建立这个博客网页的主要目的是为了记录刷题过程中的收获，包括题解、算法思路和一些相关资料等。</strong></p>
<p><code>此网站也会收藏一些平日学习和工作中有价值的资料</code></p>
<p>网站仍在建设中，更多功能会逐步完善，包括评论功能等，敬请期待！！！</p>
]]></content>
      <categories>
        <category>知识及记录</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第一天坚持坚持</title>
    <url>/2021/02/27/firstday/</url>
    <content><![CDATA[<p>第一次记录一下</p>
]]></content>
      <categories>
        <category>知识及记录</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode lc 395（至少有k个重复字符的最长子串）</title>
    <url>/2021/03/06/lc395/</url>
    <content><![CDATA[<p>至少有k个重复字符的最长子串</p>
<span id="more"></span>

<p>date: 2021-02-27 16:19:03</p>
<h2><span id="分类">分类</span></h2><ul>
<li>递归<h2><span id="题目地址">题目地址</span></h2></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/</a></p>
<h2><span id="题目描述">题目描述</span></h2><p>给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。（难度中等）
 </p>
<p>示例 1：</p>
<p>输入：s = “aaabb”, k = 3<br>输出：3<br>解释：最长子串为 “aaa” ，其中 ‘a’ 重复了 3 次。<br>示例 2：</p>
<p>输入：s = “ababbc”, k = 2<br>输出：5<br>解释：最长子串为 “ababb” ，其中 ‘a’ 重复了 2 次， ‘b’ 重复了 3 次。
 </p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 104<br>s 仅由小写英文字母组成<br>1 &lt;= k &lt;= 105</p>
<h2><span id="前置知识">前置知识</span></h2><ul>
<li><p>递归</p>
<h2><span id="公司">公司</span></h2></li>
<li><p>暂无</p>
</li>
</ul>
<h2><span id="解题思路">解题思路</span></h2><ul>
<li>首先我是没想出来，看了答案发现了这个思路</li>
<li>要连续子序列也就是想当于如果出现了个数最少的字母，我们需要从那个最少的字母那里断开这个序列，直到把所有少于k的字母全部断开，然后从断开的所有子序列里找个最长的</li>
</ul>
<ul>
<li>对于split 那个function 还是不太清晰，我觉得有必要我整理一下<ul>
<li>The split() method splits a string into a list. 比如： txt = “hello, my name is Peter, I am 26 years old”； x = txt.split(“, “)  output: x=[‘hello’, ‘my name is Peter’, ‘I am 26 years old’]<h2><span id="代码">代码</span></h2></li>
</ul>
</li>
</ul>
<ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubstring</span>(<span class="params">self, s, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)&lt;k:  <span class="comment">#base </span></span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s.count(c) &lt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>( self.longestSubstring(t, k) <span class="keyword">for</span> t <span class="keyword">in</span> s.split(c) )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>return 那块，前面self.longestSubstring，前面已经有self,后面的括号里就不要加了</li>
<li>s.split(c) 这个语句中，如果输入是“aaabb”. 输出是[“aaa”,”,”]</li>
</ul>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n<em>26)$  n(字符串长度)</em>(字符集) 因为递归最多26次（26个英文字母）</li>
<li>空间复杂度：$O(26^2)$  每层需要开辟26个字母的空间</li>
</ul>
<h2><span id="大佬解题">大佬解题</span></h2><ul>
<li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jiang-yuan-zi-fu-chuan-yi-shu-liang-bu-gou-de-zi-f/">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jiang-yuan-zi-fu-chuan-yi-shu-liang-bu-gou-de-zi-f/</a></li>
</ul>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2021/03/06/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>#双指针 (<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-two-sum">顺序</a>)</p>
<p>双指针用于遍历数组，两个指针指向不同的元素，从而共同的完成一个任务。</p>
<span id="more"></span>

<p>（1）共同完成一个和的target</p>
<p><strong>目录 (Table of Contents)</strong></p>
<p>[TOCM]</p>
<p>[TOC]</p>
<p>##1. (LC167) 两数之和 II - 输入有序数组   <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">两数之和II</a></p>
<h3><span id="题目">题目</span></h3><p>给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br> 示例 1：</p>
<p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
<h3><span id="思路">思路</span></h3><p>双指针<br>如何想到双指针，我觉得首先是这个数组是有序的，然后就是由两个数构成，这就想到了双指针了</p>
<h3><span id="python3-code">Python3 Code:</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt; right:</span><br><span class="line">            total = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> total &gt; target:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]                </span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：$O(n)$ 只是遍历了一次</li>
<li>空间复杂度：$O(1)$ 只用了两个额外的变量（不考虑输出变量空间，只考虑额外的）</li>
</ul>
<p>##2. (LC633) 两数平方和   <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">两数平方和</a></p>
<h3><span id="题目">题目</span></h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。</p>
<p>示例 1：</p>
<p>输入：c = 5<br>输出：true<br>解释：1 * 1 + 2 * 2 = 5<br>范围：0 &lt;= c &lt;= 2^31 - 1</p>
<h3><span id="思路">思路</span></h3><p>首先这个又是两个整数的，我们想如果出现两个整数共同来完成一件事，这两个整数在一个范围内，是不是都可以用双指针呢。<br>但是这里面有平方比较麻烦了，所以上面那个不是和吗，我想如果求出c的根号是不是在这附近的数就比较好找了</p>
<h3><span id="python3-code">Python3 Code:</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span>(<span class="params">self, c: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sqr</span>(<span class="params">c</span>):</span></span><br><span class="line">            x0 = c/<span class="number">2</span></span><br><span class="line">            x1 = x0/<span class="number">2</span> + c/(x0*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">abs</span>(x1-x0) &gt; <span class="number">1</span>:</span><br><span class="line">                x0 = x1</span><br><span class="line">                x1 = x0/<span class="number">2</span> + c/(x0*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> x1</span><br><span class="line">        right,left = <span class="built_in">int</span>(sqr(c)),<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            print(left**<span class="number">2</span> + right**<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> left**<span class="number">2</span> + right**<span class="number">2</span> &gt; c:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> left**<span class="number">2</span> + right**<span class="number">2</span> &lt; c:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> </span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度：$O(sqr(c)*n1)$ 只是遍历了一次 def sqrt(c)</p>
</li>
<li><p>空间复杂度：$O(1)$ 只用了两个额外的变量</p>
<p>##3. (LC345) 反转字符串中的元音字母<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" title="反转字符串中的元音字母">反转字符串中的元音字母</a>  </p>
<h3><span id="题目">题目</span></h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br>示例 1：<br>输入：”hello”<br>输出：”holle”</p>
<h3><span id="思路">思路</span></h3></li>
</ul>
<ol>
<li><p>首先使用双指针是因为，反转字符串中，是两个两个一对的换，通俗的意思是，如果是简单的反转字母是, ‘abc’ 反转之后变为 ‘cba’</p>
</li>
<li><p>有一个概念很重要，就是<a href="https://zhuanlan.zhihu.com/p/34395671" title="可变对象和不可变对象">可变对象和不可变对象</a><br> (1) 可变：list, dic, set （2）不可变：tuple, string, int, float, bool</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 不可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看出来，可变对象是可以直接被改变的，而不可变对象则不可以</p>
<h3><span id="python3-code">Python3 Code:</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">list</span>(s))&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        front = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        vowels = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;I&quot;</span>,<span class="string">&quot;O&quot;</span>,<span class="string">&quot;U&quot;</span>&#125; </span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> front&lt; end:</span><br><span class="line">            <span class="keyword">if</span> s[front] <span class="keyword">in</span> vowels <span class="keyword">and</span> s[end] <span class="keyword">in</span> vowels:</span><br><span class="line">                s[front], s[end] = s[end] , s[front]</span><br><span class="line">                front+=<span class="number">1</span></span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[front] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                front+=<span class="number">1</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>时间复杂度：$ $</li>
<li>空间复杂度：$ $  </li>
</ul>
<p>##4. (LC680)  验证回文字符串 Ⅱ <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" title="验证回文字符串 Ⅱ">验证回文字符串 Ⅱ</a></p>
<h3><span id="题目">题目</span></h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br>示例 1：<br>输入：”hello”<br>输出：”holle”</p>
<h3><span id="思路">思路</span></h3><ol>
<li>Lambda 函数<br>lambda 函数是一个小型匿名函数。lambda 函数可以接受任意数量的参数，但只能有一个表达式。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Function that returns square of any number</span></span><br><span class="line">&gt;&gt;&gt;sqr = <span class="keyword">lambda</span> x: x * x</span><br><span class="line">&gt;&gt;&gt;sqr(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">100</span></span><br></pre></td></tr></table></figure></li>
<li> 优美的一行代码<br><a href="https://zhuanlan.zhihu.com/p/345055254" title="25条很棒的Python一行代码，建议收藏！">25条很棒的Python一行代码，建议收藏！</a><h3><span id="python3-code">Python3 Code:</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> s: s == s[::-<span class="number">1</span>]</span><br><span class="line">        strPart = <span class="keyword">lambda</span> s, x: s[:x] + s[x + <span class="number">1</span>:]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strPart(s, left)) <span class="keyword">or</span> isPalindrome(strPart(s, right))</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>时间复杂度：$ $</li>
<li>空间复杂度：$ $</li>
</ul>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>排序 （熟到可以默写）</title>
    <url>/2021/03/06/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2><span id="排序顺序">排序</span></h2><p>思路是<br>（1）快速选择，用于求解第k个元素的问题<br>（2）堆:堆的中心就一个，那就是动态求极值。 堆可以用二叉树实现，叫做二叉堆。二叉堆的性质就是堆的性质不变。</p>
<span id="more"></span>

<p><strong>目录 (Table of Contents)</strong></p>
<p>[TOCM]</p>
<p>[TOC]</p>
<p>##1. (LC215) Kth Element <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">Kth Element</a></p>
<h3><span id="题目">题目</span></h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br> 示例 1：<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p>
<h3><span id="思路">思路</span></h3><ol>
<li>最简单的是排序想法，直接把数组排序，然后找到k个就好了</li>
<li>堆， 堆是一种数据结构，一个很牛的<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ge-chong-pai-xu-suan-fa-tu-xie-zong-jie-by-ke-ai-x/">题解</a>和一个英文<a href="https://towardsdatascience.com/data-structure-heap-23d4c78a6962">解释</a> 和一个中文<a href="https://guguoyu.blog.csdn.net/article/details/81283998?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs">解释</a></li>
<li><a href="https://docs.python.org/3/library/heapq.html">heapq</a> 模块： 可能在面试过程中，有的面试官不让用，但是这个heapq还是很方便的。 (1)hq.heapqpush(heap,item) ：压入堆的意思，压入的是item （2）hq.heappop(heap)：弹出且返回最小的。hq.heappushpop(heap,item):先压入iem，然后弹出堆里最小的项。</li>
</ol>
<h3><span id="python3-code">Python3 Code:</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findKthLargest1(self, nums: List[int], k: int) -&gt; int: #1. 排序</span><br><span class="line">        nums.sort()</span><br><span class="line">        return nums[-k]</span><br><span class="line">    def findKthLargest2(self, nums: List[int], k: int) -&gt; int: # 2. 最大堆  用heapq模块</span><br><span class="line">        import heapq as hq</span><br><span class="line">        heap &#x3D; []</span><br><span class="line">        for i in nums:</span><br><span class="line">            hq.heappush(heap,i)</span><br><span class="line">            if len(heap) &gt; k:</span><br><span class="line">                hq.heappop(heap)</span><br><span class="line">        return heap[0]</span><br><span class="line">    def findKthLargest3(self, nums: List[int], k: int) -&gt; int: # 最大堆， 构造堆模块</span><br><span class="line">        def min_heapify(array, i):</span><br><span class="line">            left &#x3D; 2 * i + 1</span><br><span class="line">            right &#x3D; 2 * i + 2</span><br><span class="line">            length &#x3D; len(array) - 1</span><br><span class="line">            smallest &#x3D; i</span><br><span class="line">            if left &lt;&#x3D; length and array[i] &gt; array[left]:</span><br><span class="line">                smallest &#x3D; left</span><br><span class="line">            if right &lt;&#x3D; length and array[smallest] &gt; array[right]:</span><br><span class="line">                smallest &#x3D; right</span><br><span class="line">            if smallest !&#x3D; i:</span><br><span class="line">                array[i], array[smallest] &#x3D; array[smallest], array[i]</span><br><span class="line">                min_heapify(array, smallest)</span><br><span class="line">        def build_min_heap(array):</span><br><span class="line">            for i in reversed(range(len(array)&#x2F;&#x2F;2)):</span><br><span class="line">                min_heapify(array, i)</span><br><span class="line">        def heapsort(array):</span><br><span class="line">            #array &#x3D; array.copy()</span><br><span class="line">            build_min_heap(array)</span><br><span class="line">            sorted_array &#x3D; []</span><br><span class="line">            for _ in range(len(array)):</span><br><span class="line">                array[0], array[-1] &#x3D; array[-1], array[0]</span><br><span class="line">                sorted_array.append(array.pop())</span><br><span class="line">                min_heapify(array, 0)</span><br><span class="line">            return sorted_array</span><br><span class="line">        result &#x3D; heapsort(nums)</span><br><span class="line">        return result[-k]</span><br><span class="line">      def findKthLargest4(self, nums: List[int], k: int) -&gt; int: # [快速排序](https:&#x2F;&#x2F;jackkuo666.github.io&#x2F;Data_Structure_with_Python_book&#x2F;chapter6&#x2F;section4.html)</span><br><span class="line">        def partition(alist, low ,high):</span><br><span class="line">            mid_value &#x3D; alist[low]</span><br><span class="line">            while low &lt; high:</span><br><span class="line"></span><br><span class="line">                while low &lt; high and alist[high] &gt;&#x3D; mid_value:</span><br><span class="line">                    high-&#x3D;1</span><br><span class="line">                alist[low] &#x3D; alist[high]</span><br><span class="line">                while low &lt; high and alist[low] &lt;&#x3D; mid_value:</span><br><span class="line">                    low+&#x3D;1</span><br><span class="line">                alist[high] &#x3D; alist[low]</span><br><span class="line">            alist[low] &#x3D; mid_value</span><br><span class="line">            return low</span><br><span class="line">        k &#x3D; len(nums) - k</span><br><span class="line">        low &#x3D; 0</span><br><span class="line">        high &#x3D; len(nums) -1</span><br><span class="line">        while low &lt;&#x3D; high:</span><br><span class="line">            p &#x3D; partition(nums,low ,high)</span><br><span class="line">            if k &lt; p:</span><br><span class="line">                high &#x3D; p - 1</span><br><span class="line">            elif k &gt; p:</span><br><span class="line">                low &#x3D; p + 1</span><br><span class="line">            else:</span><br><span class="line">                return nums[p]</span><br><span class="line">        return -1</span><br><span class="line">         </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>堆</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
