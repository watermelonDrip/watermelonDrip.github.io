<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构的分析</title>
    <url>/2021/03/06/dataStructure/</url>
    <content><![CDATA[<p>数据结构</p>
<span id="more"></span>

<ol>
<li>内存的物理表现的一系列连续的内存单元，每个内存单元大小是固定的。数据结构只有两个对应基础的数据结构，数组和链表，其他的数据结构都是由他们产生的。</li>
<li> 数组用来表示连续的内存空间，链表通常用来表示不连续的内存空间。</li>
<li>不连续内存空间的意思是，链表有数据域和指针域。</li>
</ol>
<hr>
<h2 id="算法的性能"><a href="#算法的性能" class="headerlink" title="算法的性能"></a>算法的性能</h2><ol>
<li>一个程序的运行时间主要主要是两个因素：（1）执行每条语句的耗时（2）执行每条语句的频率。</li>
</ol>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>操作简单和支持随机访问</li>
<li>数组是一段连续的地址空间</li>
<li>数组使用连续的内存空间，来存储一系列同一数据类型的值。</li>
</ol>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol>
<li>栈是一种受限的数据结构，LIFO</li>
<li>常用操作：进栈push, 出栈pop，取栈顶top，isEmply</li>
<li>是一种逻辑结构</li>
<li>给数组和链表增加一个限制就是队列</li>
</ol>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ol>
<li>也是一种逻辑结构</li>
<li>给数组和链表增加一个限制就是队列</li>
</ol>
]]></content>
      <categories>
        <category>知识及记录</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第一天坚持坚持</title>
    <url>/2021/02/27/firstday/</url>
    <content><![CDATA[<p>第一次记录一下</p>
]]></content>
      <categories>
        <category>知识及记录</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 1 - Max</title>
    <url>/2021/03/06/firstday_max/</url>
    <content><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p><em>by max</em></p>
<p><em>2021/02/28</em></p>
<p>这是在MAX的瓜园写下的第一篇日志，没有具体的内容，仅供测试使用。</p>
<span id="more"></span>

<p><strong>建立这个博客网页的主要目的是为了记录刷题过程中的收获，包括题解、算法思路和一些相关资料等。</strong></p>
<p><code>此网站也会收藏一些平日学习和工作中有价值的资料</code></p>
<p>网站仍在建设中，更多功能会逐步完善，包括评论功能等，敬请期待！！！</p>
]]></content>
      <categories>
        <category>知识及记录</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode lc 395（至少有k个重复字符的最长子串）</title>
    <url>/2021/03/06/lc395/</url>
    <content><![CDATA[<p>至少有k个重复字符的最长子串</p>
<span id="more"></span>

<p>date: 2021-02-27 16:19:03</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>递归<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串，&nbsp;要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。（难度中等）
&nbsp;</p>
<p>示例 1：</p>
<p>输入：s = “aaabb”, k = 3<br>输出：3<br>解释：最长子串为 “aaa” ，其中 ‘a’ 重复了 3 次。<br>示例 2：</p>
<p>输入：s = “ababbc”, k = 2<br>输出：5<br>解释：最长子串为 “ababb” ，其中 ‘a’ 重复了 2 次， ‘b’ 重复了 3 次。
&nbsp;</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 104<br>s 仅由小写英文字母组成<br>1 &lt;= k &lt;= 105</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li><p>递归</p>
<h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2></li>
<li><p>暂无</p>
</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>首先我是没想出来，看了答案发现了这个思路</li>
<li>要连续子序列也就是想当于如果出现了个数最少的字母，我们需要从那个最少的字母那里断开这个序列，直到把所有少于k的字母全部断开，然后从断开的所有子序列里找个最长的</li>
</ul>
<ul>
<li>对于split 那个function 还是不太清晰，我觉得有必要我整理一下<ul>
<li>The split() method splits a string into a list. 比如： txt = “hello, my name is Peter, I am 26 years old”； x = txt.split(“, “)  output: x=[‘hello’, ‘my name is Peter’, ‘I am 26 years old’]<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2></li>
</ul>
</li>
</ul>
<ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubstring</span>(<span class="params">self, s, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)&lt;k:  <span class="comment">#base </span></span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s.count(c) &lt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>( self.longestSubstring(t, k) <span class="keyword">for</span> t <span class="keyword">in</span> s.split(c) )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>return 那块，前面self.longestSubstring，前面已经有self,后面的括号里就不要加了</li>
<li>s.split(c) 这个语句中，如果输入是“aaabb”. 输出是[“aaa”,”,”]</li>
</ul>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n<em>26)$  n(字符串长度)</em>(字符集) 因为递归最多26次（26个英文字母）</li>
<li>空间复杂度：$O(26^2)$  每层需要开辟26个字母的空间</li>
</ul>
<h2 id="大佬解题"><a href="#大佬解题" class="headerlink" title="大佬解题"></a>大佬解题</h2><ul>
<li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jiang-yuan-zi-fu-chuan-yi-shu-liang-bu-gou-de-zi-f/">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jiang-yuan-zi-fu-chuan-yi-shu-liang-bu-gou-de-zi-f/</a></li>
</ul>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>python 里 sort(),sorted() 的排序算法 -- Timsort简介</title>
    <url>/2021/03/06/python%E9%87%8Csort%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>python里sort排序是一种名为Timsort的排序方法，其时间复杂度为$O(nlogn)$, 而且这是一种快速的稳定排序方法。<br>一个算法的稳定主要是：在假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则这种排序算法是稳定的；否则成为不稳定的。通俗的说， 就是两个相同的值，在排序位置不发生交换，就说稳定的，否则就说不稳定的。在一些条件下，稳定和不稳定也是相对的。</p>
<p>##sort()用法 和 sorted()用法的不同</p>
<ol>
<li>sort()只能用在列表list上，比如list.sort()。 sorted()is a global function。</li>
<li>list.sort is insitu，也就是说不增加一个拷贝，也就是说在原list上进行sort。  sorted增加一个新的copy，与原先的list 无关。Because sorted is a global function, it can take any iterable and return a sorted list from that</li>
<li><h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3></li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>((<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>({<span class="string">'one'</span>:<span class="number">1</span>, <span class="string">'two'</span>:<span class="number">2</span>,<span class="string">'three'</span>:<span class="number">3</span>,<span class="string">'four'</span>:<span class="number">4</span>,<span class="string">'five'</span>:<span class="number">5</span>})</span><br><span class="line">[<span class="string">'five'</span>, <span class="string">'four'</span>, <span class="string">'one'</span>, <span class="string">'three'</span>, <span class="string">'two'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">'this is a string'</span>)</span><br><span class="line">[<span class="string">' '</span>, <span class="string">' '</span>, <span class="string">' '</span>, <span class="string">'a'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'i'</span>, <span class="string">'i'</span>, <span class="string">'n'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'s'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'t'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>###大佬blog</p>
<ol>
<li><a href="http://https//blog.csdn.net/u010883226/article/details/84403263"> “Python里sort（）的排序算法–Timsort简介”</a></li>
<li><a href="https://discuss.codecademy.com/t/what-is-the-difference-between-sort-and-sorted/349679/7">What is the difference between sort() and sorted()?</a></li>
<li><a href="https://www.jianshu.com/p/6b7806c4f54a">Python中的iterable该怎么理解</a></li>
</ol>
]]></content>
      <categories>
        <category>知识及记录</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/03/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><hr>
<p>二分查找也称为折半查找，每次都能查找区间减半，这种折半特性的算法时间复杂度为O(logN)。二分查找不要求序列有序。要求每一次二分后可以定位target在左侧还是右侧，只要能定位target在哪就可以。<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md#leetcode-%E9%A2%98%E8%A7%A3---%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></p>
<span id="more"></span>

<h1 id="二分查找解题思路-and-解题思路（熟到默写）"><a href="#二分查找解题思路-and-解题思路（熟到默写）" class="headerlink" title="二分查找解题思路 and 解题思路（熟到默写）"></a>二分查找<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">解题思路</a> and <a href="https://www.jianshu.com/p/88333f1f02a7">解题思路</a>（熟到默写）</h1><ul>
<li>第一步：通过比较中值与右值来确定最小值的位置范围，进而确定边界收缩的方向。</li>
<li>第二步：分析问题，首先是while循环里的细节问题。这里循环不变的是 <code>left&lt;right</code>, 并且要保证左闭右开区间里面始终套住最小值。中间值的计算是：<code>mid  = left + (right - left)/2</code>。 这是整数除法是向下取整的地板除，<code>mid</code>更靠近<code>left</code>，再结合<code>while</code>循环的条件<code>left&lt;right</code>，可以知道<code>left&lt;=mid</code> ,<code>  right&gt;mid</code>，即在<code>while </code>循环内，<code>mid</code>始终小于<code>right</code>。因此在<code>while</code>循环内，<code>nums[mid]</code>要么大于要么小于 <code>nums[right]</code>，不会等于。这样<code>else{right = mid;}</code>这句判断可以改为更精确的 <code>else if (nums[mid] &lt; nums[right]){right = mid;}</code></li>
<li>第三步<code>while</code> 循环退出的条件。 如果输入数组只有一个数，左右边界位置重合，<code>left == right</code>，不会进去<code>while</code>循环，直接输出。如果输入数组只有一个数，左右边界位置重合，<code>left == right</code>，不会进入<code>while</code>循环，直接输出。如果输入数组多于一个数，循环到最后，会只剩两个数，<code>nums[left] == nums[mid]</code>，以及<code>nums[right]</code>，这里的位置<code>left == mid == right -1</code>。如果<code>nums[left] == nums[mid] &gt; nums[right]</code>，则左边大，右边小，需要执行<code>left = mid + 1</code>，使得<code>left == right</code>，左右边界位置重合，循环结束，<code>nums[left]</code>与<code>nums[right]</code>都保存了最小值。 如果<code>nums[left] == nums[mid] &lt; nums[right]</code>，则左边小，右边大，会执行<code>right = mid</code>，使得<code>left == right</code>， 左右边界位置重合，循环结束，<code>nums[left]</code>、<code>nums[right]</code>、<code>nums[mid]</code>都保存了最小值。</li>
</ul>
<hr>
<h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><hr>
<h2 id="LC69-x-的平方根-x-的平方根"><a href="#LC69-x-的平方根-x-的平方根" class="headerlink" title="(LC69) x 的平方根 x 的平方根"></a>(LC69) x 的平方根 <a href="https://leetcode-cn.com/problems/sqrtx/description/">x 的平方根</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现&nbsp;int sqrt(int x)&nbsp;函数。 计算并返回&nbsp;x&nbsp;的平方根，其中&nbsp;x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li> 二分查找</li>
</ul>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li> 第一步：左闭右开：<code>left</code>有效，<code>right</code>无效。<code>left == mid == right -1</code></li>
<li> 第二步： 使用<code>left&lt;right</code> 作为while循环条件<code>nums[left] == nums[right]</code></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment">#左闭右开</span></span><br><span class="line">        l,r = <span class="number">0</span>,x//<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid  = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">            print(mid)</span><br><span class="line">            <span class="keyword">if</span> mid**<span class="number">2</span> &gt; x:</span><br><span class="line">                r = mid-<span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l  = mid </span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></tbody></table></figure>


<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h2 id="LC69-寻找比目标字母大的最小字母-寻找比目标字母大的最小字母"><a href="#LC69-寻找比目标字母大的最小字母-寻找比目标字母大的最小字母" class="headerlink" title="(LC69) 寻找比目标字母大的最小字母 寻找比目标字母大的最小字母"></a>(LC69) 寻找比目标字母大的最小字母 <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/">寻找比目标字母大的最小字母</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母&nbsp;target，请你寻找在这一有序列表里比目标字母大的最小字母。在比较时，字母是依序循环出现的。<br>举个例子：<br>如果目标字母 target = ‘z’ 并且字符列表为&nbsp;letters = [‘a’, ‘b’]，则答案返回&nbsp;‘a’</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">letters = ["c", "f", "j"]</span><br><span class="line">target = "a"</span><br><span class="line">输出: "c"</span><br></pre></td></tr></tbody></table></figure>

<h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li> 二分查找</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li> 第一步：左闭右开：<code>left</code>有效，<code>right</code>无效。<code>left == mid == right -1</code>，保证左闭右开区间里面始终套住最小值</li>
<li> 第二步： 使用<code>left&lt;right</code> 作为while循环条件<code>nums[left] == nums[right]</code></li>
<li>第三步： 这是循环前升序排列的， 左边比右边大，而且我们要找的是最小值，肯定是偏向左找。这个系统本身就是左右不对称的，本身就有方向性，即使做了旋转，这个不对称性还是存在的，算法的不对称来源于系统本身的不对称。</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: List[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        num_letters =[]</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> letters:</span><br><span class="line">            num_letters.append(<span class="built_in">ord</span>(ch))</span><br><span class="line">        num_target = <span class="built_in">ord</span>(target)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(num_letters)</span><br><span class="line">        mid = (r+l)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;  r:</span><br><span class="line">            mid = (r+l)&gt;&gt;<span class="number">1</span> </span><br><span class="line">            <span class="keyword">if</span> mid == <span class="built_in">len</span>(num_letters): <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> num_letters[mid] &gt; num_target:</span><br><span class="line">                r = mid </span><br><span class="line">            <span class="keyword">elif</span> num_letters[mid] &lt;= num_target:</span><br><span class="line">                l = mid+<span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> l == <span class="built_in">len</span>(num_letters): <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> letters[r]</span><br></pre></td></tr></tbody></table></figure>


<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h2 id="LC278-第一个错误的版本-第一个错误的版本"><a href="#LC278-第一个错误的版本-第一个错误的版本" class="headerlink" title="(LC278) 第一个错误的版本 第一个错误的版本"></a>(LC278) 第一个错误的版本 <a href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用&nbsp;bool isBadVersion(version)&nbsp;接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5)&nbsp;-&gt; true</span><br><span class="line">调用 isBadVersion(4)&nbsp;-&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="前置知识-2"><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li> 二分查找</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li> 第一步：左闭右开：<code>left</code>有效，<code>right</code>无效。<code>left == mid == right -1</code>，保证左闭右开区间里面始终套住最小值</li>
<li> 第二步： 使用<code>left&lt;right</code> 作为while循环条件<code>nums[left] == nums[right]</code> ，</li>
<li>第三步： 如果isBadVersion(mid)返回false， 我们知道<code>mid</code>左侧的所有版本都是正确的版本。所以left = mid +1，下一次的搜索空间变为<code>[mid+1, right)</code>。如果isBadVersion(mid)返回true， 我们知道<code>mid</code>右侧的所有版本都不是第一个错误的版本。所以’right = mid+1’。，下一次的搜索空间变为<code>[left, mid+1)</code>。当某一次操作后，<code>left</code> 和 <code>right</code>的值相等，此时他们就表示了第一个错误版本的位置</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r = <span class="number">1</span>, n</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:  <span class="comment">#左闭右开</span></span><br><span class="line">            mid = (r + l) &gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isBadVersion(mid):</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></tbody></table></figure>


<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：$O(logn)$。搜索空间每次减少一半，因此时间复杂度为$O(logn)$。</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h2 id="LC153-寻找旋转排序数组中的最小值-寻找旋转排序数组中的最小值"><a href="#LC153-寻找旋转排序数组中的最小值-寻找旋转排序数组中的最小值" class="headerlink" title="(LC153) 寻找旋转排序数组中的最小值 寻找旋转排序数组中的最小值"></a>(LC153) 寻找旋转排序数组中的最小值 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为[4,5,6,7,0,1,2] 。<br>请找出其中最小的元素。 </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure>

<h3 id="前置知识-3"><a href="#前置知识-3" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li> 二分查找</li>
</ul>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><ul>
<li> 第一步：左闭右开：<code>left</code>有效，<code>right</code>无效。<code>left == mid == right -1</code></li>
<li> 第二步： 使用<code>left&lt;right</code> 作为while循环条件<code>nums[left] == nums[right]</code></li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="comment">#左闭右开</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            <span class="comment">#偏向左找</span></span><br><span class="line">            mid = (r+l)&gt;&gt;<span class="number">1</span></span><br><span class="line">            print(mid,r,l)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[r]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br><span class="line">            </span><br></pre></td></tr></tbody></table></figure>


<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：$O(log n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>分治</title>
    <url>/2021/03/18/%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%88%86%E6%B2%BB.md">分治</a></h2><h3 id="思路是："><a href="#思路是：" class="headerlink" title="思路是："></a>思路是：</h3><p>(1) 将一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分为更小的子问题—分 （2) 将最后子问题可以简单的直接求解—“治” （3) 将所有子问题的解合并起来就说原问题的解—“合”</p>
<span id="more"></span>

<p><strong>目录 (Table of Contents)</strong></p>
<!-- toc -->


<p>[TOC]</p>
<h3 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h3><p>（1） 将问题的规模缩小到一定的程度就可以容易地解决<br>（2） 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。<br>（3） 利用该问题分解出的子问题的解可以合并为该问题的解。<br>（4） 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算计算复杂度一般是随着问题规模的增加而增加； 第二个特征是应用分治法的前提它也是大多数问题可以解决的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具有第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p>
<h2 id="1-LC241-为运算表达式设计优先级-为运算表达式设计优先级"><a href="#1-LC241-为运算表达式设计优先级-为运算表达式设计优先级" class="headerlink" title="1. (LC241) 为运算表达式设计优先级 为运算表达式设计优先级"></a>1. (LC241) 为运算表达式设计优先级 <a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">为运算表达式设计优先级</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +,&nbsp;-&nbsp;以及&nbsp;*&nbsp;。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: "2-1-1"</span><br><span class="line">输出: [0, 2]</span><br><span class="line">解释: </span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></tbody></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>分治： 自顶向下地拆分子问题</li>
<li>分解：每一步都针对一个运算符分割表达式。</li>
<li>解决：递归停止条件，无运算符只有数字</li>
<li>合并</li>
<li>递归的方式去寻找子问题和原问题解的关系。 可以通过运算符把整个式子分成两部分，两部分再利用递归解决。</li>
</ul>
<h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i,char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>]:</span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:i])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">'+'</span>:</span><br><span class="line">                            res.append(r+l)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">'-'</span>:</span><br><span class="line">                            res.append(l-r)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">'*'</span>:</span><br><span class="line">                            res.append(l*r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<p>####复杂度分析  </p>
<h2 id="2-LC95-不同的二叉搜索树-II-不同的二叉搜索树-II"><a href="#2-LC95-不同的二叉搜索树-II-不同的二叉搜索树-II" class="headerlink" title="2. (LC95) 不同的二叉搜索树 II 不同的二叉搜索树 II"></a>2. (LC95) 不同的二叉搜索树 II <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">&nbsp; [1,null,3,2],</span><br><span class="line">&nbsp; [3,2,null,1],</span><br><span class="line">&nbsp; [3,1,null,null,2],</span><br><span class="line">&nbsp; [2,1,3],</span><br><span class="line">&nbsp; [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></tbody></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>分治： 自顶向下地拆分子问题</li>
<li>分解：每一步都针对一个运算符分割表达式。</li>
<li>解决：递归停止条件，无运算符只有数字</li>
<li>合并</li>
<li>递归的方式去寻找子问题和原问题解的关系。 可以通过运算符把整个式子分成两部分，两部分再利用递归解决。通过利用查找二叉树的性质。左子树的所有值小于根节点，右子树的所有值都大于根节点。<ul>
<li>我们需要把1作为根节点，[]空作为左子树，[2,…,n] 的所有可能作为右子树</li>
<li>n 作为根节点，[1,..,n]的所有可能作为左子树，[]作为右子树</li>
<li>至于上面提到的 [2,…,n]的所有可能以及其他可能，可以利用上面的方法，把每个数字作为根节点，然后把所有可能的左子树和右子树组合起来即可。</li>
<li>如果只有一个数字，那么所有可能就说一种情况，把该数字作为一棵树。而如果是[]，那么返回null。</li>
</ul>
</li>
</ul>
<h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_gen</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> [TreeNode(nums[<span class="number">0</span>])]</span><br><span class="line">            </span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> _gen(nums[:i]):</span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> _gen(nums[i+<span class="number">1</span>:]):</span><br><span class="line">                        ans.append(TreeNode(nums[i], left = left, right = right))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> _gen(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)))</span><br></pre></td></tr></tbody></table></figure>
<p>####复杂度分析  </p>
<h2 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/44213575">“python算法实现-分治法”</a></li>
</ol>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode竞赛(第231场周赛)</title>
    <url>/2021/03/07/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B231/</url>
    <content><![CDATA[<p> 就做出来第一题和第二题<br> <span id="more"></span></p>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>(5697.检查二进制字符串字段)[<a href="https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/]">https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/]</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二进制字符串 s ，该字符串不含前导零 。</p>
<p>如果 s 最多包含 一个由连续的 ‘1’ 组成的字段 ，返回 true​​​ 。否则，返回 false 。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "1001"</span><br><span class="line">输出：false</span><br><span class="line">解释：字符串中的 1 没有形成一个连续字段。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>出现01字符串就输出错误</li>
<li>如果一直为0，则可以</li>
</ol>
<h2 id="反省"><a href="#反省" class="headerlink" title="反省"></a>反省</h2><ol>
<li><p>这次这个题真不难，但是看题的时候没看明白题。 本题的意思是只要有一个1就算是连续字段，比如“10011”, 输出也是false。 因为第一个数字1就已经算是一个由1组成的字符串了，后面的11是第二个连续1的字段了。</p>
</li>
<li><p>map()函数完全可以不用啊，但是既然用了，还不熟知识点那块还是记录一下吧。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2></li>
<li><p>map函数的原型是map(function,iterable,…)，它的返回结果是一个列表。 参数function传的是一个函数名，可以是python内置的，也可以是自定义的。参数iterable传的是一个可以迭代的对象，例如列表，元组，字符串。  这个函数的意思是将function应用于iterable的每一个元素，结果以列表的形式返回。 注意到后面，iterable后面有省略号，意思是可以传很多个iterable，如果有额外的iterable参数，并行的从这些参数中取出元素，并调用function。如果一个iterable 参数比另外的iterable参数要短，将以None扩展参数元素</p>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">c=<span class="string">"zhangkang"</span></span><br><span class="line"></span><br><span class="line">la=<span class="built_in">map</span>(<span class="built_in">str</span>,a)</span><br><span class="line">lb=<span class="built_in">map</span>(<span class="built_in">str</span>,b)</span><br><span class="line">lc=<span class="built_in">map</span>(<span class="built_in">str</span>,c)</span><br><span class="line"></span><br><span class="line">print(la)</span><br><span class="line">print(lb)</span><br><span class="line">print(lc)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line">[<span class="string">'z'</span>, <span class="string">'h'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>, <span class="string">'k'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>] </span><br></pre></td></tr></tbody></table></figure>
<p>str()是Python的内置函数，这个例子是把列表/元组/字符串的每个元素变成了str 类型，然后以列表的形式返回。当然我们也可以传入自定义的函数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">n=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">res=<span class="built_in">map</span>(mul,n)</span><br><span class="line">输出：[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>] </span><br></pre></td></tr></tbody></table></figure>
<p>把列表n中的每个元素运行一次mul函数后得到的结果作为最终结果列表的元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list3=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">res=<span class="built_in">map</span>(add,list1,list2,list3)</span><br><span class="line">print(res)</span><br><span class="line">输出：[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>] </span><br></pre></td></tr></tbody></table></figure>


<p>并行的从三个列表中各自取出元素然后运行add函数，有人可能会问，如果三个列表长度不一样怎么办，前面已经说了，对于短的那个iterable参数会用None填补。对于上面的例子，如果list3=[1,2]的话，那么这个程序会报错，因为虽然在运行add函数的时候列表list3的最后一个元素会用None填补，但是None和int类型的数是不能相加的。也就是说，除非参数function支持None的运算，否则根本没意义。现在我们看下另一个例子你就明白了</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x,y,z</span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">list3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">res = <span class="built_in">map</span>(add, list1, list2, list3)</span><br><span class="line">print(res)</span><br><span class="line">输出：</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="literal">None</span>, <span class="number">4</span>, <span class="number">4</span>), (<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">5</span>)]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOnesSegment</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span>  <span class="comment">#大佬解题</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s.count(<span class="string">'01'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOnesSegment</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span>  <span class="comment"># 本菜</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        s= <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,s))   <span class="comment">#不用map这行      </span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[r] == s[<span class="number">0</span>] <span class="keyword">and</span> r == <span class="number">1</span>:  <span class="comment"># s[r] == '1'</span></span><br><span class="line">                <span class="keyword">while</span> r&lt;n <span class="keyword">and</span> s[r] == s[<span class="number">0</span>]:</span><br><span class="line">                    r+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[r]!= s[<span class="number">0</span>]:</span><br><span class="line">                r+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>


<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h1 id="2-题目"><a href="#2-题目" class="headerlink" title="2. 题目"></a>2. 题目</h1><p>(5698.构成特定和需要添加的最少元素)[<a href="https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum/]">https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum/]</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。<br>返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。<br>注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [1,-1,1], limit = 3, goal = -4</span><br><span class="line">输出：2</span><br><span class="line">解释：可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 = -4 。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li><p>除法：</p>
<ul>
<li>传统除法：如果是整数除法则执行地板除，如果是浮点除法则执行精确除法<br><code>&gt;&gt;&gt;1/2   &gt;&gt;&gt;0   &gt;&gt;&gt;1.0/2.0 &gt;&gt;&gt;0.5</code></li>
<li>地板除法：//除法不管操作数为何种数值类型，总是会舍去小数部分，返回数字序列中比真正的商小的最接近的数字<br>`&gt;&gt;&gt;1//2  &gt;&gt;&gt;0   &gt;&gt;&gt;-1//2  &gt;&gt;&gt;-‘</li>
</ul>
</li>
<li><p>ceil,floor,round</p>
<ul>
<li>ceil() 将小数部分一律向整数部分进位，函数返回数字的上入整数 ‘ceil(-45.17): -45’</li>
<li>floor() 一律舍去，仅保留整数</li>
<li>round() 四舍五入</li>
</ul>
</li>
</ol>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul>
<li>小学数学，反正这类的题要先手写几个例子 </li>
</ul>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minElements</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], limit: <span class="built_in">int</span>, goal: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> ceil(<span class="built_in">abs</span>(goal - <span class="built_in">sum</span>(nums)) / limit)</span><br></pre></td></tr></tbody></table></figure>


<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针（easy篇）</title>
    <url>/2021/03/18/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="双指针-顺序"><a href="#双指针-顺序" class="headerlink" title="#双指针 (顺序)"></a>#双指针 (<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-two-sum">顺序</a>)</h2><p>双指针用于遍历数组，两个指针指向不同的元素，从而共同的完成一个任务。<br>（1）共同完成一个和的target<br>（2）从后往前，从前往后，两边夹击，快慢指针</p>
<p><strong>目录 (Table of Contents)</strong></p>
<p>[TOCM]</p>
<p>[TOC]</p>
<p>##1. (LC167) 两数之和 II - 输入有序数组   <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">两数之和II</a></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个已按照 升序排列&nbsp; 的整数数组&nbsp;numbers ，请你从数组中找出两个数满足相加之和等于目标数&nbsp;target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br> 示例 1：</p>
<p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>双指针<br>如何想到双指针，我觉得首先是这个数组是有序的，然后就是由两个数构成，这就想到了双指针了</p>
<h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt; right:</span><br><span class="line">            total = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> total &gt; target:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]                </span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>时间复杂度：$O(n)$ 只是遍历了一次</li>
<li>空间复杂度：$O(1)$ 只用了两个额外的变量（不考虑输出变量空间，只考虑额外的）</li>
</ul>
<p>##2. (LC633) 两数平方和   <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">两数平方和</a></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。</p>
<p>示例 1：</p>
<p>输入：c = 5<br>输出：true<br>解释：1 * 1 + 2 * 2 = 5<br>范围：0 &lt;= c &lt;= 2^31 - 1</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先这个又是两个整数的，我们想如果出现两个整数共同来完成一件事，这两个整数在一个范围内，是不是都可以用双指针呢。<br>但是这里面有平方比较麻烦了，所以上面那个不是和吗，我想如果求出c的根号是不是在这附近的数就比较好找了</p>
<h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span>(<span class="params">self, c: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sqr</span>(<span class="params">c</span>):</span></span><br><span class="line">            x0 = c/<span class="number">2</span></span><br><span class="line">            x1 = x0/<span class="number">2</span> + c/(x0*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">abs</span>(x1-x0) &gt; <span class="number">1</span>:</span><br><span class="line">                x0 = x1</span><br><span class="line">                x1 = x0/<span class="number">2</span> + c/(x0*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> x1</span><br><span class="line">        right,left = <span class="built_in">int</span>(sqr(c)),<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            print(left**<span class="number">2</span> + right**<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> left**<span class="number">2</span> + right**<span class="number">2</span> &gt; c:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> left**<span class="number">2</span> + right**<span class="number">2</span> &lt; c:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> </span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>时间复杂度：$O(sqr(c)*n1)$ 只是遍历了一次 def sqrt(c)</p>
</li>
<li><p>空间复杂度：$O(1)$ 只用了两个额外的变量</p>
<p>##3. (LC345) 反转字符串中的元音字母<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" title="反转字符串中的元音字母">反转字符串中的元音字母</a>  </p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br>示例 1：<br>输入：”hello”<br>输出：”holle”</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></li>
</ul>
<ol>
<li><p>首先使用双指针是因为，反转字符串中，是两个两个一对的换，通俗的意思是，如果是简单的反转字母是, ‘abc’ 反转之后变为 ‘cba’</p>
</li>
<li><p>有一个概念很重要，就是<a href="https://zhuanlan.zhihu.com/p/34395671" title="可变对象和不可变对象">可变对象和不可变对象</a><br> (1) 可变：list, dic, set （2）不可变：tuple, string, int, float, bool</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 不可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></tbody></table></figure>
<p>从上面的例子可以看出来，可变对象是可以直接被改变的，而不可变对象则不可以</p>
<h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">list</span>(s))&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        front = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        vowels = {<span class="string">"a"</span>,<span class="string">"e"</span>,<span class="string">"i"</span>,<span class="string">"o"</span>,<span class="string">"u"</span>,<span class="string">"A"</span>,<span class="string">"E"</span>,<span class="string">"I"</span>,<span class="string">"O"</span>,<span class="string">"U"</span>} </span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> front&lt; end:</span><br><span class="line">            <span class="keyword">if</span> s[front] <span class="keyword">in</span> vowels <span class="keyword">and</span> s[end] <span class="keyword">in</span> vowels:</span><br><span class="line">                s[front], s[end] = s[end] , s[front]</span><br><span class="line">                front+=<span class="number">1</span></span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[front] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                front+=<span class="number">1</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<ul>
<li>时间复杂度：$ $</li>
<li>空间复杂度：$ $  </li>
</ul>
<p>##4. (LC680)  验证回文字符串 Ⅱ <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" title="验证回文字符串 Ⅱ">验证回文字符串 Ⅱ</a></p>
<h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br>示例 1：<br>输入：”hello”<br>输出：”holle”</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>Lambda 函数<br>lambda 函数是一个小型匿名函数。lambda 函数可以接受任意数量的参数，但只能有一个表达式。<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Function that returns square of any number</span></span><br><span class="line">&gt;&gt;&gt;sqr = <span class="keyword">lambda</span> x: x * x</span><br><span class="line">&gt;&gt;&gt;sqr(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">100</span></span><br></pre></td></tr></tbody></table></figure></li>
<li> 优美的一行代码<br><a href="https://zhuanlan.zhihu.com/p/345055254" title="25条很棒的Python一行代码，建议收藏！">25条很棒的Python一行代码，建议收藏！</a><h3 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> s: s == s[::-<span class="number">1</span>]</span><br><span class="line">        strPart = <span class="keyword">lambda</span> s, x: s[:x] + s[x + <span class="number">1</span>:]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strPart(s, left)) <span class="keyword">or</span> isPalindrome(strPart(s, right))</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<ul>
<li>时间复杂度：$ $</li>
<li>空间复杂度：$ $  </li>
</ul>
<p>##5. (LC88)  合并两个有序数组合并两个有序数组  <a href="https://leetcode-cn.com/problems/merge-sorted-array/description/">合并两个有序数组</a></p>
<h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给你两个有序整数数组&nbsp;nums1 和 nums2，请你将 nums2 合并到&nbsp;nums1&nbsp;中，使 nums1 成为一个有序数组。</p>
<p>初始化&nbsp;nums1 和 nums2 的元素数量分别为&nbsp;m 和 n 。你可以假设&nbsp;nums1 的空间大小等于&nbsp;m + n，这样它就有足够的空间保存来自 nums2 的元素。</p>
<p>示例 1：</p>
<p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p> 需要从尾开始遍历， 否则在num1上归并得到的值会覆盖还未进行归并比较的值</p>
<h3 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># two get pointers for nums1 and nums2</span></span><br><span class="line">       p1 = m - <span class="number">1</span></span><br><span class="line">       p2 = n - <span class="number">1</span></span><br><span class="line">       <span class="comment"># set pointer for nums1</span></span><br><span class="line">       p = m + n - <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment"># while there are still elements to compare</span></span><br><span class="line">       <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">and</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">               nums1[p] = nums2[p2]</span><br><span class="line">               p2 -= <span class="number">1</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               nums1[p] =  nums1[p1]</span><br><span class="line">               p1 -= <span class="number">1</span></span><br><span class="line">           p -= <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment"># add missing elements from nums2</span></span><br><span class="line">       nums1[:p2 + <span class="number">1</span>] = nums2[:p2 + <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>时间复杂度：$O(n+m) $</p>
</li>
<li><p>空间复杂度：$O(1) $没有额外的变量产生  </p>
<p>##6. (LC141)   环形链表 环形链表  <a href="https://leetcode-cn.com/problems/linked-list-cycle/description/">环形链表</a></p>
<h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，判断链表中是否有环。</p>
</li>
</ul>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>(1) 从力扣官网上看到的<a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">龟兔赛跑算法</a></p>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<ul>
<li><p>细节： 为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>
<ul>
<li>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</li>
</ul>
<h3 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>##7. (LC141)  通过删除字母匹配到字典里最长单词  <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">通过删除字母匹配到字典里最长单词</a></p>
<h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p>
<p>示例 1:</p>
</li>
</ul>
<p>输入:<br>s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]<br>输出:<br>“apple”</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>(1)  首先是字符串字典顺序是啥意? 只听说过数的运算，字符串怎么进行运算呢？字符串运算是灵活，又有点复杂的。<a href="https://zhuanlan.zhihu.com/p/91137723">python字符串数据类型</a>。其中我们讲一下字符串的关系运算，采用 ‘&lt;’, ‘&lt;=’, ‘&gt;’, ‘&gt;=’, ‘==’, ‘!=’ 关系运算符对两个字符串进行比较，其实是依次对两个字符串同位置上字符的ADCII 码进行比较。需要注意的是如果如果第一个字符能比较出大小来，不会往后比较，第一个字符相同的话，才往后进行比较<br>(2)  这个题进行双指针也是挺明显的，首先是两个字符串进行遍历的比较。第二是前面也有提到的是，字符串是可变的，所以可以进行比较的。</p>
<h3 id="Python3-Code-6"><a href="#Python3-Code-6" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        len_ans = <span class="number">0</span></span><br><span class="line">        ans = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> dst <span class="keyword">in</span> dictionary:</span><br><span class="line">            i = <span class="number">0</span> </span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(dst):<span class="comment"># 先判断是不是符合条件的字符串</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == dst[j]:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(dst): <span class="comment">#判断是不是字典序最小的</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; len_ans:</span><br><span class="line">                    len_ans,ans = <span class="built_in">len</span>(dst), dst</span><br><span class="line">                <span class="keyword">elif</span> j == len_ans <span class="keyword">and</span> dst &lt; ans:</span><br><span class="line">                    len_ans,ans = <span class="built_in">len</span>(dst), dst</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure>
]]></content>
  </entry>
  <entry>
    <title>声学信号处理系列（一）--声学信号处理基础知识</title>
    <url>/2021/03/07/%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%970_%E5%A3%B0%E5%AD%A6%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="声学信号处理系列（一）–声学信号处理基础知识"><a href="#声学信号处理系列（一）–声学信号处理基础知识" class="headerlink" title="声学信号处理系列（一）–声学信号处理基础知识"></a>声学信号处理系列（一）–声学信号处理基础知识</h1><p><em>by max</em></p>
<p><em>2021/03/07</em></p>
<h2 id="0-写在开始的话"><a href="#0-写在开始的话" class="headerlink" title="0.写在开始的话"></a>0.写在开始的话</h2><p>这个博客系列里，会介绍一些声学信号处理领域相关的基础性知识，以及工业界学术界主流的一些算法应用方向。主要会关注与本人工作相关的一些细分领域，例如：语音增强、声纹识别、麦克风阵列、声学场景识别以及声纹识别反欺骗等诸多方向。随着系列博客文章的积累，会逐渐关注并提供更多应用领域的介绍。本系列旨在记录平时工作中学习到的新知识，也希望能跟别人分享自己的一些心得体会。个人水平有限，如有疏漏错误，敬请批评指正，谢谢！</p>
<span id="more"></span>

<h2 id="1-声学基础"><a href="#1-声学基础" class="headerlink" title="1.声学基础"></a>1.声学基础</h2><p>声音是自然界中非常常见的一种信号之一，我们平时的生活中声音无处不在。人类可以通过声音，来对物体进行感知、辨认和定位。同样，声音也是日常我们互相交流时用于传递信息文字的“载具”。</p>
<p>初高中物理课上大家应该都学到过，声音的本质是物体振动生成的声波，该声波通过某种介质（例如空气、水和固体）传播并能被人类或者动物的听觉器官所感知。声音的频率一般会以赫兹表示，记为Hz，指每秒钟周期性震动的次数。而分贝是用来表示声音强度的单位，记为dB[1]。</p>
<h2 id="2-我们如何发出声音"><a href="#2-我们如何发出声音" class="headerlink" title="2.我们如何发出声音"></a>2.我们如何发出声音</h2><p>正如上一小节中所介绍的，发出声音需要凭借物体的振动。那么我们人类从口腔中发出各种各样的声音，也正是依靠我们的声带的振动来实现的。具体说来，从我们肺部内排出的气体气流，在经过形态变化的声带结构时，带动声带产生振动，进而生成了声波，声波经过我们的口腔和嘴，传输到外界空气中。在整个过程里，由于每个人类个体的声带器官、口腔腔体和嘴部的生理结构都是各异的，所以也导致我们每个人说出来的话的语音语调，以及包括音色，都是不同的。需要注意的是，由于鼻腔和口腔在人体内部是连通的，也会参与到发声过程中来。</p>
<p>下图是一个口腔内部的各个器官的展示，体内从肺部出来的气流，经气管-&gt;声带-&gt;咽喉-&gt;口鼻，传出体外。</p>
<p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3541145379,2023942298&amp;fm=15&amp;gp=0.jpg" alt="avatar"></p>
<h2 id="3-一些基本的专业词汇-2"><a href="#3-一些基本的专业词汇-2" class="headerlink" title="3.一些基本的专业词汇[2]"></a>3.一些基本的专业词汇[2]</h2><ul>
<li>音节（Syllable）：说话时一次发出的，具有一个响亮的中心，并被明显感觉到的语音片段。</li>
<li>音素（Phoneme）：语音发音的最小单位。一个音节可以由一个或多个音素构成。音素可分为元音和辅音两种。</li>
<li>元音（Vowel）：当声带振动发出的声音气流从咽喉进入口腔并从嘴部唇部出去时，这些声腔完全开放，气流可以顺利通过时所发的音，称为元音。元音构成音节的主干，无论从长度或是能量角度考虑，元音在音节中都占主要部分。决定元音音色的主要因素是舌头的形状及其在口腔中的位置，以及嘴唇的形状等。口腔中当舌头处于不同的舌位高度和舌位前后时，可以发出不同的音素。下图是一个单元音发音舌位示意图：</li>
</ul>
<img src="/images/vowels.gif" width="50%" height="50%" align="center/">

<ul>
<li>辅音（Consonant）：当呼出的气流，由于整个声腔通路上某一部分封闭起来或受到阻碍，气流传播不通畅，而克服发音器官的这种阻碍时所发的音，称为辅音。发辅音时，声带振动的是浊音，声带不振动的是清音。辅音只出现在音节的前端或后端或前后两端，时长和能量相比元音都很小。</li>
<li>半元音：有时，虽然声道基本畅通，但某处声道较窄，引起轻微的摩擦声，称为半元音。</li>
</ul>
<h2 id="4-共振峰（Formant）与基频F0（Fundamental-frequency）"><a href="#4-共振峰（Formant）与基频F0（Fundamental-frequency）" class="headerlink" title="4.共振峰（Formant）与基频F0（Fundamental frequency）"></a>4.共振峰（Formant）与基频F0（Fundamental frequency）</h2><p>共振峰和基频F0是语音信号处理中较为重要的概念，所以单独拿出来介绍一下。</p>
<p>(1)共振峰：前面介绍过发声机理，其中声道可以被等效视为一根横截面非均匀的声管，在发声过程中，该声管起共鸣器的作用。当一个具有相对较大能量的元音激励进入声道时，会引起共振特性，产生一组共振频率，称为共振峰频率，可简称为共振峰。换句话说，共振峰不是特指某一个频率的振动信号，而是代指一组具有不同频率的共振信号，这组信号里，每个信号所处的频率是不同的，但是是连续存在的。</p>
<p>一般可以用共振峰频率的位置和频带宽度这两个参数来描述一组共振峰。每个不同的元音，都对应着一组不同的共振峰参数。共振峰中的信号通常用F来表示，例如F0，F1，F2…等等。</p>
<p>(2)基频F0：基频又称基础频率，其定义为共振峰中第一个共振信号的振动频率。共振峰中除基频F0以外，其他共振信号均为口腔共振产生，而基频F0由声带振动产生，其能量一般为共振峰中最强的。有时将音调（pitch）和基频等效看待，二者其实有一些细节上的不同，但平时讨论时可以暂时视为一体。音调反应的是音高的信息，男性和女性的平均音调范围是不同的，男性更低一些，女性更高一些。</p>
<p>任何为基频整倍数的频率上的信号称为谐波。谐波反应的是音色的信息。</p>
<p>通常我们可以通过观测语音信号的语谱图，来对共振峰和基频有一个直观的了解。语谱图是将语音的频谱信号以二维形式所描绘出来的图形，该图形横轴为时间，单位通常为秒s，纵轴为频率，单位通常为赫兹Hz。图形上颜色的深浅代表声学信号能量强度的高低。一个典型的反应了共振峰的语谱图如下所示：</p>
<img src="/images/spectrogram_formants.png" width="50%" height="50%" align="center/">

<h2 id="5-我们如何听到声音"><a href="#5-我们如何听到声音" class="headerlink" title="5.我们如何听到声音"></a>5.我们如何听到声音</h2><p>人类听到声音的简要过程：空气中的声波传播到人耳内，耳朵内的鼓膜受到声波的声压的作用会产生位移振动，内耳的一个主要器官耳蜗，将这种位移振动的机械信息，转换为生物神经信号，传递给大脑进行处理后，我们就能够获知听到的是什么声音了。具体的介绍请移步参考资料[2]中的2.4.2节，会有更详尽的了解。</p>
<p>人耳一般能接收并处理的声音的频率范围为20Hz<del>20kHz，强度为-5</del>130dB。在此范围外的声学信号里的音频分量，是人耳处理不到的，一般在语音信号处理领域的问题中不会考虑。但是，凡事无绝对，我们也不能说在这个范围以内的音频分量我们一定能听得到，这就涉及到一个概念叫做听觉掩蔽效应。</p>
<p>听觉掩蔽效应指的是在一个强信号附近，弱信号将变得听不到，被掩盖掉了。生活中这种例子常见的有：购物商场的大喇叭在外放吵闹的音乐时，两个人的对话可能即使很近也听不清楚。被掩蔽掉的不可闻信号的最大声压级称为掩蔽门限或掩蔽阈值，在这个掩蔽阈值以下的声音都会被掩盖掉。</p>
<h2 id="参考资料列表"><a href="#参考资料列表" class="headerlink" title="参考资料列表"></a>参考资料列表</h2><p>[1] 维基百科-声音词条：<a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E9%9F%B3">https://zh.wikipedia.org/wiki/%E5%A3%B0%E9%9F%B3</a></p>
<p>[2] 赵力. 语音信号处理[M]. 机械工业出版社, 2016.</p>
]]></content>
      <categories>
        <category>知识及记录</category>
      </categories>
      <tags>
        <tag>声学信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>排序 （熟到可以默写）</title>
    <url>/2021/03/18/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="排序顺序"><a href="#排序顺序" class="headerlink" title="排序顺序"></a>排序<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%8E%92%E5%BA%8F.md">顺序</a></h2><p>思路是：</p>
<p>（1）快速选择，用于求解第k个元素的问题</p>
<p>（2）堆:堆的中心就一个，那就是动态求极值。 堆可以用二叉树实现，叫做二叉堆。二叉堆的性质就是堆的性质不变。</p>
<p> (3) 三向快排： 快排的核心思想是选择一个枢纽，左边的都比枢纽小，右边的都比枢纽大。 然后堆分成的两部分再进行递归快排。 但是如果有很多重复元素的时候呢，因为快排会对一个都是重复元素的数组再进行递归，其实我们已经知道了， 不用再进行递归了，因为已经是有序的了。 怎么实现呢？<br>    - 三向排序： 对于一个数组，一次扫描要有三个指针。</p>
<p><strong>目录 (Table of Contents)</strong></p>
<p>[TOCM]</p>
<p>[TOC]</p>
<p>##1. (LC215) Kth Element <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">Kth Element</a></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br> 示例 1：<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>最简单的是排序想法，直接把数组排序，然后找到k个就好了</li>
<li>堆， 堆是一种数据结构，一个很牛的<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ge-chong-pai-xu-suan-fa-tu-xie-zong-jie-by-ke-ai-x/">题解</a>和一个英文<a href="https://towardsdatascience.com/data-structure-heap-23d4c78a6962">解释</a> 和一个中文<a href="https://guguoyu.blog.csdn.net/article/details/81283998?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs">解释</a></li>
<li><a href="https://docs.python.org/3/library/heapq.html">heapq</a> 模块： 可能在面试过程中，有的面试官不让用，但是这个heapq还是很方便的。 (1)hq.heapqpush(heap,item) ：压入堆的意思，压入的是item （2）hq.heappop(heap)：弹出且返回最小的。hq.heappushpop(heap,item):先压入iem，然后弹出堆里最小的项。</li>
</ol>
<h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest1</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment">#1. 排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest2</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 2. 最大堆  用heapq模块</span></span><br><span class="line">        <span class="keyword">import</span> heapq <span class="keyword">as</span> hq</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            hq.heappush(heap,i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                hq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest3</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 3.  最大堆， 构造堆模块</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">min_heapify</span>(<span class="params">array, i</span>):</span></span><br><span class="line">            left = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            length = <span class="built_in">len</span>(array) - <span class="number">1</span></span><br><span class="line">            smallest = i</span><br><span class="line">            <span class="keyword">if</span> left &lt;= length <span class="keyword">and</span> array[i] &gt; array[left]:</span><br><span class="line">                smallest = left</span><br><span class="line">            <span class="keyword">if</span> right &lt;= length <span class="keyword">and</span> array[smallest] &gt; array[right]:</span><br><span class="line">                smallest = right</span><br><span class="line">            <span class="keyword">if</span> smallest != i:</span><br><span class="line">                array[i], array[smallest] = array[smallest], array[i]</span><br><span class="line">                min_heapify(array, smallest)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_min_heap</span>(<span class="params">array</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(array)//<span class="number">2</span>)):</span><br><span class="line">                min_heapify(array, i)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">array</span>):</span></span><br><span class="line">            <span class="comment">#array = array.copy()</span></span><br><span class="line">            build_min_heap(array)</span><br><span class="line">            sorted_array = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">                array[<span class="number">0</span>], array[-<span class="number">1</span>] = array[-<span class="number">1</span>], array[<span class="number">0</span>]</span><br><span class="line">                sorted_array.append(array.pop())</span><br><span class="line">                min_heapify(array, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sorted_array</span><br><span class="line">        result = heapsort(nums)</span><br><span class="line">        <span class="keyword">return</span> result[-k]</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest4</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment"># 4. 快速排序 [快速排序](https://jackkuo666.github.io/Data_Structure_with_Python_book/chapter6/section4.html)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">alist, low ,high</span>):</span></span><br><span class="line">            mid_value = alist[low]</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid_value:</span><br><span class="line">                    high-=<span class="number">1</span></span><br><span class="line">                alist[low] = alist[high]</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt;= mid_value:</span><br><span class="line">                    low+=<span class="number">1</span></span><br><span class="line">                alist[high] = alist[low]</span><br><span class="line">            alist[low] = mid_value</span><br><span class="line">            <span class="keyword">return</span> low</span><br><span class="line">        k = <span class="built_in">len</span>(nums) - k</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums) -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            p = partition(nums,low ,high)</span><br><span class="line">            <span class="keyword">if</span> k &lt; p:</span><br><span class="line">                high = p - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> k &gt; p:</span><br><span class="line">                low = p + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[p]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">         </span><br></pre></td></tr></tbody></table></figure>
<p>##2. (LC347) 前 K 个高频元素 <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前 K 个高频元素</a></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素<br> 示例 1：<br>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>最简单的是排序想法，直接把数组排序，但是不满足时间复杂度的要求， 这里有个一个点是sort()函数，单独有一篇文章讲。</li>
<li>进一步，为了满足时间复杂度的要求，需要对解法一的排序过程进行改进。因为最终需要返回前k个频率最大的元素，可以想到借助堆这种数据结构。通过维护一个元素数目为k的最小堆，每次都将新的元素与对顶端的元素（也就是堆中频率最小的元素）进行比较，如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中。最终，堆中的k个元素即为前k个高频元素。 其中用到了.items(), #The items() method returns a view object. The view object contains the key-value pairs of the dictionary, as tuples in a list.</li>
<li>桶排序(bucket sort)，用空间复杂度换取时间复杂度的方法。为每一个数字设置一个桶，桶中是该数字出现的次数，然后对桶进行排序，实际上，上面的排序算法就说使用普通的排序方法对频率桶进行了排序，现在我们使用桶排序对频次惊醒排序。 桶排序为了进一步优化时间复杂度。 先统计数组中元素的频次。接着，将数组中的元素按着出现频次进行分组，即出现频次为i的元素存放在第i个桶，最后从桶中逆序取出前k个元素。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_1</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 1. 排序</span></span><br><span class="line">        freq_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums: <span class="comment"># 统计元素的频率</span></span><br><span class="line">            freq_dict[num] = freq_dict.get(num , <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        freq_dict_sort = <span class="built_in">sorted</span>(freq_dict.items(), key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line">        ret = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            ret.append(freq_dict_sort[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_2</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 2. 堆排序</span></span><br><span class="line">		freq_dict = <span class="built_in">dict</span>() <span class="comment"># 统计元素的频率</span></span><br><span class="line">		<span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">			freq_dict[num] = freq_dict.get(num,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 维护一个大小为k的最小堆，使得堆中的元素即为前k个高频元素</span></span><br><span class="line">		pq = <span class="built_in">list</span>()</span><br><span class="line">		<span class="keyword">for</span> key,value <span class="keyword">in</span> freq_dict.items(): </span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(pq)&lt; k:</span><br><span class="line">				heapq.heappush(pq, (value,key))</span><br><span class="line">			<span class="keyword">elif</span> value &gt; pq[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">				heapq.heapreplace(pq, (value,key))</span><br><span class="line">		ret = <span class="built_in">list</span>()</span><br><span class="line">		<span class="keyword">while</span> pq:</span><br><span class="line">			ret.append(heapq.heappop(pq)[<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">topKFrequent_3</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span> <span class="comment"># 3. 桶排序</span></span><br><span class="line">		freq_dict = <span class="built_in">dict</span>() <span class="comment"># 统计元素频率</span></span><br><span class="line">		<span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">			freq_dict[num] = freq_dict.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">		bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+ <span class="number">1</span>)]</span><br><span class="line">		<span class="keyword">for</span> key, value <span class="keyword">in</span> freq_dict.items():</span><br><span class="line">			bucket[value].append(key)</span><br><span class="line">		ret = <span class="built_in">list</span>() <span class="comment">#  逆序取出前k个元素</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(nums))):</span><br><span class="line">			<span class="keyword">if</span> bucket[i]:</span><br><span class="line">				ret.extend(bucket[i])</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(ret)&gt;=k:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">return</span> ret[:k]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ol>
<li>排序</li>
</ol>
<ul>
<li>时间复杂度：$O(nlogn)$</li>
<li>空间复杂度：$O(n)$ : 最极端的情况下（每个元素都不同），用于存储元素及其频率的map需要存储n个键值对</li>
</ul>
<ol start="2">
<li>堆排序</li>
</ol>
<ul>
<li>时间复杂度：$O(nlogk)$ 其中n表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是O(n);接着，遍历用于存储元素频率的map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这一系列操作的时间复杂度是O(nlogk)的；最后，弹出堆中的元素所需要的时间复杂度O(klogk)。因此总的时间复杂度是O(nlogk)</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<ol start="2">
<li>桶排序</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$ 数组的长度</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<p>##3. (LC75) 颜色分类 <a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含红色、白色和蓝色，一共&nbsp;n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、&nbsp;1 和 2 分别表示红色、白色和蓝色。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li>三路快排</li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul>
<li>在快排的基础上，将组数分为三个部分，及大于、等于、小于三个部分，其中大于和小于部分继续递归快排  </li>
<li>（lc官方解题）我们使用一个指针ptr表示头部位置的范围，ptr中存储了一个整数，表示数组nums从位置0到位置ptr - 1都属于【头部】。ptr的初始值为0，表示还没数处于【头部】。 在第一次遍历中，我们从左向右遍历整个数组，如果找到了0，那么就需要将0与【头部】位置的元素位置进行交换，并将【头部】向后扩充一位，结束后头部只有0。第二次同上。但是我们想要一次遍历怎么办，我们就要俩个指针。 </li>
<li>我们用指针p0 来交换 0， p1来交换1，初始值都是0。当从左向右遍历整个数组时:<br>  (1) 如果找到1， 那么将其与nums[p1]进行交换，并将p1向后移动一个位置。<br>  （2) 如果找到了0， 那么将其与nums[p0]交换的话，可能把1也交换出去。当p0 &lt; p1时，我们需要再将nums[i] 与nums[p1]进行交换，其中</li>
</ul>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul>
<li> 双指针</li>
</ul>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        p0 = p1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                nums[i] , nums[p1] = nums[p1] , nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i] , nums[p0] = nums[p0] , nums[i]</span><br><span class="line">                <span class="keyword">if</span> p0 &lt; p1:</span><br><span class="line">                    nums[i] , nums[p1] = nums[p1] , nums[i]</span><br><span class="line">                p0+=<span class="number">1</span></span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h3 id="大佬解题"><a href="#大佬解题" class="headerlink" title="大佬解题"></a>大佬解题</h3><ol>
<li><a href="https://www.cnblogs.com/xugenpeng/p/9950007.html#%E6%8F%8F%E8%BF%B0">【LeetCode题解】347_前K个高频元素（Top-K-Frequent-Elements）</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>搜索（BFS, DFS, Backtracking）</title>
    <url>/2021/03/18/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="搜索（BFS-DFS-Backtracking）"><a href="#搜索（BFS-DFS-Backtracking）" class="headerlink" title="搜索（BFS, DFS, Backtracking）"></a>搜索（BFS, DFS, Backtracking）</h1><hr>
<p>广度优先算法（Breadth-First-Search），简称BFS。深度优先算法（Deep-First-Search），简称DFS。BFS:利用队列先进先出的特性，可以优先遍历横向节点。DFS:利用栈先进后出的特性，可以优先遍历纵向节点。<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md">搜索</a></p>
<hr>
<p>深度优先搜索和广度优先搜索广泛应用于树和图中。 （1） BFS  (2) DFS (3) Backtracking</p>
<span id="more"></span>

<h1 id="BFS-广度优先搜索）"><a href="#BFS-广度优先搜索）" class="headerlink" title="BFS (广度优先搜索）"></a>BFS (广度优先搜索）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p>广度优先算法（BFS）：是一种图形搜索演算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点，如果发现目标，则演算终止。</p>
<h2 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h2><p>BFS是一种盲目搜寻法，目的是系统的展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为主。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>邻接表的时候是$O(|V|+|E|)$。其中，$|V|$是节点的数目，$|E|$是图中边的数目。</p>
<h2 id="适应条件："><a href="#适应条件：" class="headerlink" title="适应条件："></a>适应条件：</h2><p>对于所有边长度相同的情况，比如地图的模型，BFS第一次遇到目标点，此时就一定是从根节点到目标节点的最短路径（因为每次所有的点都是向外扩张一步，你先遇到，那你就一定最短的了）。<strong>BFS先找到的一定是最短的</strong>。但是如果是加权边的话就会有问题，BFS传回的是经过<strong>边数最少</strong>的解，但是因为加权了，这个解到根节点的<strong>距离</strong>就不一定是最短的了。比如1000+1000是两段，1+1+1是三段，但是由于BFS返回的是是<strong>经过边数最少的的解</strong>，这里就会返回总长度是2000的那个解，但是显然不是距离最短的路径。此时我们就应该采用<strong>Dijkstra最短路算法</strong>解决加权路径的最短路了（这就有点超纲了呀）。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li>寻找非加权图(或者所有边权重是一样)中任两点的最短路径。</li>
<li>寻找其中一个连通分支中的所有节点（扩散性）。</li>
<li>BFS染色法判断是否为二分图</li>
</ol>
<h2 id="大佬解释BFS"><a href="#大佬解释BFS" class="headerlink" title="大佬解释BFS"></a>大佬解释BFS</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/40151973#:~:text=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88Breadth%2DFirst,%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BB%A5%E6%89%BE%E5%AF%BB%E7%BB%93%E6%9E%9C%E3%80%82">BFS算法介绍</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/50187643">算法- 从栈 &amp; 队列 到 BFS &amp; DFS</a></li>
<li><a href="https://www.jianshu.com/p/d2125448270b">用Python实现树的BFS与DFS</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/141898546">LeetCode | 一文帮你搞定BFS、DFS算法（python版）</a></li>
</ol>
<hr>
<h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><hr>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="LC1091-计算在网格中从原点到特定点的最短路径长度-计算在网格中从原点到特定点的最短路径长度"><a href="#LC1091-计算在网格中从原点到特定点的最短路径长度-计算在网格中从原点到特定点的最短路径长度" class="headerlink" title="(LC1091)计算在网格中从原点到特定点的最短路径长度   计算在网格中从原点到特定点的最短路径长度 "></a>(LC1091)计算在网格中从原点到特定点的最短路径长度   <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">计算在网格中从原点到特定点的最短路径长度 </a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p> 给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：路径途经的所有单元格都的值都是 0 。路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。畅通路径的长度 是该路径途经的单元格总数。 </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：grid = [[0,1],[1,0]]</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li>Deque(class collections.deque([iterable[,maxlen]])) [使用戳一戳](collections中 deque的使用)<ul>
<li>Deque是双边队列（double-ended queue），具有队列和栈的性质，在 list 的基础上增加了移动、旋转和增删等。</li>
<li>Deque队列是由栈或者queue队列生成的（发音是”deck”,”double-ended queue”的简称）。</li>
<li>Deque是一个双端队列, 如果要经常从两端append 的数据, 选择这个数据结构就比较好了, 如果要实现随机访问,不建议用这个,请用列表。Deque 优势就是可以从两边append ,appendleft 数据。这一点list 是没有的<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">queue = deque([<span class="string">"Eric"</span>, <span class="string">"John"</span>, <span class="string">"Michael"</span>])</span><br><span class="line">queue.append(<span class="string">"Terry"</span>)           <span class="comment"># Terry 入队</span></span><br><span class="line">queue.append(<span class="string">"Graham"</span>)          <span class="comment"># Graham 入队</span></span><br><span class="line">queue.popleft()                 <span class="comment"># 队首元素出队</span></span><br><span class="line"><span class="comment">#输出: 'Eric'</span></span><br><span class="line">queue.popleft()                 <span class="comment"># 队首元素出队</span></span><br><span class="line"><span class="comment">#输出: 'John'</span></span><br><span class="line">print(queue)                           <span class="comment"># 队列中剩下的元素</span></span><br><span class="line"><span class="comment">#输出: deque(['Michael', 'Terry', 'Graham'])</span></span><br></pre></td></tr></tbody></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>第一次刷这个BFS,毫无头绪，怎么办？首先是看到大佬的一个模板，先偷过来</li>
</ol>
<ul>
<li> 第一步：先构造图<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initial_graph</span>(<span class="params">n, edges</span>):</span></span><br><span class="line">    dict_graph = {}  <span class="comment">#用字典表示</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dict_graph[i] = []</span><br><span class="line">    num_e = <span class="built_in">len</span>(edges)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_e):</span><br><span class="line">        u = edges[i][<span class="number">0</span>] <span class="comment">#用矩阵表示</span></span><br><span class="line">        v = edges[i][<span class="number">1</span>]</span><br><span class="line">        dict_graph[u].append(v)</span><br><span class="line">        dict_graph[v].append(u)</span><br><span class="line">    <span class="keyword">return</span> dict_graph</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<ul>
<li><p>第二步：使用队列<br>  BFS适用于层级搜索，队列先进先出，量身定做。python中队列有两种导入方法：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 1.使用queue  #队列</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line">q = Queue() <span class="comment"># 定义，为什么是这样涉及python的设计，不是很懂</span></span><br><span class="line">q.put(node) <span class="comment"># 放入</span></span><br><span class="line">q.get() <span class="comment"># 出队</span></span><br><span class="line"><span class="comment"># 2.使用deque</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">q = collections.deque() <span class="comment"># 双向队列</span></span><br><span class="line">q.append() <span class="comment"># 入队</span></span><br><span class="line">q.popleft() <span class="comment"># 出队</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>第三步：节点入队</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 使用Queue()定义</span></span><br><span class="line">q.put(start_node)</span><br><span class="line"><span class="comment"># 为防止无向图中回溯，使用set阻断</span></span><br><span class="line">hash_set = <span class="built_in">set</span>()</span><br><span class="line">hash_set.add(start_node)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第四步：BFS主体</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">	size = <span class="built_in">len</span>(q)</span><br><span class="line">	step += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> iter_num <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">		node = q.get() <span class="comment"># current node</span></span><br><span class="line">		<span class="comment"># get the neighbor</span></span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> dict_graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor == end_node: <span class="comment"># find it!!!!</span></span><br><span class="line">				<span class="keyword">return</span> step</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> hash_set:</span><br><span class="line">				<span class="keyword">continue</span> <span class="comment"># avoid backtracking</span></span><br><span class="line">			hast_set.add(node)</span><br><span class="line">			q.put(neighbor)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> <span class="comment"># can't find</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ol start="2">
<li>具体操作</li>
</ol>
<ul>
<li>本题本身就是矩阵，就不需要重新弄建initial。从头遍历，每次遇到0的时候，将周围8个方向可走的点push进队列，这样就可以将下一步能走的点找到。</li>
<li>用一个大小为3的数组来保存当前点的坐标，和走到当前点所需要的代价</li>
<li>由于要找的是花费路径最短的，所以第一个符合循环结束条件的数组，其第三个值就是我们要找的最小代价</li>
</ul>
<h4 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">or</span> grid[n - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>:  <span class="comment"># 若起始点或终点堵塞，则不可能有这样的路径</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">1</span>  <span class="comment"># 注意题目的描述，是返回从 1 到 k 的路径，第一个节点被定为下标 1，</span></span><br><span class="line">        path = deque()</span><br><span class="line">        path.append([<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 先压入起点</span></span><br><span class="line">        <span class="keyword">while</span> path:  <span class="comment"># BFS模板</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path)):  <span class="comment"># 对BFS的某一层的中所有点向8个方向进行扩展</span></span><br><span class="line">                x, y = path.popleft()</span><br><span class="line">                <span class="keyword">for</span> new_x, new_y <span class="keyword">in</span> [[x - <span class="number">1</span>, y - <span class="number">1</span>], [x - <span class="number">1</span>, y], [x - <span class="number">1</span>, y + <span class="number">1</span>], [x, y - <span class="number">1</span>],</span><br><span class="line">                                     [x, y + <span class="number">1</span>], [x + <span class="number">1</span>, y - <span class="number">1</span>], [x + <span class="number">1</span>, y], [x + <span class="number">1</span>, y + <span class="number">1</span>]]:</span><br><span class="line">                    <span class="comment"># 下面几种continue可以合并一行，这里为看的清楚就分开写了</span></span><br><span class="line">                    <span class="keyword">if</span> new_x == n - <span class="number">1</span> <span class="keyword">and</span> new_y == n - <span class="number">1</span>:  <span class="comment"># 如果扩展的点到达了终点</span></span><br><span class="line">                        <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_x &lt; n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_y &lt; n:  <span class="comment"># 扩展的点超出边界，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">1</span>:  <span class="comment"># 若扩展的点为阻塞，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == -<span class="number">1</span>:  <span class="comment"># 若扩展的点已经访问过，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">0</span>:  <span class="comment"># 若为通畅点</span></span><br><span class="line">                        grid[new_x][new_y] = -<span class="number">1</span>  <span class="comment"># 当前层次下已经访问该点</span></span><br><span class="line">                        path.append([new_x, new_y])  <span class="comment"># 将扩展的点加入path，到下一层的时候继续扩展</span></span><br><span class="line">            res += <span class="number">1</span>  <span class="comment"># 对某一层的元素都求判定过后，距离加1(同一个层次中的所有点的距离距离起点都是相等的）</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解"><a href="#大佬题解" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC297-完全平方数-完全平方数"><a href="#LC297-完全平方数-完全平方数" class="headerlink" title="(LC297)完全平方数   完全平方数 "></a>(LC297)完全平方数   <a href="https://leetcode-cn.com/problems/perfect-squares/description/">完全平方数 </a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定正整数&nbsp;n，找到若干个完全平方数（比如&nbsp;1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。</li>
<li><a href="https://leetcode-cn.com/problems/perfect-squares/solution/dong-tai-gui-hua-bfs-zhu-xing-jie-shi-python3-by-2/">广度优先遍历</a></li>
<li><h4 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4></li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([n])  <span class="comment">#必须带[]，否则不是iterable </span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            step +=<span class="number">1</span></span><br><span class="line">            l = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                temp = queue.pop()  <span class="comment"># 不能用 queue.popleft() 因为后面用的是appendleft。前后只能有一个left</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(temp**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">                    x = temp - i**<span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> step</span><br><span class="line">                    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(x)</span><br><span class="line">                        queue.appendleft(x)</span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></tbody></table></figure>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-1"><a href="#大佬题解-1" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC"><a href="#LC" class="headerlink" title="(LC )    "></a>(LC )   <a href=""> </a></h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-2"><a href="#大佬题解-2" class="headerlink" title="大佬题解"></a>大佬题解</h4><hr>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><hr>
<h3 id="LC-1"><a href="#LC-1" class="headerlink" title="(LC )    "></a>(LC )   <a href=""> </a></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>
<h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-3"><a href="#大佬题解-3" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-2"><a href="#LC-2" class="headerlink" title="(LC )    "></a>(LC )   <a href=""> </a></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-4"><a href="#Python3-Code-4" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>
<h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-4"><a href="#大佬题解-4" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-3"><a href="#LC-3" class="headerlink" title="(LC )    "></a>(LC )   <a href=""> </a></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-5"><a href="#Python3-Code-5" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>
<h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-5"><a href="#大佬题解-5" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-4"><a href="#LC-4" class="headerlink" title="(LC )    "></a>(LC )   <a href=""> </a></h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-6"><a href="#Python3-Code-6" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>
<h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-6"><a href="#大佬题解-6" class="headerlink" title="大佬题解"></a>大佬题解</h4><h3 id="LC-5"><a href="#LC-5" class="headerlink" title="(LC )    "></a>(LC )   <a href=""> </a></h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><h4 id="Python3-Code-7"><a href="#Python3-Code-7" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></tbody></table></figure>
<h4 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="大佬题解-7"><a href="#大佬题解-7" class="headerlink" title="大佬题解"></a>大佬题解</h4>]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>经典到默写的</title>
    <url>/2021/03/18/%E7%86%9F%E5%88%B0%E9%BB%98%E5%86%99/</url>
    <content><![CDATA[<p>默写吧</p>
<span id="more"></span>


<h2 id="1-基于分治的快速排序"><a href="#1-基于分治的快速排序" class="headerlink" title="1. 基于分治的快速排序"></a>1. 基于分治的快速排序</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>每次取list 的第一个元素，把剩下的元素与第一个元素比较，此时生成两个list,less中存放的就是余下的所有比第一个元素小的list, greater 中存放的是余下的所有比第一个元素大的list。然后循环递归，当基线条件只有一个元素或0个元素时停止，并返回结果。</li>
</ul>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">def quick_sort(arr):</span><br><span class="line">	if len(arr)&lt;2:</span><br><span class="line">		return arr</span><br><span class="line">	else:</span><br><span class="line">		pivot = arr[0]</span><br><span class="line">		less = [i for i in arr[1:] if i&lt;=pivot]  </span><br><span class="line">		greater = [i for i in arr[1:] if i&gt;pivot]</span><br><span class="line">		return quick_sort(less) + pivot + quick_sort(greater)</span><br><span class="line">if __name__ == "__main__":</span><br><span class="line"> </span><br><span class="line">    arr = [5,7,9,3,6,1,4,2]</span><br><span class="line">	print(quick_sort(arr))</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ2OTAxNS8yMDE5MDMvMTQ2OTAxNS0yMDE5MDMyNjE4MTQ1MzY3My0xODk3MDkyNTUwLnBuZw?x-oss-process=image/format,png"></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2021/03/18/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md">贪心</a></h2><p>思路是：(1) 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的 (2)贪心算法一般是先需要排序的。</p>
<span id="more"></span>

<p><strong>目录 (Table of Contents)</strong></p>
<!-- toc -->


<p>[TOC]</p>
<p>##1. (LC455) 分发饼干 <a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>对每个孩子 i，都有一个胃口值&nbsp;g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]&nbsp;。如果 s[j]&nbsp;&gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>排序+贪心：我觉得这个也很好想，因为我们要求分配给最多的小孩的数量，肯定是可着吃的少的孩子先来。因为一个大胖子吃10斤的，可以给10个吃一斤的孩子啊。</p>
</li>
<li><p>贪心贪在哪里：</p>
</li>
</ul>
<ul>
<li> 在示例中可以看到，在计算起点的时候，一定从g[i] 最小的开始计算， 也就是优先给需求低的分配最下尺寸的饼干，这就是贪心的地方。</li>
<li>局部最优：每个小孩得到的饼干最少化，多一点都不给，多给浪费的呀</li>
<li>全局最优：保障让每一个饼干刚好满足当前的小朋友，就可以使得最后满足的人数最多。</li>
</ul>
<h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: List[<span class="built_in">int</span>], s: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(g) <span class="comment">#greed factor</span></span><br><span class="line">        m = <span class="built_in">len</span>(s) <span class="comment">#size</span></span><br><span class="line">        i = <span class="number">0</span> </span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;m <span class="keyword">and</span> i&lt;n:</span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> g[i]&gt;s[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; m:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></tbody></table></figure>
<p>####复杂度分析</p>
<ul>
<li>时间复杂度： $O( m log m + n logn)$ 其中m和n分别是数组g和s的长度。对两个数组排序的时间复杂度是 $O(mlogm+nlogn)$，遍历数组的时间复杂度是$O(m+n)$。</li>
<li>空间复杂度：$O(log m + log n)$ 其中m和n分别是数组g和s的长度。主要是排序的额外空间开销。</li>
</ul>
<p>##2. (LC435) 无重叠区间 <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>排序+贪心：这个题还是排序+贪心。为什么这么说呢，首先区间边界没有相互重叠，和第一题的分饼干相似。这种类型的题的思路是，每一步都选的很小心，生怕影响后面的人。</li>
</ol>
<h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        points = <span class="built_in">sorted</span>(points,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        print(points)</span><br><span class="line">        right = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt;right:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">                right = points[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>
<p>####复杂度分析</p>
<ul>
<li>时间复杂度： $O(n logn)$ 其中n是数组的长度。 </li>
<li>空间复杂度：$O(log n)$  </li>
</ul>
<p>##3. (LC406) 根据身高重建队列 <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">根据身高重建队列</a></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。<br>请你重新构造并返回输入数组&nbsp;people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>排序+贪心： </li>
</ol>
<h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x:(-x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(people) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> people</span><br><span class="line">        <span class="comment">## 对队列排序，先按h降序，再按k升序</span></span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        new_people = [people[<span class="number">0</span>]]    <span class="comment"># 这个人是从前往后、从上往下看到的第一个人</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> people[<span class="number">1</span>:]:</span><br><span class="line">            new_people.insert(i[<span class="number">1</span>], i)</span><br><span class="line">        <span class="keyword">return</span> new_people</span><br></pre></td></tr></tbody></table></figure>
<p>####复杂度分析</p>
<ul>
<li>时间复杂度： $O(n^2)$，其中n是数组people的长度。我们需要O(n log n) 的时间进行排序，随后需要O(n^2)的时间遍历每一个人并将他们放入队列中。由于前者在渐近意义下小于后者，因此总时间复杂度为  O(n^2)</li>
<li>空间复杂度：$O( log n )$  </li>
</ul>
<p>##4. (LC53) 最大子序和 <a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>-贪心， 贪心竟然这么难想</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ul>
<li>贪心贪在哪里（<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/53-zui-da-zi-xu-he-bao-li-tan-xin-dong-t-jkeq/">详解</a>）？</li>
</ul>
<ul>
<li><p>如果在示例中可以看到 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心的地方！</p>
</li>
<li><p>局部最优：当前 “ 连续和 ”为负数的时候立即放弃，从下一个元素重新计算 “ 连续和 ”， 因为负数加上下一个“连续和”只会越来越小。</p>
</li>
<li><p>全局最优：选取最大“连续和”  </p>
</li>
<li><p>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2></li>
</ul>
<ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br><span class="line">        ans = -inf</span><br><span class="line">        result = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> ans&gt;<span class="number">0</span>:</span><br><span class="line">                ans += nums[i] </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = nums[i]</span><br><span class="line">            result = <span class="built_in">max</span>(result,ans)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>

<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<p>##5. (LC53) 用最少数量的箭引爆气球 <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/">用最少数量的箭引爆气球</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 &nbsp;xstart&nbsp;≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</span><br></pre></td></tr></tbody></table></figure>

<h2 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><p>-贪心+排序</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">                   [10.........16]</span><br><span class="line">   [2..........8]</span><br><span class="line">[1.......6]</span><br><span class="line">            [7.........12]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>贪心贪在<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/tu-jie-tan-tao-wei-shi-yao-yao-an-qu-jian-de-you-d/">哪里</a>？</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2></li>
<li><p>语言支持：Python3</p>
</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        points = <span class="built_in">sorted</span>(points,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        print(points)</span><br><span class="line">        right = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt;right:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">                right = points[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>

<p><strong>复杂度分析</strong></p>
<p>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>排序</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/03/18/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md#7-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C">刷题顺序</a></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><ul>
<li><p>Important notice: 涉及到链表的操作，一定要在纸上把过程先画出来，再写程序！不要断链子。</p>
<span id="more"></span>
</li>
<li><p>注意<a href="https://zhuanlan.zhihu.com/p/53691100">防止锻链</a>，因为一旦把节点的指针反向了，当前的指针就不再指向下一个节点了，因为也就i不能再继续往后遍历了，也就不能把这个完整的链表进行反转了，这种情况称作断链。为了解决断链的情况，我们就需要再节点指针反向之前，就把当前节点的下一个节点先记下来，等到当前节点的指针完成反转之后，遍历指针直接移动到刚刚被记住的那个节点，这样就能防止锻炼的情况了。具体操作如下：<a href="https://zhuanlan.zhihu.com/p/53691100">讲解1</a></p>
</li>
<li></li>
<li><p>注意：我们经常需要定义一个哨兵节点<code>prehead</code>，这可以在最后让我们比较容易地返回合并后的链表。</p>
</li>
</ul>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol>
<li>双指针：</li>
<li>栈：</li>
</ol>
<!-- more -->


<h2 id="1-LC160-相交链表-相交链表"><a href="#1-LC160-相交链表-相交链表" class="headerlink" title="1. (LC160) 相交链表 相交链表"></a>1. (LC160) 相交链表 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">相交链表</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>  图解</p>
<img src="/images/链表lc160.png" width="50%" height="50%" align="center/">
</li>
<li><p>数学思维</p>
</li>
</ol>
<ul>
<li> 我们假设<code>A</code>的头节点到交汇点的距离为<code>a</code>， <code>B</code>的头节点到交汇点的距离为<code>b</code>，交会点最后的距离为<code>c</code>。</li>
<li> <code>A</code>指针<code>cur_A</code>总共走了<code>a+b-c</code>步，<code>B</code>指针<code>cur_B</code>总共走了<code>b+a-c</code>步，所以会两个指针相同，达到终止条件。当没有交点的时候，<code>A</code>指针<code>cur_A</code>总共走了<code>a+b</code>步，<code>B</code>指针<code>cur_B</code>总共走了<code>b+a</code>步，也会两个指针相同指向null，达到终止条件。</li>
</ul>
<ol start="3">
<li>思路总结</li>
</ol>
<ul>
<li>链表来说，首先是先动手走一走，再一个如果碰到交点问题，要看看怎么才能得到一个等式。</li>
</ul>
<h3 id="Python3-Code"><a href="#Python3-Code" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span>  <span class="comment">#双指针</span></span><br><span class="line">        cur_A = headA</span><br><span class="line">        cur_B = headB</span><br><span class="line">        <span class="keyword">while</span> cur_A != cur_B:</span><br><span class="line">            cur_A = cur_A.<span class="built_in">next</span> <span class="keyword">if</span> cur_A <span class="keyword">else</span> headB</span><br><span class="line">            cur_B = cur_B.<span class="built_in">next</span> <span class="keyword">if</span> cur_B <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> cur_A</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>时间复杂度：$O(n+m)$ n是链表A的长度，m是链表B的长度  </li>
<li>空间复杂度：$O(1)$  </li>
</ul>
<h2 id="2-LC2206-反转链表-反转链表"><a href="#2-LC2206-反转链表-反转链表" class="headerlink" title="2. (LC2206) 反转链表 反转链表"></a>2. (LC2206) 反转链表 <a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>反转一个单链表。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>双指针：为了防止断链子，要保持下一个节点<code>temp</code>和前一个节点<code>pre</code></p>
</li>
<li><p>递归：和双指针是一样的逻辑，同样是当<code>cur</code>为空的时候循环结束，不断将<code>cur</code>指向<code>pre</code>的过程。递归的这个好绕啊，第一遍没太理解，先记下来吧。一个很好的解释，慢慢理解，<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">戳这里</a></p>
</li>
<li><p>栈：最简单的一种方式就是使用栈，因为栈是先进后出的，实现原理是把链表点一个个入栈，当全部入栈之后在一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。</p>
<h3 id="Python3-Code-1"><a href="#Python3-Code-1" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3></li>
</ol>
<ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span> <span class="comment">#双指针</span></span><br><span class="line">        cur = head</span><br><span class="line">        pre = <span class="literal">None</span>        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span> <span class="comment">#递归</span></span><br><span class="line">		<span class="comment"># 递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span>==<span class="literal">None</span>):</span><br><span class="line">			<span class="keyword">return</span> head</span><br><span class="line">		<span class="comment"># 这里的cur就是最后一个节点</span></span><br><span class="line">		cur = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">		<span class="comment"># 这里请配合动画演示理解</span></span><br><span class="line">		<span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">		<span class="comment"># 而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">		<span class="comment"># 所以head.next.next 就是5-&gt;4</span></span><br><span class="line">		head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">		<span class="comment"># 防止链表循环，需要将head.next设置为空</span></span><br><span class="line">		head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">		<span class="comment"># 每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">		<span class="keyword">return</span> cur </span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        stack = [<span class="literal">None</span>]</span><br><span class="line">        <span class="comment"># 把链表节点全部放到栈中</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            stack.append(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        head = stack.pop()</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 栈中的结点全部出栈，然后重新连成一个新的链表</span></span><br><span class="line">        <span class="keyword">while</span> stack: </span><br><span class="line">            cur.<span class="built_in">next</span> = stack.pop()</span><br><span class="line">            cur =cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 最后一个结点就是反转前的头结点，一定要让他的next</span></span><br><span class="line">        <span class="comment"># 等于空，否则会构成环</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>时间复杂度：$O( )$ n是链表的长度，  </p>
</li>
<li><p>空间复杂度：$O( )$  </p>
<h2 id="3-LC21-合并两个有序链表-合并两个有序链表"><a href="#3-LC21-合并两个有序链表-合并两个有序链表" class="headerlink" title="3. (LC21) 合并两个有序链表 合并两个有序链表"></a>3. (LC21) 合并两个有序链表 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></h2></li>
</ul>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>  迭代</li>
</ol>
<ul>
<li> 首先，我们设定一个哨兵节点<code>prehead</code>，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个<code>prev</code>指针，我们需要做的是调整它的<code>next</code>指针。然后我们重复以下过程，直到<code>l1</code>或者<code>l2</code>指向<code>null</code>。在循环终止的时候，<code>l1</code>和<code>l2</code>至多有一个是非空的。</li>
</ul>
<ol start="2">
<li>递归</li>
</ol>
<h3 id="Python3-Code-2"><a href="#Python3-Code-2" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    dummy = ListNode()</span><br><span class="line">    cur = dummy </span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = l1</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = l2</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>时间复杂度：$O(n+m)$, 其中n和m个链表长度</p>
</li>
<li><p>空间复杂度：$O(1)$  </p>
<h2 id="4-LC83-从有序链表中删除重复节点-从有序链表中删除重复节点"><a href="#4-LC83-从有序链表中删除重复节点-从有序链表中删除重复节点" class="headerlink" title="4. (LC83) 从有序链表中删除重复节点 从有序链表中删除重复节点"></a>4. (LC83) 从有序链表中删除重复节点 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">从有序链表中删除重复节点</a></h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3></li>
</ul>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>  图解</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1614527163-BKaiqs-Picture1.png"></p>
<ol start="2">
<li>数学思维</li>
</ol>
<ul>
<li> 我们假设<code>A</code>的头节点到交汇点的距离为<code>a</code>， <code>B</code>的头节点到交汇点的距离为<code>b</code>，交会点最后的距离为<code>c</code>。</li>
<li> <code>A</code>指针<code>cur_A</code>总共走了<code>a+b-c</code>步，<code>B</code>指针<code>cur_B</code>总共走了<code>b+a-c</code>步，所以会两个指针相同，达到终止条件。当没有交点的时候，<code>A</code>指针<code>cur_A</code>总共走了<code>a+b</code>步，<code>B</code>指针<code>cur_B</code>总共走了<code>b+a</code>步，也会两个指针相同指向null，达到终止条件。</li>
</ul>
<ol start="3">
<li>思路总结</li>
</ol>
<ul>
<li>链表来说，首先是先动手走一走，再一个如果碰到交点问题，要看看怎么才能得到一个等式。</li>
</ul>
<h3 id="Python3-Code-3"><a href="#Python3-Code-3" class="headerlink" title="Python3 Code:"></a>Python3 Code:</h3><ul>
<li>语言支持：Python3</li>
</ul>
<p>Python3 Code:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span>  <span class="comment">#双指针</span></span><br><span class="line">        cur_A = headA</span><br><span class="line">        cur_B = headB</span><br><span class="line">        <span class="keyword">while</span> cur_A != cur_B:</span><br><span class="line">            cur_A = cur_A.<span class="built_in">next</span> <span class="keyword">if</span> cur_A <span class="keyword">else</span> headB</span><br><span class="line">            cur_B = cur_B.<span class="built_in">next</span> <span class="keyword">if</span> cur_B <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> cur_A</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>时间复杂度：$O(n+m)$ n是链表A的长度，m是链表B的长度  </li>
<li>空间复杂度：$O(1)$  </li>
</ul>
]]></content>
  </entry>
</search>
