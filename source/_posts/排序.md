---
title: 排序 （熟到可以默写）
---
排序[顺序](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%8E%92%E5%BA%8F.md)
---
思路是
（1）快速选择，用于求解第k个元素的问题
（2）堆:堆的中心就一个，那就是动态求极值。 堆可以用二叉树实现，叫做二叉堆。二叉堆的性质就是堆的性质不变。
<!-- more -->

**目录 (Table of Contents)**

[TOCM]

[TOC]

##1. (LC215) Kth Element [Kth Element](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/)
### 题目
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
 示例 1：
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5

###  思路
1. 最简单的是排序想法，直接把数组排序，然后找到k个就好了
2. 堆， 堆是一种数据结构，一个很牛的[题解](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ge-chong-pai-xu-suan-fa-tu-xie-zong-jie-by-ke-ai-x/)和一个英文[解释](https://towardsdatascience.com/data-structure-heap-23d4c78a6962) 和一个中文[解释](https://guguoyu.blog.csdn.net/article/details/81283998?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs)
3. [heapq](https://docs.python.org/3/library/heapq.html) 模块： 可能在面试过程中，有的面试官不让用，但是这个heapq还是很方便的。 (1)hq.heapqpush(heap,item) ：压入堆的意思，压入的是item （2）hq.heappop(heap)：弹出且返回最小的。hq.heappushpop(heap,item):先压入iem，然后弹出堆里最小的项。


###  Python3 Code:

```
class Solution:
    def findKthLargest1(self, nums: List[int], k: int) -> int: #1. 排序
        nums.sort()
        return nums[-k]
    def findKthLargest2(self, nums: List[int], k: int) -> int: # 2. 最大堆  用heapq模块
        import heapq as hq
        heap = []
        for i in nums:
            hq.heappush(heap,i)
            if len(heap) > k:
                hq.heappop(heap)
        return heap[0]
    def findKthLargest3(self, nums: List[int], k: int) -> int: # 最大堆， 构造堆模块
        def min_heapify(array, i):
            left = 2 * i + 1
            right = 2 * i + 2
            length = len(array) - 1
            smallest = i
            if left <= length and array[i] > array[left]:
                smallest = left
            if right <= length and array[smallest] > array[right]:
                smallest = right
            if smallest != i:
                array[i], array[smallest] = array[smallest], array[i]
                min_heapify(array, smallest)
        def build_min_heap(array):
            for i in reversed(range(len(array)//2)):
                min_heapify(array, i)
        def heapsort(array):
            #array = array.copy()
            build_min_heap(array)
            sorted_array = []
            for _ in range(len(array)):
                array[0], array[-1] = array[-1], array[0]
                sorted_array.append(array.pop())
                min_heapify(array, 0)
            return sorted_array
        result = heapsort(nums)
        return result[-k]
      def findKthLargest4(self, nums: List[int], k: int) -> int: # [快速排序](https://jackkuo666.github.io/Data_Structure_with_Python_book/chapter6/section4.html)
        def partition(alist, low ,high):
            mid_value = alist[low]
            while low < high:

                while low < high and alist[high] >= mid_value:
                    high-=1
                alist[low] = alist[high]
                while low < high and alist[low] <= mid_value:
                    low+=1
                alist[high] = alist[low]
            alist[low] = mid_value
            return low
        k = len(nums) - k
        low = 0
        high = len(nums) -1
        while low <= high:
            p = partition(nums,low ,high)
            if k < p:
                high = p - 1
            elif k > p:
                low = p + 1
            else:
                return nums[p]
        return -1
         
```
  

 
